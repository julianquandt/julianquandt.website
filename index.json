[{"authors":["admin"],"categories":null,"content":"A PhD student at the Behavioural Science Institute\rat Radboud University\rin Nijmegen working with Harm Veling\r, Rob Holland\r, and Bernd Figner\r.\nIn my PhD project, I aim to increase our understanding confidence in value-based decision-making. The questions that keep me awake at night are:\n How do people retrieve value-information when they make a decision? How does this retrieval of information relate to people\u0026rsquo;s confidence in their decisions? This is, what does high or low confidence in VBD reflect? Why are people confident about some choices while they are uncertain of others?  Aside from working on my dissertation, I also enjoy working on my skills in statistics, statistical modelling and programming (R and python). Moreover, I am an enthusiast of open science, open access, open source and open bars.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://julianquandt.com/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"A PhD student at the Behavioural Science Institute\rat Radboud University\rin Nijmegen working with Harm Veling\r, Rob Holland\r, and Bernd Figner\r.\nIn my PhD project, I aim to increase our understanding confidence in value-based decision-making. The questions that keep me awake at night are:\n How do people retrieve value-information when they make a decision? How does this retrieval of information relate to people\u0026rsquo;s confidence in their decisions?","tags":null,"title":"Julian Quandt","type":"authors"},{"authors":null,"categories":null,"content":"Flexibility This feature can be used for publishing content such as:\n Online courses Project or software documentation Tutorials  The courses folder may be renamed. For example, we can rename it to docs for software/project documentation or tutorials for creating an online course.\nDelete tutorials To remove these pages, delete the courses folder and see below to delete the associated menu link.\nUpdate site menu After renaming or deleting the courses folder, you may wish to update any [[main]] menu links to it by editing your menu configuration at config/_default/menus.toml.\nFor example, if you delete this folder, you can remove the following from your menu configuration:\n[[main]]\rname = \u0026#34;Courses\u0026#34;\rurl = \u0026#34;courses/\u0026#34;\rweight = 50\rOr, if you are creating a software documentation site, you can rename the courses folder to docs and update the associated Courses menu configuration to:\n[[main]]\rname = \u0026#34;Docs\u0026#34;\rurl = \u0026#34;docs/\u0026#34;\rweight = 50\rUpdate the docs menu If you use the docs layout, note that the name of the menu in the front matter should be in the form [menu.X] where X is the folder name. Hence, if you rename the courses/example/ folder, you should also rename the menu definitions in the front matter of files within courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"59c3ce8e202293146a8a934d37a4070b","permalink":"https://julianquandt.com/courses/example/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/courses/example/","section":"courses","summary":"Learn how to use Academic's docs layout for publishing online courses, software documentation, and tutorials.","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 2 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"74533bae41439377bd30f645c4677a27","permalink":"https://julianquandt.com/courses/example/example1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/example/example1/","section":"courses","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim.","tags":null,"title":"Example Page 1","type":"docs"},{"authors":null,"categories":null,"content":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 4 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"1c2b5a11257c768c90d5050637d77d6a","permalink":"https://julianquandt.com/courses/example/example2/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/example/example2/","section":"courses","summary":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus.","tags":null,"title":"Example Page 2","type":"docs"},{"authors":[],"categories":["Power Analysis"],"content":"\r\r\rThe Power Analysis by simulation in R for really any design - Part II\r\rSimulating a between-subjects t-test\rSimulating a within-subject t-test\r\rUsing a one-sample t-test approach\rUsing a correlated-samples paired t-test approach\r\rSummary: Our first simulations with t-tests\r\rFootnotes\r\r\r\r\r\rClick below to download the .Rmd file\r\rDownload power-analysis-by-data-simulation-in-r-part-ii.Rmd\rbutton.btn.collapsed:before\r{\rcontent:'+' ;\rdisplay:block;\rwidth:15px;\r}\rbutton.btn:before\r{\rcontent:'-' ;\rdisplay:block;\rwidth:15px;\r}\r\rThe Power Analysis by simulation in R for really any design - Part II\rThis is Part II of my tutorial on how to do power-analysis by simulation.\rIn Part I, we saw how to do a simulation for a simple toy-example with a coin-toss.\rIn this part, we will use a more realistic problem that we might encounter in our daily research life and see how to simulate the power for these designs.\rBy looking at how to do power-simulation for the independent-samples t-test and the paired t-test we will learn how to simulate normal-distributions, how to specify their effect-sizes, in terms of \\(Cohen\u0026#39;s\\ d\\). Moreover, we simulate correlated (i.e. multivariate) normal distributions in cases where we have correlated observations (e.g. paired-sample t-test).\rThis will be an important tool for later parts of this tutorial.\nIn part III of this tutorial we will learn how we can conceptualize basically any design as a linear model and thereby be very flexible in our power analysis.\rIn part IV we will learn how to apply this technique to complicated designs such as linear mixed-effects models and generalized mixed-effects models.\nSimulating a between-subjects t-test\rLet’s get to it.\rThe first thing we will need again in our simulation is one of the implemented simulation functions in R (those that let R run theoretical experiments for us), but this time it is not rbinom as we are not working with coin-flips but rnorm - the simulation function for the normal distribution.\rLet’s have a short look at that function as we will keep working with it throughout the tutorial.\nrnorm(n, mean, sd) takes three arguments, a sample-size n, a mean and a standard-deviation sd.\rBy specifying these values, we can sample random ‘people’ (or observations) that are participating in our simulated experiments.\rImagine, for example, that we have an intervention study in which we have a treatment group and a control group.\rWe can easily simulate both groups with rnorm but what should the means and sds of the groups be?\nThere are two ways we can approach this.\nWe could think about what group means we expect in our given case and what we expect the spread of the groups to be on the measurment scale that we are working with.\rFor example, if we use a 40-point scale for a clinical test we might know that a group with deficiencies on the thing that we measure would probably score around 10 points and that almost everyone from that group would score lower than 20 points.\rThis statement (most people score around 10, almost everyone scores lower than tified as normal distribution with a mean of 10 and a standard-deviation of 5. In this case only 2.5% of the values (i.e. the values outside the 95% CI) will be higher than 20.\rIn a new research project, we might not be able or willing to to make these statements.\rIn this case, by making some extra assumptions, we can fall back to the approach that we also use in power-calculation software in most cases and define a standardized effect size that we can use to simulate data rather than defining the group means and standard-deviations directly.\r\rI personally try to go with the first approach whenever possible, as I think that in many cases we know more about what we expect from our data than we think, even in new projects.\rEven if we do not know a lot about our data, we might still try out different assumptions (i.e. means and sds) for the groups in our simulation to see what power we would get for each of them.\rThis way, we can make informed decisions about our sample size that are more nuanced than the one in which we just assume a standardized effect size and see what sample-size it implies and are forced to think harder about our data - something that might seem difficult and annoying at first, but is extremely useful and eduucational.\rAnother advantage of specifying the groups directly is that we can do this for any arbitrarily complex design where standardized effect sizes are often difficult to calculate.\nThis said, for the cases where we might really not be willing to specify groups directly, and because it allows me to demonstrate some other interesting points, in this part I will discuss how we can use standardized effect-sizes in our simulation.\rIn part III and IV however, we will always specify effects on the raw scale.\nIf we were using GPower now, we would most likely just fill in a difference between groups in \\(Cohen\u0026#39;s\\ d\\) and be done with it.\rWe could of course also follow this approac in a simulation by defining the groups based on the implied \\(Cohen\u0026#39;s\\ d\\).\rFor instance, we can just assume that group 1 as rnorm(n, 1,2).\rNow, following from the formula for Cohen’s d:\n\\[Cohen\u0026#39;s\\ d = \\frac{(M_1 - M_2)}{pooled \\ sd}\\]\nwhere\n\\[pooled\\ sd = \\sqrt\\frac{(sd_1^2+sd_2^2)}{2}\\]\nand adhering to the student t-test assumption of equal variances we can fill in the pooled sd formula above as\n\\[pooled\\ sd = \\sqrt\\frac{(2^2+2^2)}{2} = 2\\]\nto get a \\(Cohen\u0026#39;s\\ d\\) of .50:\n\\[Cohen\u0026#39;s\\ d = \\frac{(1 - 0)}{2} = 0.5\\]\nTo get any other value for \\(Cohen\u0026#39;s\\ d\\) we can just change the pooled sd value to whatever we want.\rMore generally, we want to solve the equation above for the pooled sd after specifying any \\(Cohen\u0026#39;s\\ d\\), e.g.:\n\\[0.5= \\frac{(1 - 0)}{pooled\\ sd}\\]\nWe can solve an equation like that with R’s somewhat unintuitive solve function like this:\nsolve(0.5,1) # cohens d of .5\r## [1] 2\rsolve(0.25,1) # cohens d of .25\r## [1] 4\rsolve(2,1) # cohens d of 2\r## [1] 0.5\rgiving us three examples of how we would need to specify pooled sd to arrive at a particular \\(Cohen\u0026#39;s\\ d\\).\nThus, if we want to do a t-test with two simulated groups and a cohen’s d of 0.5 we can simulate two groups of a particular sample-size by using the rnorm function.\rLet’s say we have 30 participants in each group.\nset.seed(1234)\rgroup1 \u0026lt;- rnorm(30, 1, 2)\rgroup2 \u0026lt;- rnorm(30, 0, 2)\rWe can visualize the groups that we got in a plot like this:\nhist(group1, col = \u0026quot;#addd8e\u0026quot;, breaks = 10, main = \u0026quot;Histogram of both groups\u0026quot;, xlab = \u0026quot;\u0026quot;)\rhist(group2, add = TRUE, breaks = 10, col= \u0026quot;#31a354\u0026quot;)\rWe can already make important observations from this plot:\nWe wanted to get normal distributions, but what we got here does not really look normal.\rWhy is that? Because we only have 30 people per group and taking only 30 values from the specified normal distributions does not really give us a good approximation of the real distribution.\rThis point is important: The sampling variability in such small groups is high and often, if small sample-studies (i.e. underpowered studies) find “effects”, they are often rather big and the consequence of this sampling variability rather than real differences of groups.\rFor example, by looking at the means of our sampled groups mean(group1) = 0.40715 and mean(group2) = -1.1032366 we see that the group mean of group 1 is actually closer to the mean that we specified for group 2 (i.e. 0) than to its own mean, while the mean for group 2 is far away from our intended mean.\rLooking at the sds actually shows that they are quite close to what we wanted sd(group1) = 1.8059661 and sd(group2) = 1.9179992.\rThe \\(Cohen\u0026#39;s\\ d\\) that we wanted is also not presented very accurately at (mean(group1)-mean(group2))/(sqrt((sd(group1)^2+sd(group2)^2)/2)) = 0.8108043.\rAgain, if we would do this in Gpower, and specify a \\(Cohen\u0026#39;s\\ d\\), we will always work with an exact \\(Cohen\u0026#39;s\\ d\\), in a simulation approach we do not.\nSo let us run a t-test to see whether there is a significant difference here.\rFirst, we need to decide on an alpha-level again.\rWhat will we choose?\rWell, to have a good justification we have to elaborate on what the groups actually represent.\rLet us say that the difference between groups is related to an intervention that can elevate depressive symptoms.\rThus, the control group (group1) did not get the intervention and scores higher on depressive symptoms while the treatment group (group2) is expected to score lower.\rLet us assume that this is the first study that we run and that, if we find anything we will follow it up by more extensive studies anyway. Therefore, we might not want to miss a possible effect by setting a too conservative alpha-level.\rIf we find something in this study, we will conduct further studies in which we are more strict about the alpha level.\rThus, we choose .10 for this first “pilot” study.\n\rNOTE: The alpha-level “jusficications” in this tutorial are for educational purposes and to provide a starting point. They are obviously not as rigorous as we would like in a real research project. If you find yourself in a situation where you want to justify your alpha-level see Justify your alpha by Lakens et al. for a good discussion on this.\r\rWe can now run a t-test with R’s integrated t.test function.\nt.test(group1, group2, paired = FALSE, var.equal = TRUE, conf.level = 0.9)\r## ## Two Sample t-test\r## ## data: group1 and group2\r## t = 3.1402, df = 58, p-value = 0.002656\r## alternative hypothesis: true difference in means is not equal to 0\r## 90 percent confidence interval:\r## 0.7064042 2.3143690\r## sample estimates:\r## mean of x mean of y ## 0.407150 -1.103237\rThe t-test shows, that this effect would be significant.\rHowever, we also got “lucky” and had a larger effect than we intended to have.\rTo do a proper power analysis (lets say we first want to see whether 30 people per group are enough) we need to not only simulate each group once, but many many times and see how often we get a significant result at the desired alpha-level1.\rMoreover, we would like to have a power of at least 95%, again reflecting our view that we do not want to miss a possible effect.\nIn normal language these assumptions mean that if there is a difference, we will detect it in 19 out of 20 cases while, if there is no difference, we will only be incorrectly claiming that there is one in 1 out of 10 cases.\nWe will do this similarly to our simulations in part 1 of this tutorial.\nset.seed(1)\rn_sims \u0026lt;- 1000 # we want 1000 simulations\rp_vals \u0026lt;- c()\rfor(i in 1:n_sims){\rgroup1 \u0026lt;- rnorm(30,1,2) # simulate group 1\rgroup2 \u0026lt;- rnorm(30,0,2) # simulate group 2\rp_vals[i] \u0026lt;- t.test(group1, group2, paired = FALSE, var.equal = TRUE, conf.level = 0.90)$p.value # run t-test and extract the p-value\r}\rmean(p_vals \u0026lt; .10) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)\r## [1] 0.592\rAha, so it appears that our power mean(p_vals \u0026lt; .10) = 0.592 is much lower than the 95% that we desired.\rThus, we did really get lucky in our example above when we found an effect of our intervention.\nTo actually do a legit power-analysis however, we would like to know how many people we do need for a power of 95 percent.\rAgain we can modify the code above to take this into account.\nset.seed(1)\rn_sims \u0026lt;- 1000 # we want 1000 simulations\rp_vals \u0026lt;- c()\rpower_at_n \u0026lt;- c(0) # this vector will contain the power for each sample-size (it needs the initial 0 for the while-loop to work)\rcohens_ds \u0026lt;- c()\rcohens_ds_at_n \u0026lt;- c() n \u0026lt;- 30 # sample-size i \u0026lt;- 2\rwhile(power_at_n[i-1] \u0026lt; .95){\rfor(sim in 1:n_sims){\rgroup1 \u0026lt;- rnorm(n,1,2) # simulate group 1\rgroup2 \u0026lt;- rnorm(n,0,2) # simulate group 2\rp_vals[sim] \u0026lt;- t.test(group1, group2, paired = FALSE, var.equal = TRUE, conf.level = 0.9)$p.value # run t-test and extract the p-value\rcohens_ds[sim] \u0026lt;- abs((mean(group1)-mean(group2))/(sqrt((sd(group1)^2+sd(group2)^2)/2))) # we also save the cohens ds that we observed in each simulation\r}\rpower_at_n[i] \u0026lt;- mean(p_vals \u0026lt; .10) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)\rcohens_ds_at_n[i] \u0026lt;- mean(cohens_ds) # calculate means of cohens ds for each sample-size\rn \u0026lt;- n+1 # increase sample-size by 1\ri \u0026lt;- i+1 # increase index of the while-loop by 1 to save power and cohens d to vector\r}\rpower_at_n \u0026lt;- power_at_n[-1] # delete first 0 from the vector\rcohens_ds_at_n \u0026lt;- cohens_ds_at_n[-1] # delete first NA from the vector\rThe loop stopped at a sample-size of n-1 = 84 participants per group.\rThus make a conclusion about the effectiveness of our intervention at the specified alpha-level with the desired power we need 168 people in total.\nTo visualize the power we can plot it again, just as in the first part of the tutorial.\nplot(30:(n-1), power_at_n, xlab = \u0026quot;Number of participants per group\u0026quot;, ylab = \u0026quot;Power\u0026quot;, ylim = c(0,1), axes = TRUE)\rabline(h = .95, col = \u0026quot;red\u0026quot;)\rAgain, this plot shows us how our power to detect the effect slowly increases if we increase the sample-size until it reaches our desired power.\nThere is another interesting observation to make here.\rIn the code above, I also calculate the average \\(Cohen\u0026#39;s\\ d\\) for each sample size and the plot below shows how it changes with increasing sample-size.\nplot(30:(n-1), cohens_ds_at_n, xlab = \u0026quot;Number of participants per group\u0026quot;, ylab = \u0026quot;Cohens D\u0026quot;, ylim = c(0.45,0.55), axes = TRUE)\rabline(h = .50, col = \u0026quot;red\u0026quot;)\rIt is not super obvious in this plot and I had to change the scale of the y-axis quite a bit to make it visible, but we can actually see how our average \\(Cohen\u0026#39;s\\ d\\) initially deviates slightly more from the desired \\(Cohen\u0026#39;s\\ d\\) of .50 than in de end.\rIn other words, in the beginning, for small sample-sizes there is more fluctuation than for bigger sample-sizes.\rThat is pretty neat, as it seems very desirable that a power-estimation procedure takes into account that for smaller sample-sizes, even if the effect in the population is exactly the same (i.e. we always sample groups with a difference of \\(Cohen\u0026#39;s\\ d\\) = .50) it is just less precise.\nLet’s have a brief summary of what we did so far.\rWe just used the formula for \\(Cohen\u0026#39;s\\ d\\) to give our groups a certain difference that we are interested in, ran 1000 simulated experiments for each sample-size and calculated the power, just as in the first part of the tutorial.\nHowever, I want to mention again that, even though it is convenient to specify the effect-size this way as it saves us from having to specify precise group means and standard-deviations directy and makes the specification more comparable, it is often preferable to specify the parameters on the original scale that we are interested in.\rThis is especially the case if we have previous data on a research topic that we can make use of.\rMoreover, for more complex designs with many parameters, standardized effect sizes are often difficult to obtain and we are forced to make our assumptions on the original scale of the data.\rWe will see this in later examples.\n\rSimulating a within-subject t-test\rIntuitively, it might seem that we can use the exact same approach above for a paired t-test as well.\rHowever, the problem with this is that in a paired t-test we get 2 data-points from the same individual.\rFor example, image we have a group of people that get an intervention and we measure their score before and after the intervention and want to compare them with a paired t-test.\rIn this case, the score of the post-measure of a given individual is not completely independent of the score of the pre-measure.\rIn other words, somebody who scores very low on the pre-measure will most likely not score very high on the post-measure and vice versa.\nThus, there is a correlation between the pre- and the post-measures in that the pre-measures already tell us a little bit about what we can expect on the post-measure.\rYou probably already knew this but why does this matter for power simulation, you might wonder.\rIt matters as it directly influences our power to detect an effect as we will see later.\rFor now let’s just keep in mind that it is important.\nSo what do we do in a situation with correlated data as in the pre-post intervention situation?\rThere are two ways we can go from here.\rFirst, we can simulate correlated normal distributions, as already mentioned above.\rHowever, for the particular case of a paired sample t-test, we can also just make use of the fact that, in the end, we are testing whether the difference between post- and pre-measures is different from 0.\rIn this case, the correlation between the pre and the post-measure is implicitely handled when substracting the two measures. This way, we do not need to directly specify it.\rIf the correlation is close to one, the standard-deviation of the difference scores will be very small, if it is zero, we will end up with the same situation that we have in the independent-sample t-test.\rThus, we can just make use of a one-sample in which we test whether the distribution of difference-scores differs from zero as the paired t-test is equivalent to the one-sample t-test on difference scores (see Lakens, 2013 for more details on this).\nThough the one-sample approach is easier to simulate, I will describe both approaches in the following as the first approach (simulating correlated normal-distributions) is more flexible and we need it for the situations we deal with later.\nUsing a one-sample t-test approach\rWhen we want to do our power-calculation based on the one-sample t-test approach, we only have to specify a single difference-score distribution.\rWe can do this again, based on the \\(Cohen\u0026#39;s\\ d\\) formula, this time for a one-sample scenario:\n\\[ Cohen\u0026#39;s\\ d = \\frac{M_{diff} - \\mu_0}{SD_{diff}}\\]\nIn the above formula, to get our values for the simulation we can substitute the \\(\\mu_0\\) by 0 (as our null-hypothesis is no difference) and solve the equation in the same way as above by fixing the mean-difference between pre- and post-measure, \\(M_{diff}\\) to 1 and calculating the sd we need for each given \\(Cohen\u0026#39;s\\ d\\), for instance\n\\[ 0.5 = \\frac{1}{SD_{diff}}\\]\nputting this into Rs solve function again, we unsurprisingly get a 2 in this case.\nsolve(0.5, 1)\r## [1] 2\rTo run our simulation we just need to modify the code above to run a one-sample t-test rather than a two-sample t-test and change the formula for \\(Cohen\u0026#39;s\\ d\\)\nset.seed(1)\rn_sims \u0026lt;- 1000 # we want 1000 simulations\rp_vals \u0026lt;- c()\rpower_at_n \u0026lt;- c(0) # this vector will contain the power for each sample-size (it needs the initial 0 for the while-loop to work)\rcohens_ds \u0026lt;- c()\rcohens_ds_at_n \u0026lt;- c() n \u0026lt;- 2 # sample-size i \u0026lt;- 2\rwhile(power_at_n[i-1] \u0026lt; .95){\rfor(sim in 1:n_sims){\rdifference \u0026lt;- rnorm(n,1,2) # simulate the difference score distribution\rp_vals[sim] \u0026lt;- t.test(difference, mu = 0, conf.level = 0.90)$p.value # run t-test and extract the p-value\rcohens_ds[sim] \u0026lt;- mean(difference)/sd(difference) # we also save the cohens ds that we observed in each simulation }\rpower_at_n[i] \u0026lt;- mean(p_vals \u0026lt; .10) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)\rcohens_ds_at_n[i] \u0026lt;- mean(cohens_ds) # calculate means of cohens ds for each sample-size\rn \u0026lt;- n+1 # increase sample-size by 1\ri \u0026lt;- i+1 # increase index of the while-loop by 1 to save power and cohens d to vector\r}\rpower_at_n \u0026lt;- power_at_n[-1] # delete first 0 from the vector\rcohens_ds_at_n \u0026lt;- cohens_ds_at_n[-1] # delete first NA from the vector\rWe see that the loop stopped at n = 43 so the sample size we need is n-1 = 42\nWe can plot the power-curve again\nplot(2:(n-1), power_at_n, xlab = \u0026quot;Number of participants per group\u0026quot;, ylab = \u0026quot;Power\u0026quot;, ylim = c(0,1), axes = TRUE)\rabline(h = .95, col = \u0026quot;red\u0026quot;)\rand the \\(Cohen\u0026#39;s\\ d\\) values:\nplot(2:(n-1), cohens_ds_at_n, xlab = \u0026quot;Number of participants per group\u0026quot;, ylab = \u0026quot;Cohens D\u0026quot;, ylim = c(0.0,1.0), axes = TRUE)\rabline(h = .50, col = \u0026quot;red\u0026quot;)\rWe see again, and this time more dramatically, how our simulated effect size becomes more accurate the bigger our sample gets.\n\rUsing a correlated-samples paired t-test approach\rThe relationship between \\(SD_{diff}\\) and the correlation\rIn the above example, we respecified a paired t-test as a one-sample t-test on the difference scores.\rHowever, what we are actually working with is two correlated distributions of measurements.\rTo demonstrate this point, let us have a look at how we would actually calculate the standard deviation of the difference scores (\\(SD_{diff}\\)) in the above equation for \\(Cohen\u0026#39;s\\ d\\).\rThe formula to calculate \\(SD_{diff}\\) from the standard deviation of the two measurements (pre and post) and their correlation is:\n\\[SD_{diff} = \\sqrt{SD_{pre}^2+SD_{post}^2-2r \\times SD_{pre} \\times SD_{post}} \\]\nIt is not important at this point to understand why this is the case (we will just trust Cohen on this) but see how we can, for any given \\(SD_{diff}\\) and assuming both groups have, for example, a standard deviation of 2, solve the formula to see what correlation (the \\(r\\) in the above formula) it would imply.\nImagine, for instance, we assume (like in the independent-samples t-test above) that both measures have a standard-deviation of 2 and that the standard-deviation of the difference scores would also be 2 so that we would have the same situation as in the one-sample t-test example above, where we had a mean-difference of 1 and a difference-score standard-deviation of 2.\nFilling this in we get\n\\[2 = \\sqrt{2^2+2^2-2r \\times 2 \\times 2} \\]\nSolving this equation for \\(r\\), we get2 \\(r = 0.5\\):\nTherefore, interestingly the situation in which we use the same groups as above and assume that we would get the same \\(SD_{diff}\\) of 2 as we assumed in our one-sample situation would imply that the correlation between the pre- and the post-measure is \\(r = 0.5\\).\rWhat does this mean?\rWell, lets see what happens if we assume a correlation of \\(r = .90\\) and see what \\(SD_{diff}\\) we get:\n\\[SD_{diff} = \\sqrt{2^2+2^2-2 \\times 0.90 \\times 2 \\times 2} \\]\nSolving this in R gives us: sqrt(2^2+2^2-2*0.9*2*2) = 0.89.\rThus, if the correlation increases the standard-deviation of the difference-scores becomes smaller.\rIf we do the same with a correlation of .10 we get sqrt(2^2+2^2-2*0.1*2*2) = 2.68.\rThus, when the correlation decreases the standard-deviation becomes bigger.\rInterestingly, this demonstrates that for the same mean-difference, a high correlation results in a larger \\(Cohen\u0026#39;s\\ d\\) as calculated for the difference scores in the one-sample case.\rIn other words, as the pre-scores tend to be more similar to the post-scores (i.e. they have a high correlation), the standard-deviation of the difference scores decreases.\rThis, in turn, results in higher power to detect an effect.\nTo sum up all of the above, we can either specify a difference-score distribution directly and thereby imply a certain correlation by specifying the \\(SD_{diff}\\), or we can see what \\(SD_{diff}\\) we get with a certain correlation by using the formula above and use the result for the one-sample simulation.\rHowever, instead of working with the one-sample t-test, in the next section, we will see how we can directly simulate correlated normal-distributions in R.\n\rSimulating correlated normal-distributions and demystifying the multivariate normal.\rIn real life, almost everything is correlated to some degree.\rThough these correlations are often not of interest, they sometimes are and in a good simulation we want to acknowledge them. For instance, predictors in a regression might be correlated or random effects in a mixed-model.\nThe following part is (again) longer than I intended but I feel that it is important to understand how we simulate correlated normal-distributions and what a multivariate normal-distribution is.\rIn most cases later on we will deal with some kind of correlated normal distributions (in mixed-models we will always encounter them for example) so I think it helps if we have a look at them now in an easier example, so we have one problem less to worry about later on.\nRephrasing the problem of simulating two correlated normal-distributions, we can say that we want to simulate a multivariate normal distribution or, more specifically in this case, a bivariate normal distribution.\rIf you never heard these terms before, they might seem very opague, so let’s see what they are.\rI will first show how we can simulate them, and explain what exactly this multivariate normal distribution means afterwards with a little visual intuiton.\rWe can simulate a multivariate normal distribution by using the mvrnorm() function from the MASS package but it works slightly different than the simulation functions that we have used so far (rnorm and rbinom).\rLets have a look at how this works (code explained below).\nrequire(MASS) # load MASS package\r## Loading required package: MASS\rpre_post_means \u0026lt;- c(pre = 0,post = 1) # define means of pre and post in a vector\rpre_sd \u0026lt;- 2 # define sd of pre-measure\rpost_sd \u0026lt;- 2 # define sd of post-measure\rcorrelation \u0026lt;- 0.5 # define their correlation\rsigma \u0026lt;- matrix(c(pre_sd^2, pre_sd*post_sd*correlation, pre_sd*post_sd*correlation, post_sd^2), ncol = 2) # define variance-covariance matrix\rset.seed(1)\rbivnorm \u0026lt;- data.frame(mvrnorm(10000, pre_post_means, sigma)) # simulate bivariate normal\rThe above code samples 10,000 observations from a bivariate normal-distribution, or in terms of our example, it samples 10,000 pre-measures with 10,000 correlated post-measures.\rThe first thing that is different from our earlier simulations is the first line of the code pre_post_means \u0026lt;- c(0,1).\rInstead of defining our means seperately for each measurement, as we have done earlier in the independent-sample case, we now put the pre- and post-measurement mean that we assume into a vector.\rThis is because we will simulate both measurements together in the mvrnorm function, and therefore both means need to be provided at the same time.\nSecondly, we define the standard-deviations of both measurements just as we did earlier and also specify a correlation that we would like our data-points to have, in this case 0.5.\nNow, the line matrix(c(pre_sd^2, pre_sd*post_sd*correlation, pre_sd*post_sd*correlation, post_sd^2), ncol = 2) does something that we have not done before and it might look quite confusing.\rWhat we are doing here is specifying the variance-covariance matrix.\rThis is nothing more than a table containing the variances of our pre- and post-measurement (the first and the last entry in the list) and the covariance between the two variables twice - once for each measurement (the middle 2 entries in the list).\rConceptually you can see this variance-covariance matrix as the standard-deviation of the multivariate normal that mvrnorm needs instead of the standard-deviation that we put into rnorm earlier.\nWe can visualize the variance-covariance matrix sigma to demystify it a bit.\ncolnames(sigma) \u0026lt;- c(\u0026quot;pre\u0026quot;, \u0026quot;post\u0026quot;)\rrownames(sigma) \u0026lt;- c(\u0026quot;pre\u0026quot;, \u0026quot;post\u0026quot;)\rsigma\r## pre post\r## pre 4 2\r## post 2 4\rThus, this matrix is nothing more than a table containing the variance of each variable (4 in each case) and their covariance (i.e. the correlation of the two multiplied by both standard-deviations (\\(Cov(pre,post) = \\rho(pre,post)*sd_{pre}*sd_{post}\\)).\nIn the next line of the code we put this all into mvrnorm to simulate our bivariate normal distribution and store the results in a data-frame with 2 columns, each containing one measurement point:\nhead(bivnorm)\r## pre post\r## 1 -0.2807182 -0.8893814\r## 2 1.3746052 0.2615539\r## 3 -0.4119554 -1.4827470\r## 4 3.9486678 2.5775470\r## 5 1.0711637 1.0702847\r## 6 -0.8961042 -0.9460816\rWhen we run cor(bivnorm$pre, bivnorm$post) we see that indeed their correlation is 0.52 and close to what we specified.\nTo see how we can imagine such a bivariate normal distribution, we can visualize it the following way.\nIf we draw a histogram of each measurement individually, it looks like this.\npar(mfrow=c(1,2))\rhist(bivnorm$pre, main = \u0026quot;pre-measure\u0026quot;)\rhist(bivnorm$post, main = \u0026quot;post-measure\u0026quot;)\rHowever, imagine we would not only look at each histogram seperately but we would combine them into one plot by putting the pre-measure scores of each simulated individual on the x-axis and putting the post-measures on the y-axis like this:\nplot(bivnorm$pre, bivnorm$post, xlab = \u0026quot;pre-measure\u0026quot;, ylab = \u0026quot;post-measure\u0026quot;)\rIn the above plot, we can clearly see the correlations between the two measurements that we put in the data.\rMore elegantly, we can combine the two histograms in the following way.\nbivnorm_kde \u0026lt;- kde2d(bivnorm[,1], bivnorm[,2], n = 50) # calculate kernel density (i.e. the \u0026quot;height of the cone on the z-axis\u0026quot;; not so important to understand here)\rpar(mar = c(0, 0, 0, 0)) # tel r not to leave so much space around the plot\rpersp(bivnorm_kde, phi = 45, theta = 30, xlab = \u0026quot;pre-measure\u0026quot;, ylab = \u0026quot;post-measure\u0026quot;, zlab = \u0026quot;frequency\u0026quot;) # plot the bivariate normal\rHere, we see clearly how our bivariate normal distribution is nothing more than the 2 normal-distributions of each measurement-point combined into one “cone-shaped” normal distribution that has a certain correlation.\nThe plot below shows how this cone looks with different correlations.\nNotice how for higher correlations, the cone becomes more and more narrow and starts looking like a “shark-fin” with a correlation of .90.\rThis “narrowring” of the cone is the visualization of why the standard-deviations of the difference scores get more narrow.\nIf we visualize this as a point cloud again the three correlations look like this:\nbivnorm_10 \u0026lt;- as.data.frame(bivnorm_10)\rbivnorm_90 \u0026lt;- as.data.frame(bivnorm_90)\rpar(mfrow = c(1,3))\rplot(bivnorm_10$pre, bivnorm_10$post)\rplot(bivnorm$pre, bivnorm$post)\rplot(bivnorm_90$pre, bivnorm_90$post)\rThis again, clearly shows the manipulatino between the pre- and post measures.\n\rPower-analysis with the multivariate normal\rNow that we know what we are doing when using mvrnorm we can go ahead and do a power-simulation for the example above with a bivariate normal-distribution.\rHowever, as we are not sure how big our correlation is, we can try 3 different correlations in the code above by placing the simulation in another for-loop and telling it to try different correlations.\nmu_pre_post \u0026lt;- c(pre = 0, post = 1)\rsd_pre \u0026lt;- 2\rsd_post \u0026lt;- 2\rcorrelations \u0026lt;- c(0.1, 0.5, 0.9)\rset.seed(1)\rn_sims \u0026lt;- 1000 # we want 1000 simulations\rp_vals \u0026lt;- c()\r# this vector will contain the power for each sample-size (it needs the initial 0 for the while-loop to work)\rcohens_ds \u0026lt;- c()\rpowers_at_cor \u0026lt;- list()\rcohens_ds_at_cor \u0026lt;- list()\rfor(icor in 1:length(correlations)){ # do a power-simulation for each specified simulation\rn \u0026lt;- 2 # sample-size i \u0026lt;- 2 # index of the while loop for saving things into the right place in the lists\rpower_at_n \u0026lt;- c(0) cohens_ds_at_n \u0026lt;- c() sigma \u0026lt;- matrix(c(sd_pre^2, sd_pre*sd_post*correlations[icor], sd_pre*sd_post*correlations[icor], sd_post^2), ncol = 2) #var-covar matrix\rwhile(power_at_n[i-1] \u0026lt; .95){\rfor(sim in 1:n_sims){\rbivnorm \u0026lt;- data.frame(mvrnorm(n, mu_pre_post, sigma)) # simulate the bivariate normal\rp_vals[sim] \u0026lt;- t.test(bivnorm$pre, bivnorm$post, paired = TRUE, var.equal = TRUE, conf.level = 0.9)$p.value # run t-test and extract the p-value\rcohens_ds[sim] \u0026lt;- abs((mean(bivnorm$pre)-mean(bivnorm$post))/(sqrt(sd(bivnorm$pre)^2+sd(bivnorm$post)^2-2*cor(bivnorm$pre, bivnorm$post)*sd(bivnorm$pre)*sd(bivnorm$post)))) # we also save the cohens ds that we observed in each simulation\r}\rpower_at_n[i] \u0026lt;- mean(p_vals \u0026lt; .10) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)\rnames(power_at_n)[i] \u0026lt;- n\rcohens_ds_at_n[i] \u0026lt;- mean(cohens_ds) # calculate means of cohens ds for each sample-size\rnames(cohens_ds_at_n)[i] \u0026lt;- n\rn \u0026lt;- n+1 # increase sample-size by 1\ri \u0026lt;- i+1 # increase index of the while-loop by 1 to save power and cohens d to vector\r}\rpower_at_n \u0026lt;- power_at_n[-1] # delete first 0 from the vector\rcohens_ds_at_n \u0026lt;- cohens_ds_at_n[-1] # delete first NA from the vector\rpowers_at_cor[[icor]] \u0026lt;- power_at_n # store the entire power curve for this correlation in a list\rcohens_ds_at_cor[[icor]] \u0026lt;- cohens_ds_at_n # do the same for cohens d\rnames(powers_at_cor)[[icor]] \u0026lt;- correlations[icor] # name the power-curve in the list according to the tested correlation\rnames(cohens_ds_at_cor)[[icor]] \u0026lt;- correlations[icor] # same for cohens d\r}\rAgain, the above code runs a power-simulation, or more specifically three power-analyses, one for each correlation that we wanted to test.\rNotice how this time we specify paired = TRUE in the t.test function, to indicate that we are dealing with non-independent observations.\rAlso note that a new part of the code saves the power_at_n vector to a list called power_at_cor.\rThis list, will have 3 elements, each of them the power curve for one of the correlations.\rWe can access each power-curve bei either powers_at_cor[[1]] to get the first vector in the list (the double square brackets mean first entire vector rather than first number only) or we can use it by indicating its name as powers_at_cor$0.1` to tell R that we want the power curve for a correlation of .10.\nWe can plot these power-curves next to each other\npar(mfrow=c(1,3))\rplot(2:(length(powers_at_cor$`0.1`)+1), powers_at_cor$`0.1`, xlab = \u0026quot;Number of participants\u0026quot;, ylab = \u0026quot;Power\u0026quot;, ylim = c(0,1), axes = TRUE, main = \u0026quot;correlation = 0.1\u0026quot;)\rabline(h = .95, col = \u0026quot;red\u0026quot;)\rplot(2:(length(powers_at_cor$`0.5`)+1), powers_at_cor$`0.5`, xlab = \u0026quot;Number of participants\u0026quot;, ylab = \u0026quot;Power\u0026quot;, ylim = c(0,1), axes = TRUE, main = \u0026quot;correlation = 0.5\u0026quot;)\rabline(h = .95, col = \u0026quot;red\u0026quot;)\rplot(2:(length(powers_at_cor$`0.9`)+1), powers_at_cor$`0.9`, xlab = \u0026quot;Number of participants\u0026quot;, ylab = \u0026quot;Power\u0026quot;, ylim = c(0,1), axes = TRUE, main = \u0026quot;correlation = 0.9\u0026quot;)\rabline(h = .95, col = \u0026quot;red\u0026quot;)\rHere we see how drastically the correlation influences the power in this situation.\rWith a high correlation, we need only very few participants to achieve the desired power in the specified case.\rWhy is this?\rThe reason for this is what we had a look at above: The decreasing standard-deviation of the difference scores the higher the correlation gets.\nThis is how the effect-sizes look.\npar(mfrow=c(1,3))\rplot(2:(length(cohens_ds_at_cor$`0.1`)+1), cohens_ds_at_cor$`0.1`, xlab = \u0026quot;Number of participants\u0026quot;, ylab = \u0026quot;Cohens D\u0026quot;, ylim = c(0,1), axes = TRUE, main = \u0026quot;correlation = 0.1\u0026quot;)\rabline(h = .50, col = \u0026quot;red\u0026quot;)\rplot(2:(length(cohens_ds_at_cor$`0.5`)+1), cohens_ds_at_cor$`0.5`, xlab = \u0026quot;Number of participants\u0026quot;, ylab = \u0026quot;Cohens D\u0026quot;, ylim = c(0,1), axes = TRUE, main = \u0026quot;correlation = 0.5\u0026quot;)\rabline(h = .50, col = \u0026quot;red\u0026quot;)\rplot(2:(length(cohens_ds_at_cor$`0.9`)+1), cohens_ds_at_cor$`0.9`, xlab = \u0026quot;Number of participants\u0026quot;, ylab = \u0026quot;Cohens D\u0026quot;, ylim = c(0,10), axes = TRUE, main = \u0026quot;correlation = 0.9\u0026quot;)\rabline(h = .50, col = \u0026quot;red\u0026quot;)\rFor .10 the value of the effect-size seems slightly underestimated, for .50 it approaches .50 just as in the two-sample case and for .90 it seems overestimated by quite a bit.\rDid something go wrong?\rWell no. As we’ve seen above \\(Cohen\u0026#39;s\\ d\\) is calculated by dividing the mean-difference by the standard-deviation of the difference scores which becomes smaller and smaller with increasing correlation.\rTherefore, calculated this way, \\(Cohen\u0026#39;s\\ d\\) is much bigger in the case with the larger correlation.\rThis is also why we seem to have much bigger power - we just work with a larger effect size than we intended.\rWe can even calculate by how much the effect-size is influenced by the correlation by dividing the effect-size that we would calculate based on the means and sds of our groups by \\(\\sqrt{2(1-r)}\\).\nr = .90 –\u0026gt; 0.5/sqrt(2*(1-.90)) = 1.118034\rr = .50 –\u0026gt; 0.5/sqrt(2*(1-.50)) = 0.5\rr = .10 –\u0026gt; 0.5/sqrt(2*(1-.10)) = 0.372678\nYou might wonder how we can specify effect-sizes in these cases of correlated data. Do we “correct” the expected effect for the correlation or do we just assume that it is .50 and use the one-sample scenario above?\rI do not have a good answer for this.\rIn many cases it might be fine to only specify the effect-size of the pre-post design based on the difference scores as we did in the one-sample case.\rIn some cases, however, we might find the correlation very important or have more information about the correlation of 2 measures than about the change in measures due to an intervention.\rIn those cases, it might make sense to be very specific about the expected correlations and be aware that we might need more data if the correlation is low.\rEventually, our data stem from an underlying data generating process that includes the correlation between variables and measures and it is always good to be aware of the factors that might possibly influence the results.\rWhen we collect data in a pre-post design, we do in fact measure a score at 2 time-points and do not directly assess the difference.\rWhen we specify the standard-deviation of the difference scores however, to arrive at a given \\(Cohen\u0026#39;s\\ d\\), we implicitely make assumptions about the correlations of these two measures.\nThe Take-home message here is that correlations matter and that we need to be aware of this. The good news is that power-simulations will at least make us aware of these factors and show us how different assumptions lead to different results.\n\r\r\rSummary: Our first simulations with t-tests\rThis was the last bit that I wanted to discuss about simulating t-tests and the end of part II of this tutorial.\rWe have now learned how to simulate a t-test by using either \\(Cohen\u0026#39;s\\ d\\) as an effect-size estimate and, if necessary, tell R that our two groups, or measurements, are correlated in some way.\rWhat we learned above is not restricted to doing t-tests however.\rSimulating univariate (i.e. uncorrelated) or multivariate (i.e. correlated) normal-distributions will be what we do most of the time in part III and part IV of the tutorial.\rThe only thing that will change for more complicated designs is how we combine the different tools that we learned in this part to achieve our goal.\nIn part III of this tutorial, we will see how we can basically run every analysis as a linear model using the lm function instead of using the t.test function for t-tests, the aov function for ANOVA-designs and so forth.\rBy exploring how this works for t-test, anova and regression we will simulate our way through the third part and be flexible enough to simulate any classical research designs that we would, for example, be able to do in GPower. In part IV we will go beyond this and simulate mixed-effect models.\n\r\rFootnotes\r\r\rThink back to the possible sequences of coin tosses in part I.\rInstead of possible sequences of coin-tosses, we deal with possible sequences of people-scores here, assuming that they come from the underlying distribution that we specify.\rTo get a good approximation of all the possible samples that we could get that still follow the specified distribution, we need to simulate many, many times.↩︎\n\rThis is how we solve for r:\r\r\r2\r=\r\r\r2\r2\r\r+\r\r2\r2\r\r−\r2\rr\r×\r2\r×\r2\r\r\r\r\r\r\r\r⟺\r\r\r\r\r2\r=\r\r8\r−\r8\rr\r\r\r\r\r\r|\r2\r\r\r\r\r\r\r\r⟺\r\r\r\r\r4\r=\r8\r−\r8\rr\r\r\r\r\r|\r\r−\r8\r;\r÷\r(\r−\r8\r)\r\r\r\r\r\r\r⟺\r\r\r\r\r0.5\r=\rr\r\r\r\r↩︎\n\r\r\r","date":1589241600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589285988,"objectID":"2d947e302dd1a377cf4458eee616db7f","permalink":"https://julianquandt.com/post/power-analysis-by-data-simulation-in-r-part-ii/","publishdate":"2020-05-12T00:00:00Z","relpermalink":"/post/power-analysis-by-data-simulation-in-r-part-ii/","section":"post","summary":"This part foucuses on simple scenarios (t-tests) to introduce the simulation of correlated measurements and multivariate normal-distributions","tags":["power","data-simulation"],"title":"Power Analysis by Data Simulation in R - Part II","type":"post"},{"authors":[],"categories":["Power Analysis"],"content":"\r\r\rPower Analysis by Data Simulation in R - Part I: Theoretical introduction to simulation\rBack to Power\rFinally, an actual power simulation.\rSummary\rFootnotes\r\r\r\r\r\rClick below to download the .Rmd file\r\rDownload power-analysis-by-data-simulation-in-r-part-i.Rmd\rPower Analysis by Data Simulation in R - Part I: Theoretical introduction to simulation\rWhy this blog?\rIn recent years, power-analysis has become a standard tool in the behavioral sciences.\rWith an ongoing replication crisis, high-power research is the a key to improving replicability and to improving the reliability of findings.\rEspecially with preregistration slowly becoming standard practice in psychology, power-analysis, the practice of estimating the required sample-size a-priori, is a more important step than ever to plan research projects accordingly.\nNot so long ago, power-analysis was a rather complicated endeavor urging people to use algebraic solutions to calculate power of planned studies which can be demanding especially for non-trivial designs (i.e. basically anything that is not a correlation).\rLuckily, for many research designs power-analysis is nowadays readily available in software packages such as G*Power and even for relatively complex designs in specialized tools such as the great PANGEA tool for all kinds of generalized ANOVA designs and other tools by Jake Westfall.\nHowever, while these tools are really great they also have (in my personal opinion) two drawbacks.\rFirst, they urge the user to familiarize themselves with a new piece of software with new user interfaces, that are not always intuitive.\rSecond, and more importantly, these interfaces promote a statistical way of thinking that often leaves the user confused with what the ever-changing parameters (think of these \\(\\delta\\) , \\(d\\), \\(f\\), \\(f^2\\) and vague “group-size” and “measurement-point” fields) that need to be filled in mean.\rMoreover, these parameters differ for most designs and give an impression that power-analysis is complicated business better left to statisticians or that it might not be worth the effort.\n\r\rFigure 1. Me trying to figure out how to use a standard power-analysis software.\r\r\rHowever, this impression changed dramatically for me, once I changed my ways and started doing power analysis by simulation.\rMoreover, learning how to simulate data can of course not only be of use for power analysis but is a useful skill to in every research project.\rWhen we simulate data, we can see whether what we think about the data-generating process will actually result in the patterns that we would expect.\rIn other words, we can do theoretical experiments to see whether if everything goes as we would expect, we would also find the results that we would expect.\rEspecially when our analyses become more complex, all the different parts in our model tend to interact and it is easy to get lost.\rBy simulating data before conducting an experiment, we will be forced (and able) to specify more precisely how we think a theoretical model or prediction will be reflected in the data.\nThus, even though this tutorial will focus on simulating data for power analysis, you will learn a very useful skill on the side - simulating your own data and thereby conducting theoretical experiments before you even collect data.\rI know that there are already some excellent tutorials on data/power-simulation out there but they are often very brief and/or technical and assume a rather high level of prior knowledge about R and data-simulation in general.\rTherefore, I will spend some time on explaining theoretical concepts and slowly build up the simulation-code to hopefully enable the reader to understand the underlying principles and flexibly conduct power simulations themselves after reading this.\nThroughout the tutorial I assume readers are familiar with R and some of it’s base functionality.\rThis tutorial will consist of four different parts.\n\rIn the first part (the one you are reading) I will give a short overview of how power-analysis by simulation works on a conceptual level and why I prefer it to available power-analysis software, even though there are clear drawbacks that I will also briefly mention.\rMoreover, I will introduce the concept of power as I want to bring us all on the same page and want to give a (hopefully) intuitive example about what we actually do in power calculation and how it relates to the simulation techniques that we will use for the rest of the tutorial.\rIn the second part, I will discuss simulations for the simplest case of paired and two-sample t-tests.\rIn the third part, we will explore different ANOVA and regression designs.\rIn the fourth part we will move on to more complex mixed-effects and hierarchical models and even have a peak at Bayesian approaches to power analysis (well technically its not a power analysis but a true detection rate analysis).\rFor this fourth part, I assume readers will be familiar with how to fit mixed-effect models in lmer and/or brms.\r\rThis part of the tutorial is by far the most wordy and longest part.\rJust as a little motivator to keep in mind during this sometimes lengthy tutorial:\rAt the end of part IV of this tutorial, you will know how to do your own custom power analysis for mixed-effects models.\n\rPower Analysis by Simulation (a sustainable alternative)\r\r\rFigure 2. The proof that there are alternative ways to how we normally get our power.\r\r\r\rWhat is power again? A brief introduction\rAs my intention is to keep this post as short as possible (SPOILER: which definitely did not work), let’s directly dive into the topic by having a look at the definition of power:\nIf a certain effect of interest exists (e.g. a difference between two groups) power is the chance that we actually find the effect in a given study.\nTo provide some intuition about power, lets assume you toss a coin 10 times and you get 10 heads.\rShould you be surprised about this?\rIntuitively, it makes sense that we should be more surprised the more often we toss the coin and it keeps landing on head. 10 out of 10 heads would for example be less surprising than 10,000 out of 10,000, right?\rThis is exactly the question we want to answer when with power analysis1.\rHow often should we toss the coin until we are surprised enough to conclude that the coin is not fair.\nTo translate the above situation into a Frequentist null-hypothesis significance testing (NHST) scenario, we hypothesize that the coin is indeed fair (null-hypothesis) and see whether or not the observed number of heads (the observed data) fits with this hypothesis or not. If yes, we will retain the null-hypothesis that the coin is fair, if not, we will conclude that the data are very unlikely to result from tossing a fair coin.\nHow do we do this?\rWell, assume we observed 3 heads out of 3 total tosses.\rNow we can count all ways that this could have happened with a fair coin and compare it to all possible outcomes that our coin toss experiment might have produced.\rThese possibilities are (for a fair coin or any coin that cannot produce only heads or only tails):\n\r\r\rToss #1\rToss #2\rToss #3\rnumber of heads\r\r\r\rPossibility #1\rHEAD\rHEAD\rHEAD\r3\r\rPossibility #2\rHEAD\rHEAD\rTAIL\r2\r\rPossibility #3\rHEAD\rTAIL\rTAIL\r1\r\rPossibility #4\rTAIL\rTAIL\rTAIL\r0\r\rPossibility #5\rTAIL\rTAIL\rHEAD\r1\r\rPossibility #6\rTAIL\rHEAD\rHEAD\r2\r\rPossibility #7\rTAIL\rHEAD\rTAIL\r1\r\rPossibility #8\rHEAD\rTAIL\rHEAD\r2\r\r\r\rNotice that a possibility is not only defined by the number of heads and tails but also by the order in which they occur2. We can also calculate the number of possibilities as \\(2^x\\) where 2 means that we have 2 possible outcomes per toss and \\(x\\) is the number of tosses. In this case the number of possibilities is therefore \\(2^3 = 8\\).\rOnly 1 of these 8 events (Possibility 1) can produce 3 out of 3 heads.\rIf our coin is fair, each of these events should be equally likely and we can see that when flipping a fair coin 3 times, in only 1 out of 8 cases (12.5%) we will get 3 heads (Possibility 1).\nDo we find this surprising enough to conclude that the coin that we flipped is unfair?\rMaybe, maybe not.\rIf not, instead of flipping the coin three times, we could flip it 100 times.\rImagine we observed 55 heads in 100 flips.\rWe could now start writing down all possible outcomes, but that would take some time.\rThis time, there are not 8 but \\(2^{100}\\) = 1,267,651,000,000,000,000,000,000,000,000 possible sequences of heads and tails, and we would have to count the ones that produce at least 55 heads to see how often that would happen if our coin is fair3.\nHowever, luckily we are not the first who are interested in these kind of problems and we can make use of mathematical formulas that other people figured out for us.\nIn this case we need the binomial probability mass function.\rIn short, this function defines how often we can get each outcome, assuming a certain chance of getting heads or tails.\rIf you are interested in seeing this function and see how we can hand-code it in R, then click on the info-box below.\rIf you do not want to get too much into the technicalities here, you can also just read on.\n\n\r\r\rClick here to extend information about the binomial likelihood function\r\r\n\r\\[P(x)=\\frac{N!}{x!(N-x)!}\\pi^x(1-\\pi)^{N-x} \\]\nFor people who are not used to mathematical formulas, this might already look intimidating. However, all we need to know right now is that this formula gives us the probability of getting x heads \\(P{(x)}\\) (i.e. the number of ways we get x heads divided by N tosses):\rNote that \\(\\pi\\) in the above formula is not the one we might know from geometry but it is simply the Greek letter for p denoting a probability here.\rIn this case, it is the probability of either event, heads or tails, happening on each toss so it is 50% or 0.5.\rWe can fill this in for the example above:\n\\[P(55)=\\frac{100!}{55!(100-55)!}0.5^{55}(1-0.5)^{100-55}\\]\nTranslating this formula into R syntax we get the following:\nfactorial(100)/(factorial(55)*factorial(100-55))*0.5^55*(1-0.5)^(100-55) = 0.05\nHowever, before we said that we do not need the probability of exactly 55 heads but everything that is at least 55. In order to answer our question how often we get at least 55 heads, we could repeat the above calculation with all values from 55 up until 100 and add up the probabilities that we get.\nFor example we could do this with a for-loop:\n# first we write a function that calculates the probability for each number so we can call it in a loop\rpbinom2 \u0026lt;- function(N, x, p){\rfactorial(N)/(factorial(x)*factorial(N-x))*p^x*(1-p)^(N-x)\r}\rtosses_55to100 \u0026lt;- c(55:100) # we define the amount of heads that we want to check for (all bigger than or equal to 55)\rprobs \u0026lt;- c() # we will make an empty collection that we will add the results for each number of heads to\rfor(i in tosses_55to100){\rprobs \u0026lt;- append(probs, pbinom2(100,i,.5))\r}\rprint(probs[1:10])\r## [1] 0.048474297 0.038952560 0.030068643 0.022292270 0.015869073 0.010843867\r## [7] 0.007110732 0.004472880 0.002697928 0.001559739\rNow we got all the probabilities for each of the amounts of heads that we are interested in.\rBy summing them up we get what we need - the probability of getting at least 55 heads in 100 tosses, sum(probs) = 0.18 or 18 percent.\n\r\r\nAs mentioned, fortunately, the counting of possibilities is pre-implemented into R.\rRunning pbinom(x = 54, size = 100, prob = .5, lower.tail = FALSE) (I will explain below) we can get R to calculate the proportion of samples that would result in more than x times heads in an experiment of size 100 (i.e. tossing a coin 100 times).\rExecuting this in R we get 0.18.\nIn short, the pbinom function gives us the answer to the question \"what is proportion of possible toss-sequences that results in more than x = 544 heads if we toss a coin size=100 times if our hypothesis is that the coin is fair with a probability of heads of prob = .5.\rThe lower.tail = FALSE argument tells R that we want the the probability of the upper part of the probability mass (i.e. the probability of getting 55 or more heads rather than 54 or less).\rIn other words, every 6th out of the \\(2^{100}\\) possible sequences has 55 or more heads.\rAgain, this is not really surprising and would probably not make us conclude that a coin is definitely unfair.\nIf, for example, we think that a coin is unfair if the amount of heads (or more heads) has only a probability of .01 or 1 percent, what amount of heads would allow us to draw such a conclusion when tossing a coin 100 times?\rTo solve this, we can just use the pbinom function for not only x = 55 heads but also 56 up to 100 heads, and see from which point onwards only 1 percent of all \\(2^{100}\\) sequences include so many heads.\nThe code below does exactly this.\rConveniently the pbinom function cannot only evaluate 1 value at the same time but we can just pass all values that we want to try as a sequence and it will give us the probability of x heads for each of them so we can store them as a collection of values.\rWe can plot these values to see when we cross the 1 percent line.\nn_heads \u0026lt;- 54:99 # all possible amount of heads that we want to try.\rp_heads \u0026lt;- pbinom(q = n_heads, size = 100, prob = .5, lower.tail = F) # get pbinom to show us the probability of so many heads for each of the values if a coin is fair\rplot(n_heads, p_heads)\rabline(h = .01)\rabline(v = n_heads[p_heads \u0026lt; .01][1])\rUsing the above we see that the at 62 tosses, i.e. the 9th element of the vector is the first probability that is smaller than .01, in this case 0.006.\rIn other words, getting 62 or more heads in 100 tosses would only happen extremely rarely, in 1 out of 62 cases.\rThus actually getting 62 heads is pretty surprising and if something like that happened we might conclude that a coin is unfair.\nHowever, instead of following the approach above, there is an easier way to get the number of heads that would surprise us by using the qbinom function that gives us the quantile (i.e. number of heads or more heads) that would only happen with a certain probability: qbinom(p = .01, size = 100, prob = .5, lower.tail = FALSE) = 62, unsurprisingly gives us the same result.\n\r\rBack to Power\rIn this coin-toss example, we run a statistical test about the fairness of the coin.\rBut what is the power of the test here (in case you forgot during my very long “brief” introduction, this post was about power)?\nActually, we already used three concepts from Frequentist statistical testing:\n\rThe null-hypothesis: we assumed that the coin is fair\rThe p-value : the probability that we calculated above when checking how likely 62 or more heads are (we got 0.006).\rThe alpha level : (i.e. where people conventionally use .05 in psychological literature5) is the threshold that we picked for concluding it would surprise us enough to say that the coin must be unfair, i.e. the probability of .01. In other words, it is the chance that we conclude that a coin is unfair even if it is actually fair (the one percent of cases where 62 or more heads would happen even with a fair coin).\r\rIn a proper power analysis, all of these need to be specified in addition to an alternative hypothesis. Let’s give it a try and specify them to run a power-analysis\nSpecifying the null-hypothesis.\rAgain, we will assume that a coin is fair and will produce heads with a probability of .506.\n\rSpecifying the Alternative Hypothesis aka Effect Size.\rTo conduct a proper power-analysis, it is important that we specify a concrete alternative hypothesis (or effect size).\rIf we do know have a hypothesis about the effect size, we can by definition not know the power to investigate this hypothesis.\rMakes sense, right?\nThis means we will try to think about an effect size that would be meaningful in this coin flip example.\rFor instance, if you use the coin to make an important decision, i.e. when the fairness of the coin is very important (see e.g. Figure 3)7 you would probably want to be very strict about when a coin is unfair and would like to, for instance, already conclude that it is unfair at 55% percent heads, a deviation from a truly fair coin of 5%.\n\rMost software packages use effect-size estimates like Cohen’s d or f or other standardized effect sizes. We will have a look at how to do this with simulations briefly in the second part of the tutorial, but throughout this tutorial, we will mostly follow a different approach by trying to specify the expected effect size on the rawscale.\r\r\r8\n\rSpecifying the alpha-level\rFurthermore, as it does not deem you a good idea to get into a fight with Harvey (Figure 3) by incorrectly accusing him of using an unfair coin, you want the chance of this happening (i.e. the alpha-level) to be very low at only 0.1 percent (1 in a 1000 cases)9.\n\rSpecifying the desired power\rMoreover, you also want to be sure that you would detect the unfairness of 55% if it is actually there.\rLet’s say you only want to have a 10 percent chance of not detecting it if it was there.\r100 minus this chance is the power of our coin-toss study, i.e. 90 percent (or 1-.10 on the probability scale).\n\r\rFigure 3. An illustrative example of when a coin-toss really matters.↩︎\r\r\r\nTo summarize, our test has the following properties:\n\ralpha-level = .001\ralternative hypothesis (aka effect size / fairness-criterion) = 55% heads\rpower = .90\r\rOur job now is to figure out at which number of tosses we can be 90% sure to detect the unfairness of 55% with only a 0.1% chance of getting into a fight with Harvey by wrongly accusing him of unfairness.\nTo do this we can use the following r-code (I will explain below)\n\rThe first Power Calculation\rpower_at_n \u0026lt;- c(0) # initialize vector that stores power for each number of tosses\rn_heads \u0026lt;- c() # save \u0026quot;critical\u0026quot; number of heads for that toss-amount that would result n_toss \u0026lt;- 2 # initialize the toss-counter\rwhile(power_at_n[n_toss-1] \u0026lt; .90){ # continue as long as power is not 90%\rn_heads[n_toss] \u0026lt;- qbinom(.001, n_toss, .5, lower.tail = F) # retrieve critical value\rpower_at_n[n_toss] \u0026lt;- pbinom(n_heads[n_toss], n_toss, .55, lower.tail = F) # calculate power (1-beta) for each coin-toss\rn_toss \u0026lt;- n_toss+1 # increase toss-number }\rThe above loop needs some explanation.\rIt increases the toss-amount n_toss by 1 as long as it has not yet reached 90% power.\rTo do this, we again use the qbinom function to find the number of heads (or more heads) that would only occur with a probability of .001.\rIn other words, only 0.1% of the possible coin toss sequences would result in that specific amount of heads when tossing the coin n_toss times.\rThis is the same thing we did earlier with a fixed amount of 100 tosses.\nin the next line, we take this amount of heads that only occurs with a probabiltiy of .001 for the current toss amount n_toss and use pbinom to calculate the probability of getting at least this many heads with our hypothesized unfair coin that produces heads in 55% of the cases.\rThis means, we calculate the percentage of coin toss sequences that contain at least this many heads.\rThis probability is the power of the test.\rWhy?\rBecause if 90% of the sequences contain 55% or more heads, if we take the coin and toss it n_toss times,in 90% of the cases we will get one of those sequences that contain 55% or more heads.\nLets have a look at two of the values from this calculation to make this more clear.\rFor instance, lets look at the values when the loop tried out 100 tosses:\nn_heads[100] = 65. This number is higher than the 62 heads we had above, as we are more strict now by specifying a stricter alpha level (.001 instead of .01).\rNext, this 65 was passed on to the pbinom function and we can look at the power, power_at_n[100] = 0.02.\rAt this point we only have a power of .02 or 2%.\rThis means that tossing an unfair coin that would give 55% heads 100 times, only 2% of the sequences would contain 55 or more heads, therfore making it unlikely that we would detect the unfairness.\rWhen we increase the number of tosses until the loop stops, we are at n_toss-1 = 1908 coin tosses.\rAt this number of tosses, the amount of heads that would make us conclude that a fair coin is unfair (biased with 55% heads) with only 0.1% chance of being wrong is n_heads-[n_toss-1] = 1021.\rThus in this case, with 1908 tosses, if we get 1021 heads or more, we conclude that the coin is unfair.\rWhat is the chance of getting at least that with our unfair coin?\rThat’s what the pbinom function in the loop above tells us and it is power_at_n[n_toss-1] = 0.9, our specified 90%.\rWe can also plot the power for each number of tosses that we tried in the loop.\rFigure 4 shows the increase in power with increasing sample-size.\n\rplot(1:(n_toss-1), power_at_n, xlab = \u0026quot;Number of coin-tosses\u0026quot;, ylab = \u0026quot;Power\u0026quot;, axes = FALSE)\rabline(h = .90, col = \u0026quot;red\u0026quot;)\raxis(side = 1, at = seq(0,(n_toss-1),by=100))\raxis(side = 2, at = seq(0,1,by=0.1))\r\rFigure 4. Change in power until we reach 90% indicated by the red horizontal line.\r\r\r\nThus, when tossing a coin 1908 times10, in 90% of the cases we will be able to tell it’s biased and can confidently confront Harvey like shown in Figure 5.\n\r\rFigure 5. Confronting Harvey and telling him what we think about his coin.\r\r\rIf you are not familiar with using these distribution functions (qbinom, pbinom etc.) in R, this might have been a lot of new information but this is basically what we do in power analysis:\nWe specify a null-hypothesis, an alternative hypothesis, an alpha-level and a desired power,\rWe try a small sample-size.\rWe retrieve the critical value, (the number of heads that would be more surprising than what we specified as our alpha-level).\rWe calculate the probability that the amount of heads that would make us reject the null-hypothesis would be observed with the unfair coin according to the alternative hypothesis.\rWe stop as soon as this probability is equal to the desired power.\r\r\r\rFinally, an actual power simulation.\rSo far, we have not done any simulation but have merely analytically derived the power by making use of the binomial probability mass function11.\rThus, for easy toy-examples like this one we would not need to do a simulation.\rHowever, as soon as we deal with real examples, it is much more difficult to make use of this approach and if we have several predictors in our model, or if we deal with mixed-effect models or hierarchical models (as we will do in part IV of this tutorial) the above method is not feasible anymore.\nWhat we can do however, for any model of any complexity and form, is to actually pretend we were repeatedly doing the experiment for each sample size and see how often we would be able to reject the null-hypothesis.\rFor instance we could toss a coin 20 times and test whether we would reject the null-hypothesis.\rWe could then repeat this process for 20 tosses very often, e.g. 1,000 times and see what the probability is that we would conclude that the null-hypothesis is false12.\rThis is what we do in power-simulation.\nAn obvious disadvantage is that instead of just calculating the power for each toss-amount (i.e. sample-size) only once, we need to try each toss-amount out 1,000 times.\rThus, simulation takes much longer than a regular power-calculation, especially with more complex models and high sample-sizes.\rHowever, the advantage of the method is that we can just learn it once and adjust it for any situation that we will ever find ourselves in, not having to ever walk through tedious interfaces again, selecting arbitrary analyses and setting ever changing parameters to certain values.\rAnother advantage (that will be discussed in detail later) is that we do not need to specify a precise alternative hypothesis and test it for that single value, but that we can actually remain more vague about what our alternative hypothesis (i.e. the effect size that we expect) will be.\rOftentimes we do not know exactly what effect-size we can expect and we might like to tell the power-analysis about this uncertainty.\nAt last, let us do a power-simulation for the above example.\rLuckily we do not really have to toss a coin as R can do that for us by using the rbinom function, that will as often as we call it do a coin-tossing experiment for us with a specified sample-size.\rLets first see how the rbinom function works if we would want to toss a coin 20 times.\nset.seed(1) # make sure our simulation will give the same results if you try it\rrbinom(n = 1, size = 20, prob = .50) # let r do 1 experiment with 20 coin tosses of a fair coin\r## [1] 9\rIn the above code, R tossed a coin 20 times and it resulted in 9 heads.\rWe could repeat this experiment again:\nset.seed(2) # make sure our simulation will give other results than before\rrbinom(n = 1, size = 20, prob = .5) # run the experiment again\r## [1] 8\rIn this case, giving us 8 heads.\rBy increasing the first argument to the rbinom function, we can tell R to repeat this experiment more often.\rMoreover, we can tell it to make use of an unfair coin directly, so we can directly put our alternative hypothesis in the simulation by changing the last number of the rbinom function from .50 to .55, to do the same test as above.\nset.seed(1)\rn_heads \u0026lt;- rbinom(n = 1000, size = 20, prob = .55) # run 1,000 experiments, of 20 coin tosses each, at once\rstr(n_heads) # show structure of vector\r## int [1:1000] 12 12 11 8 13 8 7 10 10 14 ...\rNow, R repeated the 20 coin-toss experiment 1,000 times with an unfair coin of 55% chance of resulting in heads giving us 1,000 times the amount of heads that it got.\rLet us again now test how big our power was in this case, again with an alpha-level of .001.\np_heads \u0026lt;- pbinom(n_heads, 20, .50, lower.tail = F) # calculate the probability of observing this many heads if the coin would be fair (which it is not cause we simulated with 55% heads)\rexp_power \u0026lt;- mean(p_heads \u0026lt; .001) # check where this chance drops below our alpha level\rThe first line in the above code does exactly what we did earlier, just with a little change.\rWe take the amounts of heads that we got from an unfair coin, and check in how many cases we would conclude - assuming that the coin would actually be fair, thus using .50 as the probability in pbinom - that the observed amounts of heads is too unlikely for us to believe that the coin was fair.\rWe save these probabilities to a vector.\rThe second line calculates the observed power of our experiment.\rTo understand what it does, let us have a look at the vector p_heads it looks the following (here only the first 10 out of 1,000 values):\np_heads[1:10]\r## [1] 0.13158798 0.13158798 0.25172234 0.74827766 0.05765915 0.74827766\r## [7] 0.86841202 0.41190147 0.41190147 0.02069473\rAs shown above, the p_heads vector contains the probability of observing each amount of heads n_heads from our 1,000 experiments assuming the experiment was done with a fair coin (which it was not).\rNow we would like to check how many of these probabilities are at least as small as our alpha-level, i.e. surprising enough to conclude the coin was not fair.\rWe do this by checking for each value whether it was .001 or smaller (p_heads \u0026lt; .001).\rThis will result in another vector of 0 when the condition is false and 1 when the condition is true13.\rTaking the mean of this vector will give us the probability of rejecting the null-hypothesis while we actually know it is incorrect (as we put the bias in the coin ourselves).\rAgain, this will give us the power.\rIn the present case with 20 coin-tosses the power is exp_power = 0.004 or 0.4 percent.\rThis is obviously very low and not surprising given that we already know from the calculation above that we need a lot more coin-tosses than 20 to get the desired power of 90%.\rTo get to our desired power in this example, we need to change the code above so it will try different sample-sizes again.\nset.seed(1)\rexp_power_at_n \u0026lt;- c(0) # create a vector where we can store the power for each sample-size\rn_toss_start \u0026lt;- 19 # start at 21 tosses\rn_toss_loop \u0026lt;- 2 # additional number of tosses tried (above 20)\rwhile(exp_power_at_n[n_toss_loop-1] \u0026lt; .90){ # continue increasing the sample-size until power = 90%\rn_toss \u0026lt;- n_toss_start+n_toss_loop # calculate the current number of tosses\rn_heads \u0026lt;- rbinom(1000, n_toss, .55) # run 1000 experiments for any given number of tosses and store number of heads\rp_heads \u0026lt;- pbinom(n_heads, n_toss, .50, lower.tail = F) # calculate the probability of getting at least that many heads if the coin would be fair exp_power_at_n[n_toss_loop] \u0026lt;- mean(p_heads \u0026lt; .001) # calculate power by checking what proportion of the probabilities is smaller than or equal to our alpha-level\rn_toss_loop = n_toss_loop+1\r}\rexp_power_at_n \u0026lt;- exp_power_at_n[-1] # remove the first 0 that we used to populate the vector for the first iteration of the loop\rThe above code is similar to what we have done earlier when we tried only 1 sample-size.\rThis time, we iterate over different sample-sizes in a loop and store the power for each in the vector exp_power_at_n.\rAs in the earlier calculation, we can now use this to see how many tosses we would need by having a look at where the loop stopped, i.e. when it reached 90% power, which is at n_toss-1 = 1795 tosses at which the power was exp_power_at_n[length(exp_power_at_n)] = 0.903.\rWe can also plot all these values again as done in Figure 6.\n\rplot(21:n_toss, exp_power_at_n, xlab = \u0026quot;Number of coin-tosses\u0026quot;, ylab = \u0026quot;Power\u0026quot;, ylim = c(0,1), axes = FALSE)\rabline(h = .90, col = \u0026quot;red\u0026quot;)\raxis(side = 1, at = seq(0,(n_toss),by=100))\raxis(side = 2, at = seq(0,1,by=0.1))\r\rFigure 6. Observed power in the simulation.\r\r\rThe shape of the line looks very similar to the earlier calculation, however the line appears to be thicker.\rMoreover, it might be surprising that we did not get the same amount of tosses that we got from the calculation.\rActually they differ quite a lot (1908 vs. 1795).\rThis is due to the fact that even when running 1,000 experiments for each sample-size there is still imprecision in the simulation.\rEach coin-flip is random and even if we repeat a experiment 1,000 times this randomness is still in there (think of how many possible sequences there would be!).\rThis randomness is why we cat a different number in the simulation and why the line in Figure 6 is thicker than in Figure 4.\nIf we want to approach the results of the calculation more closely in our simulation (i.e. get a more precise power-estimate) we can increase the number of experiments that R will run per sample-size (i.e. the number of simulations).\rFor example, we could repeat the simulation with 100,000 experiments per sample-size.\rYou have to be patient here, this already takes a few minutes maybe.\nset.seed(1)\rexp_power_at_n \u0026lt;- c(0) # create a vector where we can store the power for each sample-size\rn_toss_start \u0026lt;- 19 # start at 21 tosses\rn_toss_loop \u0026lt;- 2 # additional number of tosses tried (above 20)\rwhile(exp_power_at_n[n_toss_loop-1] \u0026lt; .90){ # continue increasing the sample-size until power = 90%\rn_toss \u0026lt;- n_toss_start+n_toss_loop # calculate the current number of tosses\rn_heads \u0026lt;- rbinom(100000, n_toss, .55) # run 1000 experiments for any given number of tosses and store number of heads\rp_heads \u0026lt;- pbinom(n_heads, n_toss, .50, lower.tail = F) # calculate the probability of getting at least that many heads if the coin would be fair exp_power_at_n[n_toss_loop] \u0026lt;- mean(p_heads \u0026lt; .001) # calculate power by checking what proportion of the probabilities is smaller than or equal to our alpha-level\rn_toss_loop = n_toss_loop+1\r}\rexp_power_at_n \u0026lt;- exp_power_at_n[-1] # remove the first 0 that we used to populate the vector for the first iteration of the loop\rIf you run this code, you will see that it took substantially longer than the previous simulation with only 1,000 repetitions.\rIf we now look at the outcome again we find that the number of tosses n_toss-1 = 1870 is already slightly closer to the calculated value but still not exactly the same.\rIn my personal opinion, this imprecision is both advantage of simulation as well as disadvantage.\rIt is a disadvantage in that it is less precise than the calculation above in theory.\rHowever, it is an advantage as it adds some noise to the power-estimation process that is actually also present in real life.\rThis is, even if there is an effect in the population, each new sample will always be different which is also the case in the simulation.\rIf we look at Figure 7, we also see that now the power-increase follows a more straight line again that is very close to the one from the exact calculation and not as thick anymore as in Figure 6.\n\rplot(21:n_toss, exp_power_at_n, xlab = \u0026quot;Number of coin-tosses\u0026quot;, ylab = \u0026quot;Power\u0026quot;, ylim = c(0,1), axes = FALSE)\rabline(h = .90, col = \u0026quot;red\u0026quot;)\raxis(side = 1, at = seq(0,(n_toss),by=100))\raxis(side = 2, at = seq(0,1,by=0.1))\r\rFigure 7. Power curve for a more precise simulation.\r\r\r\rSummary\rIn this part of the tutorial I tried to bring us all on the same page about why we would do data or power simulation and how it is related to exact power calculation.\n\rIn principle, in power calculation we count the amount of potential data sequences (e.g. possible sequences of HEADS-TAILS in coin-tosses) that could happen in an experiment of a specific size (e.g. amount of coin-tosses).\rAfterwards, we calculate the critical value (e.g. number of heads) that would make us reject the null-hypothesis (e.g. a coin is fair) as only a very small percentage of sequences (“small” is defined by the alpha-level here) would surpass the critical value.\rFinally, we calculate the percentage of sequences according to the alternative hypothesis (e.g. a coin is unfair with a bias of 55%) that would surpass the critical value.\rThis is the power of our test.\r\rIn power-simulation we do something very similar, but instead of calculating how many possible data sequences there are and how many of them result in a critical value, we just try this out a lot of times until we get an approximation of how often we would observe data that are inconsistent with the null-hypothesis given our specified alpha-level.\nI hope you forgive my rather lengthy introduction on power-analysis before actually doing the simulation, as I thought it would be a good foundation before we move on to more complex and realistic situations.\n\rIn part II of this tutorial, we will move on to these more realistic situations that we might actually be interested in psychology by looking at how we do simulations for t-tests.\rIn part III we will continue with ANOVA and regression designs.\rIn part IV we will look at mixed-effects/multilevel models.\r\r\rFootnotes\r\r\rThe answer to the question - Should we be surprised - is basically what we get when we do a statistical test and inspect the p-value.\rOk, this is not exactly true but p-values can actually be expressed in terms of how surprised we should be about an observation, given a certain hypothesis (e.g. when we assume no difference between groups as the null-hypothesis).\rTo read an awesome explanation about this, look at this really cool blog-post about s-values by Zad Chow.↩︎\n\rWhy is the order important here?\rBecause orders do identify unique outcomes.\rIf we do not consider entire sequences, we might be inclined to think that there are only four possibilities: 3xHEADS, 2xHEADS, 1xHEADS and 0xHEADS, and that each of these events is equally likely.\rHowever, how likely each of these events is depends on how many different sequences can produce it.↩︎\n\rI looked it up and apparently this number (a one followed by 30 zeros) is called a Nonillion. It is so big, that apparently the number of bacterial cells on earth is estimated at 5 Nonillion.\rSo I do not recommend trying to write down all possibilities…↩︎\n\rR excludes the first number here, so that is why we start at 54 rather than 55↩︎\n\rNotice however, that this alpha-level of .05 implies that we are surprised enough if something only happens in 1 out of 20 cases.\rThere have, however, been repeated calls to change the standard alpha-level, to justify it based on the specific situation you are in or to abandon it all together alongside other ideas of using alternatives like the Bayes-Factor.\rFor the most part, in this tutorial I will try to justify the alpha that I choose and to stay away from the “magical” .05 as I agree with the justification approach in that we should at least try and think harder about the alpha-level and it’s meaning.↩︎\n\rIt might be confusing that i say “specify” a null-hypothesis here.\rIs the null-hypothesis not by definition that there is no difference, i.e. that the coin is fair at 50%.\rWell, yes and no.\rOf course assuming coin-fairness is the most logical thing to do here but in real life, no matter what research question you are investigating, you will close to always find a difference between groups.\rIf you keep increasing the sample size, at some point the effect will always be significant, no matter how small the deviation is.\rThis is, we could even find the unfairness of the coin if it is only 51%.\rBut is this 51% really big enough to care about?\rMaybe, maybe not, but we can define a smallest effect size of interest and use Equivalence testing in which the null-hypothesis is a certain range of small deviations from the actual point of no-difference in which we say that the effect is too small to care about.\rEquivalence testing is not new but surprisingly unknown and/or uncommon in the psychological literature.\rIf you are interested in Equivalence Testing, you should check out the great paper(s) and blog-post(s) about it by Daniel Lakens and colleagues.↩︎\n\rFor those unfamiliar with this reference: Consider watching Dark Knight, it’s a great movie. In short, the displayed character, Harvey Dent, a former state lawyer, falls from grace and and loses his faith in the law system. He takes the law into his own hands and decides whether people will be sentenced (i.e. killed) by tossing a coin.↩︎\n\rSoftware like G*Power often uses different standardized effect sizes for different analyses.\rHowever, in many cases standardized effect-sizes can be converted into each other.\rIf you ever need to do such a thing, Hause Lin made a nice conversion app.↩︎\n\rThereby justifying our alpha-level in this toy example.↩︎\n\rThis might be a good point to open G*Power (maybe for the last time ever), to see whether you get the same conclusions there (spoiler: you will, and if not, that only shows that software like this is not necessarily easier to use).↩︎\n\rYou can see that is it not a simulation as you will always get the exact same result whenever you run the code above.↩︎\n\rIn other words, instead of writing all possible coin-toss sequences down and counting how many of them would produce 55% heads with a certain amount of tosses, we could just run very many experiments in which we for example throw a coin 20 times.\rIf we repeat these 20 tosses 1,000 times, we get an approximation of how many heads the toss sequences produce on average.↩︎\n\rTechnically the vector contains FALSE instead of 0 and TRUE instead of 1. However, in R, and many other programming languages, the two are interchangeable, allowing us to calculate the mean in the same way.↩︎\n\r\r\r","date":1587513600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587729644,"objectID":"aa86b66bc5d65f818c902d58df6501e8","permalink":"https://julianquandt.com/post/power-analysis-by-data-simulation-in-r-part-i/","publishdate":"2020-04-22T00:00:00Z","relpermalink":"/post/power-analysis-by-data-simulation-in-r-part-i/","section":"post","summary":"This part provides an introduction, some background on power-calculation and data-simulation.","tags":["power","data-simulation"],"title":"Power Analysis by Data Simulation in R - Part I","type":"post"},{"authors":["Julian Quandt"],"categories":["statistics"],"content":"","date":1573171200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579194048,"objectID":"aa779006cb0736ec33787a75d1417ba2","permalink":"https://julianquandt.com/talk/extending_stats_toolbox/","publishdate":"2019-11-08T00:00:00Z","relpermalink":"/talk/extending_stats_toolbox/","section":"talk","summary":"What we often forget when making use of statistics in our daily research practice is that statistics itself is a rapidly developing research field that is rapidly progressing. For instance, in recent yearsBayesFactors have been proposed asan alternative to p-values and their adaptation has quickly increased in psychological papers in recent years with many scholars claiming that they should become the standard way of statistical inference. However, while people start to adopt Bayes Factors quickly, there are problems and challenges that they might often go unnoticed. Furthermore, many Bayesian statisticians themselves say that we should not use p-values and BayesFactorsand suggest yet other alternatives.","tags":["statistics","statistical testing","p-value","bayes factor"],"title":"Extending the Statistical Toolbox @ BSI PhD-Day 2019","type":"talk"},{"authors":["Zhang Chen","Rob W. Holland","Julian Quandt","Ap Dijksterhuis","Harm Veling"],"categories":null,"content":"","date":1569888000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569888000,"objectID":"7cfbd38a9c552d6c4dfc1cdf7de74141","permalink":"https://julianquandt.com/publication/chen-when-mere-action-2019/","publishdate":"2020-01-16T16:26:19.362758Z","relpermalink":"/publication/chen-when-mere-action-2019/","section":"publication","summary":"","tags":null,"title":"When Mere Action versus Inaction Leads to Robust Preference Change","type":"publication"},{"authors":["Harm Veling","Zhang Chen","Huaiyu Liu","Julian Quandt","Rob W. Holland"],"categories":null,"content":"","date":1567296000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1567296000,"objectID":"1b2553401cf029448bba13b9e939c909","permalink":"https://julianquandt.com/publication/veling-updating-pcurve-analysis-2019/","publishdate":"2020-01-16T16:31:32.225589Z","relpermalink":"/publication/veling-updating-pcurve-analysis-2019/","section":"publication","summary":"","tags":null,"title":"Updating the P-Curve Analysis of Carbine and Larson with Results from Preregistered Experiments","type":"publication"},{"authors":["Johannes Algermissen","Julian Quandt"],"categories":["statistics"],"content":"","date":1562630400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579193578,"objectID":"8ef08ea32bf0460a19786a9bf3634789","permalink":"https://julianquandt.com/talk/brms-at-sips/","publishdate":"2019-07-09T00:00:00Z","relpermalink":"/talk/brms-at-sips/","section":"talk","summary":"In statistics classes, students often learn a zoo of different models, without grasping how those all link together. In consequence, they often fit several models, one for each research question. Hierarchical/ multi-level/ mixed-effects models constitute a unifying framework that allows to address many questions in a single model, including questions that are not easily answered with standard ANOVAs (e.g. trial-by-trial effects). However, this increased flexibility comes at the costs of more complex computation. We will discuss the logic and benefits/ pitfalls of using mixed-effects models, and then introduce Markov chain Monte Carlo (MCMC) as a particularly suited fitting algorithm. We will introduce the R package brms, an easy-to-handle wrapper for fitting Bayesian mixed-effects models using MCMCs in the language Stan.","tags":["brms","bayesian statistics","mixed-effect models"],"title":"Introduction to `brms` @ SIPS 2019","type":"talk"},{"authors":["Julian Quandt","Rob W. Holland","Zhang Chen","Harm Veling"],"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"3651ca96f085e6b7d89bca96b635b1b5","permalink":"https://julianquandt.com/publication/quandt-role-attention-explaining-2019/","publishdate":"2020-01-16T16:26:19.364752Z","relpermalink":"/publication/quandt-role-attention-explaining-2019/","section":"publication","summary":"","tags":["Appetite","Attention","Food","Motor Processes","Perceptual Motor Learning","Responses","Training"],"title":"The Role of Attention in Explaining the No-Go Devaluation Effect: Effects on Appetitive Food Items","type":"publication"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://julianquandt.com/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"https://julianquandt.com/project/internal-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/internal-project/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Internal Project","type":"project"}]