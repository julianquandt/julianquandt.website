<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>power | Julian Quandt</title>
    <link>/tags/power/</link>
      <atom:link href="/tags/power/index.xml" rel="self" type="application/rss+xml" />
    <description>power</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 16 Jun 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>power</title>
      <link>/tags/power/</link>
    </image>
    
    <item>
      <title>Power Analysis by Data Simulation in R - Part III</title>
      <link>/post/power-analysis-by-data-simulation-in-r-part-iii/</link>
      <pubDate>Tue, 16 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/post/power-analysis-by-data-simulation-in-r-part-iii/</guid>
      <description><![CDATA[
        
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#the-power-analysis-by-simulation-in-r-for-really-any-design---part-iii">The Power Analysis by simulation in <code>R</code> for really any design - Part III</a></li>
<li><a href="#footnotes">Footnotes</a></li>
</ul>
</div>

<html>
<link rel="stylesheet" href="/css/style.css" />
</html>
<p><div class="alert alert-note">
  <div>
    <!-- raw HTML omitted -->Click below to download the .Rmd file<!-- raw HTML omitted -->
  </div>
</div>
</p>
<a href="data:text/x-markdown;base64,LS0tDQp0aXRsZTogUG93ZXIgQW5hbHlzaXMgYnkgRGF0YSBTaW11bGF0aW9uIGluIFIgLSBQYXJ0IElJDQphdXRob3I6IH4NCmRhdGU6ICcyMDIwLTA1LTEyJw0Kc2x1ZzogcG93ZXItYW5hbHlzaXMtYnktZGF0YS1zaW11bGF0aW9uLWluLXItcGFydC1paQ0KY2F0ZWdvcmllczogW1Bvd2VyIEFuYWx5c2lzXQ0KdGFnczogW3Bvd2VyLCBkYXRhLXNpbXVsYXRpb24sIFJdDQpzdWJ0aXRsZTogJ1BhcnQgSUkgLSBzaW11bGF0aW5nIGdyb3VwcyBhbmQgcG93ZXJpbmcgdC10ZXN0cycNCnN1bW1hcnk6ICdUaGlzIHBhcnQgZm91Y3VzZXMgb24gc2ltcGxlIHNjZW5hcmlvcyAodC10ZXN0cykgdG8gaW50cm9kdWNlIHRoZSBzaW11bGF0aW9uIG9mIGNvcnJlbGF0ZWQgbWVhc3VyZW1lbnRzIGFuZCBtdWx0aXZhcmlhdGUgbm9ybWFsLWRpc3RyaWJ1dGlvbnMnDQphdXRob3JzOiBbXQ0KbGFzdG1vZDogImByIGZvcm1hdChTeXMudGltZSgpKWAiDQpmZWF0dXJlZDogbm8NCmNvZGVfZG93bmxvYWQ6IHRydWUNCmltYWdlOg0KICBjYXB0aW9uOiAnJw0KICBmb2NhbF9wb2ludDogJycNCiAgcHJldmlld19vbmx5OiBubw0KcHJvamVjdHM6IFtQb3dlciBBbmFseXNpcyBUdXRvcmlhbF0NCm91dHB1dDoNCiAgYmxvZ2Rvd246Omh0bWxfcGFnZToNCiAgICB0b2M6IHRydWUNCiAgICB0b2NfZGVwdGg6IDMNCi0tLQ0KDQo8aHRtbD4NCiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Ii9jc3Mvc3R5bGUuY3NzIiAvPg0KPC9odG1sPg0KDQoNCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQ0KcmVxdWlyZShrbml0cikNCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVCwgd2FybmluZyA9IEYsIGNhY2hlID0gVCkNCm9wdGlvbnMod2lkdGggPSA4MCkNCm9wdGlvbnMoc2NpcGVuID0gMTApDQojc291cmNlKCJjb21tb25fcGFja2FnZXMuUiIpDQpkZXZBc2tOZXdQYWdlKGFzayA9IEZBTFNFKQ0KYGBgDQoNCnt7JSBhbGVydCBub3RlICV9fQ0KX19DbGljayBiZWxvdyB0byBkb3dubG9hZCB0aGUgLlJtZCBmaWxlX18NCnt7JSAvYWxlcnQgJX19DQoNCmBgYHtyIGVjaG89RkFMU0V9DQp4ZnVuOjplbWJlZF9maWxlKCcuLzIwMjAtMDUtMTItcG93ZXItYW5hbHlzaXMtYnktZGF0YS1zaW11bGF0aW9uLWluLXItcGFydC1paS5SbWQnLCAicG93ZXItYW5hbHlzaXMtYnktZGF0YS1zaW11bGF0aW9uLWluLXItcGFydC1paS5SbWQiKQ0KYGBgDQoNCg0KYGBge2NzcyxlY2hvPUZBTFNFfQ0KYnV0dG9uLmJ0bi5jb2xsYXBzZWQ6YmVmb3JlDQp7DQogICAgY29udGVudDonKycgOw0KICAgIGRpc3BsYXk6YmxvY2s7DQogICAgd2lkdGg6MTVweDsNCn0NCmJ1dHRvbi5idG46YmVmb3JlDQp7DQogICAgY29udGVudDonLScgOw0KICAgIGRpc3BsYXk6YmxvY2s7DQogICAgd2lkdGg6MTVweDsNCn0NCmBgYA0KDQpgYGB7cixlY2hvPUZBTFNFLHJlc3VsdHM9J2hpZGUnfQ0Ka25pdHI6OmtuaXRfaG9va3Mkc2V0KGRyb3AxPWZ1bmN0aW9uKGJlZm9yZSwgb3B0aW9ucywgZW52aXIpIHsNCiAgICBpZiAoYmVmb3JlKSB7DQogICAgICAgIHBhc3RlKA0KICAgICAgICAgICAgJzxwPicsDQonPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IGNvbGxhcHNlZCIgZGF0YS10b2dnbGU9ImNvbGxhcHNlIiBkYXRhLXRhcmdldD0iI2NlMSI+JywNCic8L2J1dHRvbj4nLA0KJzwvcD4nLA0KJzxkaXYgY2xhc3M9ImNvbGxhcHNlIiBpZD0iY2UxIj4nLA0KJzxkaXYgY2xhc3M9ImNhcmQgY2FyZC1ib2R5Ij4nLCAgc2VwID0gIlxuIikNCiAgICB9IGVsc2Ugew0KICAgICAgICBwYXN0ZSgiPC9kaXY+IiwgIjwvZGl2PiIsIHNlcCA9ICJcbiIpDQogICAgfQ0KfSkNCmBgYA0KDQpfVGhpcyBibG9nIGlzIGFsc28gYXZhaWxhYmxlIG9uIFtSLUJsb2dnZXJzXShodHRwczovL3d3dy5yLWJsb2dnZXJzLmNvbS8pXw0KDQojIFRoZSBQb3dlciBBbmFseXNpcyBieSBzaW11bGF0aW9uIGluIGBSYCBmb3IgcmVhbGx5IGFueSBkZXNpZ24gLSBQYXJ0IElJDQoNClRoaXMgaXMgUGFydCBJSSBvZiBteSB0dXRvcmlhbCBvbiBob3cgdG8gZG8gcG93ZXItYW5hbHlzaXMgYnkgc2ltdWxhdGlvbi4NCkluIFBhcnQgSSwgd2Ugc2F3IGhvdyB0byBkbyBhIHNpbXVsYXRpb24gZm9yIGEgc2ltcGxlIHRveS1leGFtcGxlIHdpdGggYSBjb2luLXRvc3MuDQpJbiB0aGlzIHBhcnQsIHdlIHdpbGwgdXNlIGEgbW9yZSByZWFsaXN0aWMgcHJvYmxlbSB0aGF0IHdlIG1pZ2h0IGVuY291bnRlciBpbiBvdXIgZGFpbHkgcmVzZWFyY2ggbGlmZSBhbmQgc2VlIGhvdyB0byBzaW11bGF0ZSB0aGUgcG93ZXIgZm9yIHRoZXNlIGRlc2lnbnMuDQpCeSBsb29raW5nIGF0IGhvdyB0byBkbyBwb3dlci1zaW11bGF0aW9uIGZvciB0aGUgaW5kZXBlbmRlbnQtc2FtcGxlcyB0LXRlc3QgYW5kIHRoZSBwYWlyZWQgdC10ZXN0IHdlIHdpbGwgbGVhcm4gaG93IHRvIHNpbXVsYXRlIG5vcm1hbC1kaXN0cmlidXRpb25zLCBob3cgdG8gc3BlY2lmeSB0aGVpciBlZmZlY3Qtc2l6ZXMsIGluIHRlcm1zIG9mICRDb2hlbidzXCBkJC4gTW9yZW92ZXIsIHdlIHNpbXVsYXRlIGNvcnJlbGF0ZWQgKGkuZS4gbXVsdGl2YXJpYXRlKSBub3JtYWwgZGlzdHJpYnV0aW9ucyBpbiBjYXNlcyB3aGVyZSB3ZSBoYXZlIGNvcnJlbGF0ZWQgb2JzZXJ2YXRpb25zIChlLmcuIHBhaXJlZC1zYW1wbGUgdC10ZXN0KS4NClRoaXMgd2lsbCBiZSBhbiBpbXBvcnRhbnQgdG9vbCBmb3IgbGF0ZXIgcGFydHMgb2YgdGhpcyB0dXRvcmlhbC4NCg0KSW4gcGFydCBJSUkgb2YgdGhpcyB0dXRvcmlhbCB3ZSB3aWxsIGxlYXJuIGhvdyB3ZSBjYW4gY29uY2VwdHVhbGl6ZSBiYXNpY2FsbHkgX2FueV8gZGVzaWduIGFzIGEgbGluZWFyIG1vZGVsIGFuZCB0aGVyZWJ5IGJlIHZlcnkgZmxleGlibGUgaW4gb3VyIHBvd2VyIGFuYWx5c2lzLg0KSW4gcGFydCBJViB3ZSB3aWxsIGxlYXJuIGhvdyB0byBhcHBseSB0aGlzIHRlY2huaXF1ZSB0byBjb21wbGljYXRlZCBkZXNpZ25zIHN1Y2ggYXMgbGluZWFyIG1peGVkLWVmZmVjdHMgbW9kZWxzIGFuZCBnZW5lcmFsaXplZCBtaXhlZC1lZmZlY3RzIG1vZGVscy4NCg0KDQojIyBTaW11bGF0aW5nIGEgYmV0d2Vlbi1zdWJqZWN0cyB0LXRlc3QNCg0KTGV0J3MgZ2V0IHRvIGl0Lg0KVGhlIGZpcnN0IHRoaW5nIHdlIHdpbGwgbmVlZCBhZ2FpbiBpbiBvdXIgc2ltdWxhdGlvbiBpcyBvbmUgb2YgdGhlIGltcGxlbWVudGVkIHNpbXVsYXRpb24gZnVuY3Rpb25zIGluIFIgKHRob3NlIHRoYXQgbGV0IGBSYCBydW4gdGhlb3JldGljYWwgZXhwZXJpbWVudHMgZm9yIHVzKSwgYnV0IHRoaXMgdGltZSBpdCBpcyBub3QgYHJiaW5vbWAgYXMgd2UgYXJlIG5vdCB3b3JraW5nIHdpdGggY29pbi1mbGlwcyBidXQgYHJub3JtYCAtIHRoZSBzaW11bGF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgbm9ybWFsIGRpc3RyaWJ1dGlvbi4NCkxldCdzIGhhdmUgYSBzaG9ydCBsb29rIGF0IHRoYXQgZnVuY3Rpb24gYXMgd2Ugd2lsbCBrZWVwIHdvcmtpbmcgd2l0aCBpdCB0aHJvdWdob3V0IHRoZSB0dXRvcmlhbC4NCg0KYHJub3JtKG4sIG1lYW4sIHNkKWAgdGFrZXMgdGhyZWUgYXJndW1lbnRzLCBhIHNhbXBsZS1zaXplIGBuYCwgYSBgbWVhbmAgYW5kIGEgc3RhbmRhcmQtZGV2aWF0aW9uIGBzZGAuDQpCeSBzcGVjaWZ5aW5nIHRoZXNlIHZhbHVlcywgd2UgY2FuIHNhbXBsZSByYW5kb20gJ3Blb3BsZScgKG9yIG9ic2VydmF0aW9ucykgdGhhdCBhcmUgcGFydGljaXBhdGluZyBpbiBvdXIgc2ltdWxhdGVkIGV4cGVyaW1lbnRzLg0KSW1hZ2luZSwgZm9yIGV4YW1wbGUsIHRoYXQgd2UgaGF2ZSBhbiBpbnRlcnZlbnRpb24gc3R1ZHkgaW4gd2hpY2ggd2UgaGF2ZSBhIHRyZWF0bWVudCBncm91cCBhbmQgYSBjb250cm9sIGdyb3VwLg0KV2UgY2FuIGVhc2lseSBzaW11bGF0ZSBib3RoIGdyb3VwcyB3aXRoIGBybm9ybWAgYnV0IHdoYXQgc2hvdWxkIHRoZSBtZWFucyBhbmQgc2RzIG9mIHRoZSBncm91cHMgYmU/DQoNClRoZXJlIGFyZSB0d28gd2F5cyB3ZSBjYW4gYXBwcm9hY2ggdGhpcy4gDQoNCjEuIFdlIGNvdWxkIHRoaW5rIGFib3V0IHdoYXQgZ3JvdXAgbWVhbnMgd2UgZXhwZWN0IGluIG91ciBnaXZlbiBjYXNlIGFuZCB3aGF0IHdlIGV4cGVjdCB0aGUgc3ByZWFkIG9mIHRoZSBncm91cHMgdG8gYmUgX29uIHRoZSBtZWFzdXJtZW50IHNjYWxlIHRoYXQgd2UgYXJlIHdvcmtpbmcgd2l0aF8uDQpGb3IgZXhhbXBsZSwgaWYgd2UgdXNlIGEgNDAtcG9pbnQgc2NhbGUgZm9yIGEgY2xpbmljYWwgdGVzdCB3ZSBtaWdodCBrbm93IHRoYXQgYSBncm91cCB3aXRoIGRlZmljaWVuY2llcyBvbiB0aGUgdGhpbmcgdGhhdCB3ZSBtZWFzdXJlIHdvdWxkIHByb2JhYmx5IHNjb3JlIGFyb3VuZCAxMCBwb2ludHMgYW5kIHRoYXQgYWxtb3N0IGV2ZXJ5b25lIGZyb20gdGhhdCBncm91cCB3b3VsZCBzY29yZSBsb3dlciB0aGFuIDIwIHBvaW50cy4NClRoaXMgc3RhdGVtZW50IChtb3N0IHBlb3BsZSBzY29yZSBhcm91bmQgMTAsIGFsbW9zdCBldmVyeW9uZSBzY29yZXMgbG93ZXIgdGhhbiB0aWZpZWQgYXMgbm9ybWFsIGRpc3RyaWJ1dGlvbiB3aXRoIGEgbWVhbiBvZiAxMCBhbmQgYSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgNS4gSW4gdGhpcyBjYXNlIG9ubHkgMi41JSBvZiB0aGUgdmFsdWVzIChpLmUuIHRoZSB2YWx1ZXMgb3V0c2lkZSB0aGUgOTUlIENJKSB3aWxsIGJlIGhpZ2hlciB0aGFuIDIwLg0KMS4gSW4gYSBuZXcgcmVzZWFyY2ggcHJvamVjdCwgd2UgbWlnaHQgbm90IGJlIGFibGUgb3Igd2lsbGluZyB0byB0byBtYWtlIHRoZXNlIHN0YXRlbWVudHMuIA0KSW4gdGhpcyBjYXNlLCBieSBtYWtpbmcgc29tZSBleHRyYSBhc3N1bXB0aW9ucywgd2UgY2FuIGZhbGwgYmFjayB0byB0aGUgYXBwcm9hY2ggdGhhdCB3ZSBhbHNvIHVzZSBpbiBwb3dlci1jYWxjdWxhdGlvbiBzb2Z0d2FyZSBpbiBtb3N0IGNhc2VzIGFuZCBkZWZpbmUgYSBfc3RhbmRhcmRpemVkIGVmZmVjdCBzaXplXyB0aGF0IHdlIGNhbiB1c2UgdG8gc2ltdWxhdGUgZGF0YSByYXRoZXIgdGhhbiBkZWZpbmluZyB0aGUgZ3JvdXAgbWVhbnMgYW5kIHN0YW5kYXJkLWRldmlhdGlvbnMgZGlyZWN0bHkuDQoNCkkgcGVyc29uYWxseSB0cnkgdG8gZ28gd2l0aCB0aGUgZmlyc3QgYXBwcm9hY2ggd2hlbmV2ZXIgcG9zc2libGUsIGFzIEkgdGhpbmsgdGhhdCBpbiBtYW55IGNhc2VzIHdlIGtub3cgbW9yZSBhYm91dCB3aGF0IHdlIGV4cGVjdCBmcm9tIG91ciBkYXRhIHRoYW4gd2UgdGhpbmssIGV2ZW4gaW4gbmV3IHByb2plY3RzLiANCkV2ZW4gaWYgd2UgX19kbyBub3RfXyBrbm93IGEgbG90IGFib3V0IG91ciBkYXRhLCB3ZSBtaWdodCBzdGlsbCB0cnkgb3V0IGRpZmZlcmVudCBhc3N1bXB0aW9ucyAoaS5lLiBtZWFucyBhbmQgc2RzKSBmb3IgdGhlIGdyb3VwcyBpbiBvdXIgc2ltdWxhdGlvbiB0byBzZWUgd2hhdCBwb3dlciB3ZSB3b3VsZCBnZXQgZm9yIGVhY2ggb2YgdGhlbS4NClRoaXMgd2F5LCB3ZSBjYW4gbWFrZSBpbmZvcm1lZCBkZWNpc2lvbnMgYWJvdXQgb3VyIHNhbXBsZSBzaXplIHRoYXQgYXJlIG1vcmUgbnVhbmNlZCB0aGFuIHRoZSBvbmUgaW4gd2hpY2ggd2UganVzdCBhc3N1bWUgYSBzdGFuZGFyZGl6ZWQgZWZmZWN0IHNpemUgYW5kIHNlZSB3aGF0IHNhbXBsZS1zaXplIGl0IGltcGxpZXMgYW5kIGFyZSBmb3JjZWQgdG8gdGhpbmsgaGFyZGVyIGFib3V0IG91ciBkYXRhIC0gc29tZXRoaW5nIHRoYXQgbWlnaHQgc2VlbSBkaWZmaWN1bHQgYW5kIGFubm95aW5nIGF0IGZpcnN0LCBidXQgaXMgZXh0cmVtZWx5IHVzZWZ1bCBhbmQgZWR1dWNhdGlvbmFsLg0KQW5vdGhlciBhZHZhbnRhZ2Ugb2Ygc3BlY2lmeWluZyB0aGUgZ3JvdXBzIGRpcmVjdGx5IGlzIHRoYXQgd2UgY2FuIGRvIHRoaXMgZm9yIGFueSBhcmJpdHJhcmlseSBjb21wbGV4IGRlc2lnbiB3aGVyZSBzdGFuZGFyZGl6ZWQgZWZmZWN0IHNpemVzIGFyZSBvZnRlbiBkaWZmaWN1bHQgdG8gY2FsY3VsYXRlLg0KDQpUaGlzIHNhaWQsIGZvciB0aGUgY2FzZXMgd2hlcmUgd2UgbWlnaHQgcmVhbGx5IG5vdCBiZSB3aWxsaW5nIHRvIHNwZWNpZnkgZ3JvdXBzIGRpcmVjdGx5LCBhbmQgYmVjYXVzZSBpdCBhbGxvd3MgbWUgdG8gZGVtb25zdHJhdGUgc29tZSBvdGhlciBpbnRlcmVzdGluZyBwb2ludHMsIGluIHRoaXMgcGFydCBJIHdpbGwgZGlzY3VzcyBob3cgd2UgY2FuIHVzZSBzdGFuZGFyZGl6ZWQgZWZmZWN0LXNpemVzIGluIG91ciBzaW11bGF0aW9uLg0KSW4gcGFydCBJSUkgYW5kIElWIGhvd2V2ZXIsIHdlIHdpbGwgYWx3YXlzIHNwZWNpZnkgZWZmZWN0cyBvbiB0aGUgcmF3IHNjYWxlLg0KDQoNCklmIHdlIHdlcmUgdXNpbmcgR1Bvd2VyIG5vdywgd2Ugd291bGQgbW9zdCBsaWtlbHkganVzdCBmaWxsIGluIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIGdyb3VwcyBpbiAkQ29oZW4nc1wgZCQgYW5kIGJlIGRvbmUgd2l0aCBpdC4gDQpXZSBjb3VsZCBvZiBjb3Vyc2UgYWxzbyBmb2xsb3cgdGhpcyBhcHByb2FjIGluIGEgc2ltdWxhdGlvbiBieSBkZWZpbmluZyB0aGUgZ3JvdXBzIGJhc2VkIG9uIHRoZSBpbXBsaWVkICRDb2hlbidzXCBkJC4gDQpGb3IgaW5zdGFuY2UsIHdlIGNhbiBqdXN0IGFzc3VtZSB0aGF0IGdyb3VwIDEgYXMgYHJub3JtKG4sIDEsMilgLg0KTm93LCBmb2xsb3dpbmcgZnJvbSB0aGUgZm9ybXVsYSBmb3IgQ29oZW4ncyBkOg0KDQokJENvaGVuJ3NcIGQgPSAgXGZyYWN7KE1fMSAtIE1fMil9e3Bvb2xlZCBcIHNkfSQkDQoNCndoZXJlDQoNCiQkcG9vbGVkXCBzZCA9ICBcc3FydFxmcmFjeyhzZF8xXjIrc2RfMl4yKX17Mn0kJA0KIA0KIGFuZCBhZGhlcmluZyB0byB0aGUgc3R1ZGVudCB0LXRlc3QgYXNzdW1wdGlvbiBvZiBlcXVhbCB2YXJpYW5jZXMgd2UgY2FuIGZpbGwgaW4gdGhlIHBvb2xlZCBzZCBmb3JtdWxhIGFib3ZlIGFzDQoNCiQkcG9vbGVkXCBzZCA9ICBcc3FydFxmcmFjeygyXjIrMl4yKX17Mn0gPSAyJCQNCg0KdG8gZ2V0IGEgJENvaGVuJ3NcIGQkIG9mIC41MDoNCg0KJCRDb2hlbidzXCBkID0gIFxmcmFjeygxIC0gMCl9ezJ9ID0gMC41JCQNCg0KVG8gZ2V0IGFueSBvdGhlciB2YWx1ZSBmb3IgJENvaGVuJ3NcIGQkIHdlIGNhbiBqdXN0IGNoYW5nZSB0aGUgcG9vbGVkIHNkIHZhbHVlIHRvIHdoYXRldmVyIHdlIHdhbnQuDQpNb3JlIGdlbmVyYWxseSwgd2Ugd2FudCB0byBzb2x2ZSB0aGUgZXF1YXRpb24gYWJvdmUgZm9yIHRoZSBwb29sZWQgc2QgYWZ0ZXIgc3BlY2lmeWluZyBhbnkgJENvaGVuJ3NcIGQkLCBlLmcuOg0KDQokJDAuNT0gIFxmcmFjeygxIC0gMCl9e3Bvb2xlZFwgc2R9JCQNCg0KV2UgY2FuIHNvbHZlIGFuIGVxdWF0aW9uIGxpa2UgdGhhdCB3aXRoIGBSYCdzIHNvbWV3aGF0IHVuaW50dWl0aXZlIGBzb2x2ZWAgZnVuY3Rpb24gbGlrZSB0aGlzOg0KDQpgYGB7ciBzb2x2ZV9jb2hlbnNkfQ0Kc29sdmUoMC41LDEpICMgY29oZW5zIGQgb2YgLjUNCnNvbHZlKDAuMjUsMSkgIyBjb2hlbnMgZCBvZiAuMjUNCnNvbHZlKDIsMSkgIyBjb2hlbnMgZCBvZiAyDQoNCmBgYA0KDQpnaXZpbmcgdXMgdGhyZWUgZXhhbXBsZXMgb2YgaG93IHdlIHdvdWxkIG5lZWQgdG8gc3BlY2lmeSBwb29sZWQgc2QgdG8gYXJyaXZlIGF0IGEgcGFydGljdWxhciAkQ29oZW4nc1wgZCQuDQoNClRodXMsIGlmIHdlIHdhbnQgdG8gZG8gYSB0LXRlc3Qgd2l0aCB0d28gc2ltdWxhdGVkIGdyb3VwcyBhbmQgYSBjb2hlbidzIGQgb2YgMC41IHdlIGNhbiBzaW11bGF0ZSB0d28gZ3JvdXBzIG9mIGEgcGFydGljdWxhciBzYW1wbGUtc2l6ZSBieSB1c2luZyB0aGUgYHJub3JtYCBmdW5jdGlvbi4NCkxldCdzIHNheSB3ZSBoYXZlIDMwIHBhcnRpY2lwYW50cyBpbiBlYWNoIGdyb3VwLg0KDQpgYGB7ciBzaW1fZ3JvdXBzMX0NCnNldC5zZWVkKDEyMzQpDQpncm91cDEgPC0gcm5vcm0oMzAsIDEsIDIpDQpncm91cDIgPC0gcm5vcm0oMzAsIDAsIDIpDQpgYGANCg0KV2UgY2FuIHZpc3VhbGl6ZSB0aGUgZ3JvdXBzIHRoYXQgd2UgZ290IGluIGEgcGxvdCBsaWtlIHRoaXM6DQoNCmBgYHtyIHBsb3RfZ3JvdXBzMX0NCmhpc3QoZ3JvdXAxLCBjb2wgPSAiI2FkZGQ4ZSIsIGJyZWFrcyA9IDEwLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBib3RoIGdyb3VwcyIsIHhsYWIgPSAiIikNCmhpc3QoZ3JvdXAyLCBhZGQgPSBUUlVFLCBicmVha3MgPSAxMCwgY29sPSAiIzMxYTM1NCIpDQpgYGANCg0KV2UgY2FuIGFscmVhZHkgbWFrZSBpbXBvcnRhbnQgb2JzZXJ2YXRpb25zIGZyb20gdGhpcyBwbG90Og0KDQpXZSB3YW50ZWQgdG8gZ2V0IG5vcm1hbCBkaXN0cmlidXRpb25zLCBidXQgd2hhdCB3ZSBnb3QgaGVyZSBkb2VzIG5vdCByZWFsbHkgbG9vayBub3JtYWwuIA0KV2h5IGlzIHRoYXQ/IEJlY2F1c2Ugd2Ugb25seSBoYXZlIDMwIHBlb3BsZSBwZXIgZ3JvdXAgYW5kIHRha2luZyBvbmx5IDMwIHZhbHVlcyBmcm9tIHRoZSBzcGVjaWZpZWQgbm9ybWFsIGRpc3RyaWJ1dGlvbnMgZG9lcyBub3QgcmVhbGx5IGdpdmUgdXMgYSBnb29kIGFwcHJveGltYXRpb24gb2YgdGhlIHJlYWwgZGlzdHJpYnV0aW9uLg0KX19UaGlzIHBvaW50IGlzIGltcG9ydGFudF9fOiBUaGUgc2FtcGxpbmcgdmFyaWFiaWxpdHkgaW4gc3VjaCBzbWFsbCBncm91cHMgaXMgaGlnaCBhbmQgb2Z0ZW4sIGlmIHNtYWxsIHNhbXBsZS1zdHVkaWVzIChpLmUuIHVuZGVycG93ZXJlZCBzdHVkaWVzKSBmaW5kICJlZmZlY3RzIiwgdGhleSBhcmUgb2Z0ZW4gcmF0aGVyIGJpZyBhbmQgdGhlIGNvbnNlcXVlbmNlIG9mIHRoaXMgc2FtcGxpbmcgdmFyaWFiaWxpdHkgcmF0aGVyIHRoYW4gcmVhbCBkaWZmZXJlbmNlcyBvZiBncm91cHMuDQpGb3IgZXhhbXBsZSwgYnkgbG9va2luZyBhdCB0aGUgbWVhbnMgb2Ygb3VyIHNhbXBsZWQgZ3JvdXBzIGBtZWFuKGdyb3VwMSlgID0gYHIgbWVhbihncm91cDEpYCBhbmQgYG1lYW4oZ3JvdXAyKWAgPSBgciBtZWFuKGdyb3VwMilgIHdlIHNlZSB0aGF0IHRoZSBncm91cCBtZWFuIG9mIGdyb3VwIDEgaXMgYWN0dWFsbHkgY2xvc2VyIHRvIHRoZSBtZWFuIHRoYXQgd2Ugc3BlY2lmaWVkIGZvciBncm91cCAyIChpLmUuIDApIHRoYW4gdG8gaXRzIG93biBtZWFuLCB3aGlsZSB0aGUgbWVhbiBmb3IgZ3JvdXAgMiBpcyBmYXIgYXdheSBmcm9tIG91ciBpbnRlbmRlZCBtZWFuLiANCkxvb2tpbmcgYXQgdGhlIHNkcyBhY3R1YWxseSBzaG93cyB0aGF0IHRoZXkgYXJlIHF1aXRlIGNsb3NlIHRvIHdoYXQgd2Ugd2FudGVkIGBzZChncm91cDEpYCA9IGByIHNkKGdyb3VwMSlgIGFuZCBgc2QoZ3JvdXAyKWAgPSBgciBzZChncm91cDIpYC4NClRoZSAkQ29oZW4nc1wgZCQgdGhhdCB3ZSB3YW50ZWQgaXMgYWxzbyBub3QgcHJlc2VudGVkIHZlcnkgYWNjdXJhdGVseSBhdCBgKG1lYW4oZ3JvdXAxKS1tZWFuKGdyb3VwMikpLyhzcXJ0KChzZChncm91cDEpXjIrc2QoZ3JvdXAyKV4yKS8yKSlgID0gYHIgKG1lYW4oZ3JvdXAxKS1tZWFuKGdyb3VwMikpLyhzcXJ0KChzZChncm91cDEpXjIrc2QoZ3JvdXAyKV4yKS8yKSlgLg0KQWdhaW4sIGlmIHdlIHdvdWxkIGRvIHRoaXMgaW4gR3Bvd2VyLCBhbmQgc3BlY2lmeSBhICRDb2hlbidzXCBkJCwgd2Ugd2lsbCBhbHdheXMgd29yayB3aXRoIGFuIF9leGFjdF8gJENvaGVuJ3NcIGQkLCBpbiBhIHNpbXVsYXRpb24gYXBwcm9hY2ggd2UgZG8gX19ub3RfXy4gDQoNCg0KU28gbGV0IHVzIHJ1biBhIHQtdGVzdCB0byBzZWUgd2hldGhlciB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRpZmZlcmVuY2UgaGVyZS4NCkZpcnN0LCB3ZSBuZWVkIHRvIGRlY2lkZSBvbiBhbiBhbHBoYS1sZXZlbCBhZ2Fpbi4NCldoYXQgd2lsbCB3ZSBjaG9vc2U/DQpXZWxsLCB0byBoYXZlIGEgZ29vZCBqdXN0aWZpY2F0aW9uIHdlIGhhdmUgdG8gZWxhYm9yYXRlIG9uIHdoYXQgdGhlIGdyb3VwcyBhY3R1YWxseSByZXByZXNlbnQuDQpMZXQgdXMgc2F5IHRoYXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBncm91cHMgaXMgcmVsYXRlZCB0byBhbiBpbnRlcnZlbnRpb24gdGhhdCBjYW4gZWxldmF0ZSBkZXByZXNzaXZlIHN5bXB0b21zLiANClRodXMsIHRoZSBjb250cm9sIGdyb3VwIChncm91cDEpIGRpZCBub3QgZ2V0IHRoZSBpbnRlcnZlbnRpb24gYW5kIHNjb3JlcyBoaWdoZXIgb24gZGVwcmVzc2l2ZSBzeW1wdG9tcyB3aGlsZSB0aGUgdHJlYXRtZW50IGdyb3VwIChncm91cDIpIGlzIGV4cGVjdGVkIHRvIHNjb3JlIGxvd2VyLg0KTGV0IHVzIGFzc3VtZSB0aGF0IHRoaXMgaXMgdGhlIGZpcnN0IHN0dWR5IHRoYXQgd2UgcnVuIGFuZCB0aGF0LCBpZiB3ZSBmaW5kIGFueXRoaW5nIHdlIHdpbGwgZm9sbG93IGl0IHVwIGJ5IG1vcmUgZXh0ZW5zaXZlIHN0dWRpZXMgYW55d2F5LiBUaGVyZWZvcmUsIHdlIG1pZ2h0IG5vdCB3YW50IHRvIG1pc3MgYSBwb3NzaWJsZSBlZmZlY3QgYnkgc2V0dGluZyBhIHRvbyBjb25zZXJ2YXRpdmUgYWxwaGEtbGV2ZWwuDQpJZiB3ZSBmaW5kIHNvbWV0aGluZyBpbiB0aGlzIHN0dWR5LCB3ZSB3aWxsIGNvbmR1Y3QgZnVydGhlciBzdHVkaWVzIGluIHdoaWNoIHdlIGFyZSBtb3JlIHN0cmljdCBhYm91dCB0aGUgYWxwaGEgbGV2ZWwuDQpUaHVzLCB3ZSBjaG9vc2UgLjEwIGZvciB0aGlzIGZpcnN0ICJwaWxvdCIgc3R1ZHkuDQoNCjxkaXYgY2xhc3MgPSAibm90ZWJveCI+DQo8cD4NCl9fTk9URV9fOiBUaGUgYWxwaGEtbGV2ZWwgImp1c2ZpY2ljYXRpb25zIiBpbiB0aGlzIHR1dG9yaWFsIGFyZSBmb3IgZWR1Y2F0aW9uYWwgcHVycG9zZXMgYW5kIHRvIHByb3ZpZGUgYSBzdGFydGluZyBwb2ludC4gVGhleSBhcmUgb2J2aW91c2x5IG5vdCBhcyByaWdvcm91cyBhcyB3ZSB3b3VsZCBsaWtlIGluIGEgcmVhbCByZXNlYXJjaCBwcm9qZWN0LiBJZiB5b3UgZmluZCB5b3Vyc2VsZiBpbiBhIHNpdHVhdGlvbiB3aGVyZSB5b3Ugd2FudCB0byBqdXN0aWZ5IHlvdXIgYWxwaGEtbGV2ZWwgc2VlIFtKdXN0aWZ5IHlvdXIgYWxwaGEgYnkgTGFrZW5zIGV0IGFsLl0oaHR0cHM6Ly93d3cubmF0dXJlLmNvbS9hcnRpY2xlcy9zNDE1NjItMDE4LTAzMTEteCkgZm9yIGEgZ29vZCBkaXNjdXNzaW9uIG9uIHRoaXMuDQo8L3A+DQo8L2Rpdj4NCg0KV2UgY2FuIG5vdyBydW4gYSB0LXRlc3Qgd2l0aCBSJ3MgaW50ZWdyYXRlZCBgdC50ZXN0YCBmdW5jdGlvbi4NCg0KYGBge3IgdC10ZXN0MX0NCnQudGVzdChncm91cDEsIGdyb3VwMiwgcGFpcmVkID0gRkFMU0UsIHZhci5lcXVhbCA9IFRSVUUsIGNvbmYubGV2ZWwgPSAwLjkpDQpgYGANCg0KVGhlIHQtdGVzdCBzaG93cywgdGhhdCB0aGlzIGVmZmVjdCB3b3VsZCBiZSBzaWduaWZpY2FudC4NCkhvd2V2ZXIsIHdlIGFsc28gZ290ICJsdWNreSIgYW5kIGhhZCBhIGxhcmdlciBlZmZlY3QgdGhhbiB3ZSBpbnRlbmRlZCB0byBoYXZlLg0KVG8gZG8gYSBwcm9wZXIgcG93ZXIgYW5hbHlzaXMgKGxldHMgc2F5IHdlIGZpcnN0IHdhbnQgdG8gc2VlIHdoZXRoZXIgMzAgcGVvcGxlIHBlciBncm91cCBhcmUgZW5vdWdoKSB3ZSBuZWVkIHRvIG5vdCBvbmx5IHNpbXVsYXRlIGVhY2ggZ3JvdXAgb25jZSwgYnV0IG1hbnkgbWFueSB0aW1lcyBhbmQgc2VlIGhvdyBvZnRlbiB3ZSBnZXQgYSBzaWduaWZpY2FudCByZXN1bHQgYXQgdGhlIGRlc2lyZWQgYWxwaGEtbGV2ZWxbXjFdLg0KTW9yZW92ZXIsIHdlIHdvdWxkIGxpa2UgdG8gaGF2ZSBhIHBvd2VyIG9mIGF0IGxlYXN0IDk1JSwgYWdhaW4gcmVmbGVjdGluZyBvdXIgdmlldyB0aGF0IHdlIGRvIG5vdCB3YW50IHRvIG1pc3MgYSBwb3NzaWJsZSBlZmZlY3QuDQoNCkluIG5vcm1hbCBsYW5ndWFnZSB0aGVzZSBhc3N1bXB0aW9ucyBtZWFuIHRoYXQgaWYgdGhlcmUgaXMgYSBkaWZmZXJlbmNlLCB3ZSB3aWxsIGRldGVjdCBpdCBpbiAxOSBvdXQgb2YgMjAgY2FzZXMgd2hpbGUsIGlmIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UsIHdlIHdpbGwgb25seSBiZSBpbmNvcnJlY3RseSBjbGFpbWluZyB0aGF0IHRoZXJlIGlzIG9uZSBpbiAxIG91dCBvZiAxMCBjYXNlcy4NCg0KV2Ugd2lsbCBkbyB0aGlzIHNpbWlsYXJseSB0byBvdXIgc2ltdWxhdGlvbnMgaW4gcGFydCAxIG9mIHRoaXMgdHV0b3JpYWwuDQoNCmBgYHtyIHNpbV90dGVzdF9wcDMwfQ0Kc2V0LnNlZWQoMSkNCm5fc2ltcyA8LSAxMDAwICMgd2Ugd2FudCAxMDAwIHNpbXVsYXRpb25zDQpwX3ZhbHMgPC0gYygpDQpmb3IoaSBpbiAxOm5fc2ltcyl7DQogIGdyb3VwMSA8LSBybm9ybSgzMCwxLDIpICMgc2ltdWxhdGUgZ3JvdXAgMQ0KICBncm91cDIgPC0gcm5vcm0oMzAsMCwyKSAjIHNpbXVsYXRlIGdyb3VwIDINCiAgcF92YWxzW2ldIDwtIHQudGVzdChncm91cDEsIGdyb3VwMiwgcGFpcmVkID0gRkFMU0UsIHZhci5lcXVhbCA9IFRSVUUsIGNvbmYubGV2ZWwgPSAwLjkwKSRwLnZhbHVlICMgcnVuIHQtdGVzdCBhbmQgZXh0cmFjdCB0aGUgcC12YWx1ZQ0KfQ0KbWVhbihwX3ZhbHMgPCAuMTApICMgY2hlY2sgcG93ZXIgKGkuZS4gcHJvcG9ydGlvbiBvZiBwLXZhbHVlcyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gYWxwaGEtbGV2ZWwgb2YgLjEwKQ0KDQpgYGANCg0KQWhhLCBzbyBpdCBhcHBlYXJzIHRoYXQgb3VyIHBvd2VyIGBtZWFuKHBfdmFscyA8IC4xMClgID0gYHIgbWVhbihwX3ZhbHMgPCAuMTApYCBpcyBtdWNoIGxvd2VyIHRoYW4gdGhlIDk1JSB0aGF0IHdlIGRlc2lyZWQuDQpUaHVzLCB3ZSBkaWQgcmVhbGx5IGdldCBsdWNreSBpbiBvdXIgZXhhbXBsZSBhYm92ZSB3aGVuIHdlIGZvdW5kIGFuIGVmZmVjdCBvZiBvdXIgaW50ZXJ2ZW50aW9uLg0KDQpUbyBhY3R1YWxseSBkbyBhIGxlZ2l0IHBvd2VyLWFuYWx5c2lzIGhvd2V2ZXIsIHdlIHdvdWxkIGxpa2UgdG8ga25vdyBob3cgbWFueSBwZW9wbGUgd2UgZG8gbmVlZCBmb3IgYSBwb3dlciBvZiA5NSBwZXJjZW50Lg0KQWdhaW4gd2UgY2FuIG1vZGlmeSB0aGUgY29kZSBhYm92ZSB0byB0YWtlIHRoaXMgaW50byBhY2NvdW50Lg0KDQpgYGB7ciB0X3Rlc3RfdHN9DQpzZXQuc2VlZCgxKQ0Kbl9zaW1zIDwtIDEwMDAgIyB3ZSB3YW50IDEwMDAgc2ltdWxhdGlvbnMNCnBfdmFscyA8LSBjKCkNCnBvd2VyX2F0X24gPC0gYygwKSAjIHRoaXMgdmVjdG9yIHdpbGwgY29udGFpbiB0aGUgcG93ZXIgZm9yIGVhY2ggc2FtcGxlLXNpemUgKGl0IG5lZWRzIHRoZSBpbml0aWFsIDAgZm9yIHRoZSB3aGlsZS1sb29wIHRvIHdvcmspDQpjb2hlbnNfZHMgPC0gYygpDQpjb2hlbnNfZHNfYXRfbiA8LSBjKCkgDQpuIDwtIDMwICMgc2FtcGxlLXNpemUgDQppIDwtIDINCndoaWxlKHBvd2VyX2F0X25baS0xXSA8IC45NSl7DQogIGZvcihzaW0gaW4gMTpuX3NpbXMpew0KICAgIGdyb3VwMSA8LSBybm9ybShuLDEsMikgIyBzaW11bGF0ZSBncm91cCAxDQogICAgZ3JvdXAyIDwtIHJub3JtKG4sMCwyKSAjIHNpbXVsYXRlIGdyb3VwIDINCiAgICBwX3ZhbHNbc2ltXSA8LSB0LnRlc3QoZ3JvdXAxLCBncm91cDIsIHBhaXJlZCA9IEZBTFNFLCB2YXIuZXF1YWwgPSBUUlVFLCBjb25mLmxldmVsID0gMC45KSRwLnZhbHVlICMgcnVuIHQtdGVzdCBhbmQgZXh0cmFjdCB0aGUgcC12YWx1ZQ0KICAgIGNvaGVuc19kc1tzaW1dIDwtIGFicygobWVhbihncm91cDEpLW1lYW4oZ3JvdXAyKSkvKHNxcnQoKHNkKGdyb3VwMSleMitzZChncm91cDIpXjIpLzIpKSkgIyB3ZSBhbHNvIHNhdmUgdGhlIGNvaGVucyBkcyB0aGF0IHdlIG9ic2VydmVkIGluIGVhY2ggc2ltdWxhdGlvbg0KICB9DQogICAgcG93ZXJfYXRfbltpXSA8LSBtZWFuKHBfdmFscyA8IC4xMCkgIyBjaGVjayBwb3dlciAoaS5lLiBwcm9wb3J0aW9uIG9mIHAtdmFsdWVzIHRoYXQgYXJlIHNtYWxsZXIgdGhhbiBhbHBoYS1sZXZlbCBvZiAuMTApDQogICAgY29oZW5zX2RzX2F0X25baV0gPC0gbWVhbihjb2hlbnNfZHMpICMgY2FsY3VsYXRlIG1lYW5zIG9mIGNvaGVucyBkcyBmb3IgZWFjaCBzYW1wbGUtc2l6ZQ0KICAgIG4gPC0gbisxICMgaW5jcmVhc2Ugc2FtcGxlLXNpemUgYnkgMQ0KICAgIGkgPC0gaSsxICMgaW5jcmVhc2UgaW5kZXggb2YgdGhlIHdoaWxlLWxvb3AgYnkgMSB0byBzYXZlIHBvd2VyIGFuZCBjb2hlbnMgZCB0byB2ZWN0b3INCn0NCnBvd2VyX2F0X24gPC0gcG93ZXJfYXRfblstMV0gIyBkZWxldGUgZmlyc3QgMCBmcm9tIHRoZSB2ZWN0b3INCmNvaGVuc19kc19hdF9uIDwtIGNvaGVuc19kc19hdF9uWy0xXSAjIGRlbGV0ZSBmaXJzdCBOQSBmcm9tIHRoZSB2ZWN0b3INCmBgYA0KDQpUaGUgbG9vcCBzdG9wcGVkIGF0IGEgc2FtcGxlLXNpemUgb2YgYG4tMWAgPSBgciBuLTFgIHBhcnRpY2lwYW50cyBwZXIgZ3JvdXAuDQpUaHVzIG1ha2UgYSBjb25jbHVzaW9uIGFib3V0IHRoZSBlZmZlY3RpdmVuZXNzIG9mIG91ciBpbnRlcnZlbnRpb24gYXQgdGhlIHNwZWNpZmllZCBhbHBoYS1sZXZlbCB3aXRoIHRoZSBkZXNpcmVkIHBvd2VyIHdlIG5lZWQgYHIgKG4tMSkqMmAgcGVvcGxlIGluIHRvdGFsLg0KDQpUbyB2aXN1YWxpemUgdGhlIHBvd2VyIHdlIGNhbiBwbG90IGl0IGFnYWluLCBqdXN0IGFzIGluIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSB0dXRvcmlhbC4NCg0KYGBge3IgcGxvdF9wb3dlcjF9DQpwbG90KDMwOihuLTEpLCBwb3dlcl9hdF9uLCB4bGFiID0gIk51bWJlciBvZiBwYXJ0aWNpcGFudHMgcGVyIGdyb3VwIiwgeWxhYiA9ICJQb3dlciIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBUUlVFKQ0KYWJsaW5lKGggPSAuOTUsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCkFnYWluLCB0aGlzIHBsb3Qgc2hvd3MgdXMgaG93IG91ciBwb3dlciB0byBkZXRlY3QgdGhlIGVmZmVjdCBzbG93bHkgaW5jcmVhc2VzIGlmIHdlIGluY3JlYXNlIHRoZSBzYW1wbGUtc2l6ZSB1bnRpbCBpdCByZWFjaGVzIG91ciBkZXNpcmVkIHBvd2VyLg0KDQoNClRoZXJlIGlzIGFub3RoZXIgaW50ZXJlc3Rpbmcgb2JzZXJ2YXRpb24gdG8gbWFrZSBoZXJlLiANCkluIHRoZSBjb2RlIGFib3ZlLCBJIGFsc28gY2FsY3VsYXRlIHRoZSBhdmVyYWdlICRDb2hlbidzXCBkJCBmb3IgZWFjaCBzYW1wbGUgc2l6ZSBhbmQgdGhlIHBsb3QgYmVsb3cgc2hvd3MgaG93IGl0IGNoYW5nZXMgd2l0aCBpbmNyZWFzaW5nIHNhbXBsZS1zaXplLg0KDQpgYGB7ciBwbG90X2NvaGVuc2QxfQ0KcGxvdCgzMDoobi0xKSwgY29oZW5zX2RzX2F0X24sIHhsYWIgPSAiTnVtYmVyIG9mIHBhcnRpY2lwYW50cyBwZXIgZ3JvdXAiLCB5bGFiID0gIkNvaGVucyBEIiwgeWxpbSA9IGMoMC40NSwwLjU1KSwgYXhlcyA9IFRSVUUpDQphYmxpbmUoaCA9IC41MCwgY29sID0gInJlZCIpDQpgYGANCg0KSXQgaXMgbm90IHN1cGVyIG9idmlvdXMgaW4gdGhpcyBwbG90IGFuZCBJIGhhZCB0byBjaGFuZ2UgdGhlIHNjYWxlIG9mIHRoZSB5LWF4aXMgcXVpdGUgYSBiaXQgdG8gbWFrZSBpdCB2aXNpYmxlLCBidXQgd2UgY2FuIGFjdHVhbGx5IHNlZSBob3cgb3VyIGF2ZXJhZ2UgJENvaGVuJ3NcIGQkIGluaXRpYWxseSBkZXZpYXRlcyBzbGlnaHRseSBtb3JlIGZyb20gdGhlIGRlc2lyZWQgJENvaGVuJ3NcIGQkIG9mIC41MCB0aGFuIGluIGRlIGVuZC4NCkluIG90aGVyIHdvcmRzLCBpbiB0aGUgYmVnaW5uaW5nLCBmb3Igc21hbGwgc2FtcGxlLXNpemVzIHRoZXJlIGlzIG1vcmUgZmx1Y3R1YXRpb24gdGhhbiBmb3IgYmlnZ2VyIHNhbXBsZS1zaXplcy4NClRoYXQgaXMgcHJldHR5IG5lYXQsIGFzIGl0IHNlZW1zIHZlcnkgZGVzaXJhYmxlIHRoYXQgYSBwb3dlci1lc3RpbWF0aW9uIHByb2NlZHVyZSB0YWtlcyBpbnRvIGFjY291bnQgdGhhdCBmb3Igc21hbGxlciBzYW1wbGUtc2l6ZXMsIGV2ZW4gaWYgdGhlIGVmZmVjdCBpbiB0aGUgcG9wdWxhdGlvbiBpcyBleGFjdGx5IHRoZSBzYW1lIChpLmUuIHdlIGFsd2F5cyBzYW1wbGUgZ3JvdXBzIHdpdGggYSBkaWZmZXJlbmNlIG9mICRDb2hlbidzXCBkJCA9IC41MCkgaXQgaXMganVzdCBsZXNzIHByZWNpc2UuDQoNCg0KTGV0J3MgaGF2ZSBhIGJyaWVmIHN1bW1hcnkgb2Ygd2hhdCB3ZSBkaWQgc28gZmFyLg0KV2UganVzdCB1c2VkIHRoZSBmb3JtdWxhIGZvciAkQ29oZW4nc1wgZCQgdG8gZ2l2ZSBvdXIgZ3JvdXBzIGEgY2VydGFpbiBkaWZmZXJlbmNlIHRoYXQgd2UgYXJlIGludGVyZXN0ZWQgaW4sIHJhbiAxMDAwIHNpbXVsYXRlZCBleHBlcmltZW50cyBmb3IgZWFjaCBzYW1wbGUtc2l6ZSBhbmQgY2FsY3VsYXRlZCB0aGUgcG93ZXIsIGp1c3QgYXMgaW4gdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHR1dG9yaWFsLg0KDQpIb3dldmVyLCBJIHdhbnQgdG8gbWVudGlvbiBhZ2FpbiB0aGF0LCBldmVuIHRob3VnaCBpdCBpcyBjb252ZW5pZW50IHRvIHNwZWNpZnkgdGhlIGVmZmVjdC1zaXplIHRoaXMgd2F5IGFzIGl0IHNhdmVzIHVzIGZyb20gaGF2aW5nIHRvIHNwZWNpZnkgcHJlY2lzZSBncm91cCBtZWFucyBhbmQgc3RhbmRhcmQtZGV2aWF0aW9ucyBkaXJlY3R5IGFuZCBtYWtlcyB0aGUgc3BlY2lmaWNhdGlvbiBtb3JlIGNvbXBhcmFibGUsIGl0IGlzIG9mdGVuIHByZWZlcmFibGUgdG8gc3BlY2lmeSB0aGUgcGFyYW1ldGVycyBvbiB0aGUgb3JpZ2luYWwgc2NhbGUgdGhhdCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi4NClRoaXMgaXMgZXNwZWNpYWxseSB0aGUgY2FzZSBpZiB3ZSBoYXZlIHByZXZpb3VzIGRhdGEgb24gYSByZXNlYXJjaCB0b3BpYyB0aGF0IHdlIGNhbiBtYWtlIHVzZSBvZi4gDQpNb3Jlb3ZlciwgZm9yIG1vcmUgY29tcGxleCBkZXNpZ25zIHdpdGggbWFueSBwYXJhbWV0ZXJzLCBzdGFuZGFyZGl6ZWQgZWZmZWN0IHNpemVzIGFyZSBvZnRlbiBkaWZmaWN1bHQgdG8gb2J0YWluIGFuZCB3ZSBhcmUgZm9yY2VkIHRvIG1ha2Ugb3VyIGFzc3VtcHRpb25zIG9uIHRoZSBvcmlnaW5hbCBzY2FsZSBvZiB0aGUgZGF0YS4NCldlIHdpbGwgc2VlIHRoaXMgaW4gbGF0ZXIgZXhhbXBsZXMuDQoNCg0KIyMgU2ltdWxhdGluZyBhIHdpdGhpbi1zdWJqZWN0IHQtdGVzdA0KDQpJbnR1aXRpdmVseSwgaXQgbWlnaHQgc2VlbSB0aGF0IHdlIGNhbiB1c2UgdGhlIGV4YWN0IHNhbWUgYXBwcm9hY2ggYWJvdmUgZm9yIGEgcGFpcmVkIHQtdGVzdCBhcyB3ZWxsLiANCkhvd2V2ZXIsIHRoZSBwcm9ibGVtIHdpdGggdGhpcyBpcyB0aGF0IGluIGEgcGFpcmVkIHQtdGVzdCB3ZSBnZXQgMiBkYXRhLXBvaW50cyBmcm9tIHRoZSBzYW1lIGluZGl2aWR1YWwuIA0KRm9yIGV4YW1wbGUsIGltYWdlIHdlIGhhdmUgYSBncm91cCBvZiBwZW9wbGUgdGhhdCBnZXQgYW4gaW50ZXJ2ZW50aW9uIGFuZCB3ZSBtZWFzdXJlIHRoZWlyIHNjb3JlIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGludGVydmVudGlvbiBhbmQgd2FudCB0byBjb21wYXJlIHRoZW0gd2l0aCBhIHBhaXJlZCB0LXRlc3QuDQpJbiB0aGlzIGNhc2UsIHRoZSBzY29yZSBvZiB0aGUgcG9zdC1tZWFzdXJlIG9mIGEgZ2l2ZW4gaW5kaXZpZHVhbCBpcyBub3QgY29tcGxldGVseSBpbmRlcGVuZGVudCBvZiB0aGUgc2NvcmUgb2YgdGhlIHByZS1tZWFzdXJlLiANCkluIG90aGVyIHdvcmRzLCBzb21lYm9keSB3aG8gc2NvcmVzIHZlcnkgbG93IG9uIHRoZSBwcmUtbWVhc3VyZSB3aWxsIG1vc3QgbGlrZWx5IG5vdCBzY29yZSB2ZXJ5IGhpZ2ggb24gdGhlIHBvc3QtbWVhc3VyZSBhbmQgdmljZSB2ZXJzYS4NCg0KVGh1cywgdGhlcmUgaXMgYSBfY29ycmVsYXRpb25fIGJldHdlZW4gdGhlIHByZS0gYW5kIHRoZSBwb3N0LW1lYXN1cmVzIGluIHRoYXQgdGhlIHByZS1tZWFzdXJlcyBhbHJlYWR5IHRlbGwgdXMgYSBsaXR0bGUgYml0IGFib3V0IHdoYXQgd2UgY2FuIGV4cGVjdCBvbiB0aGUgcG9zdC1tZWFzdXJlLg0KWW91IHByb2JhYmx5IGFscmVhZHkga25ldyB0aGlzIGJ1dCB3aHkgZG9lcyB0aGlzIG1hdHRlciBmb3IgcG93ZXIgc2ltdWxhdGlvbiwgeW91IG1pZ2h0IHdvbmRlci4gDQpJdCBtYXR0ZXJzIGFzIGl0IGRpcmVjdGx5IGluZmx1ZW5jZXMgb3VyIHBvd2VyIHRvIGRldGVjdCBhbiBlZmZlY3QgYXMgd2Ugd2lsbCBzZWUgbGF0ZXIuDQpGb3Igbm93IGxldCdzIGp1c3Qga2VlcCBpbiBtaW5kIHRoYXQgaXQgaXMgaW1wb3J0YW50Lg0KDQoNClNvIHdoYXQgZG8gd2UgZG8gaW4gYSBzaXR1YXRpb24gd2l0aCBjb3JyZWxhdGVkIGRhdGEgYXMgaW4gdGhlIHByZS1wb3N0IGludGVydmVudGlvbiBzaXR1YXRpb24/DQpUaGVyZSBhcmUgdHdvIHdheXMgd2UgY2FuIGdvIGZyb20gaGVyZS4gDQpGaXJzdCwgd2UgY2FuIHNpbXVsYXRlIGNvcnJlbGF0ZWQgbm9ybWFsIGRpc3RyaWJ1dGlvbnMsIGFzIGFscmVhZHkgbWVudGlvbmVkIGFib3ZlLg0KSG93ZXZlciwgZm9yIHRoZSBwYXJ0aWN1bGFyIGNhc2Ugb2YgYSBwYWlyZWQgc2FtcGxlIHQtdGVzdCwgd2UgY2FuIGFsc28ganVzdCBtYWtlIHVzZSBvZiB0aGUgZmFjdCB0aGF0LCBpbiB0aGUgZW5kLCB3ZSBhcmUgdGVzdGluZyB3aGV0aGVyIHRoZSBfX2RpZmZlcmVuY2VfXyBiZXR3ZWVuIHBvc3QtIGFuZCBwcmUtbWVhc3VyZXMgaXMgZGlmZmVyZW50IGZyb20gMC4gDQpJbiB0aGlzIGNhc2UsIHRoZSBjb3JyZWxhdGlvbiBiZXR3ZWVuIHRoZSBwcmUgYW5kIHRoZSBwb3N0LW1lYXN1cmUgaXMgaW1wbGljaXRlbHkgaGFuZGxlZCB3aGVuIHN1YnN0cmFjdGluZyB0aGUgdHdvIG1lYXN1cmVzLiBUaGlzIHdheSwgd2UgZG8gbm90IG5lZWQgdG8gZGlyZWN0bHkgc3BlY2lmeSBpdC4gDQpJZiB0aGUgY29ycmVsYXRpb24gaXMgY2xvc2UgdG8gb25lLCB0aGUgc3RhbmRhcmQtZGV2aWF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIHNjb3JlcyB3aWxsIGJlIHZlcnkgc21hbGwsIGlmIGl0IGlzIHplcm8sIHdlIHdpbGwgZW5kIHVwIHdpdGggdGhlIHNhbWUgc2l0dWF0aW9uIHRoYXQgd2UgaGF2ZSBpbiB0aGUgaW5kZXBlbmRlbnQtc2FtcGxlIHQtdGVzdC4NClRodXMsIHdlIGNhbiBqdXN0IG1ha2UgdXNlIG9mIGEgb25lLXNhbXBsZSBpbiB3aGljaCB3ZSB0ZXN0IHdoZXRoZXIgdGhlIGRpc3RyaWJ1dGlvbiBvZiBkaWZmZXJlbmNlLXNjb3JlcyBkaWZmZXJzIGZyb20gemVybyBhcyB0aGUgcGFpcmVkIHQtdGVzdCBpcyBlcXVpdmFsZW50IHRvIHRoZSBvbmUtc2FtcGxlIHQtdGVzdCBvbiBkaWZmZXJlbmNlIHNjb3JlcyBbKHNlZSBMYWtlbnMsIDIwMTMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzKV0oaHR0cHM6Ly93d3cubmNiaS5ubG0ubmloLmdvdi9wbWMvYXJ0aWNsZXMvUE1DMzg0MDMzMS8pLg0KDQpUaG91Z2ggdGhlIG9uZS1zYW1wbGUgYXBwcm9hY2ggaXMgZWFzaWVyIHRvIHNpbXVsYXRlLCBJIHdpbGwgZGVzY3JpYmUgYm90aCBhcHByb2FjaGVzIGluIHRoZSBmb2xsb3dpbmcgYXMgdGhlIGZpcnN0IGFwcHJvYWNoIChzaW11bGF0aW5nIGNvcnJlbGF0ZWQgbm9ybWFsLWRpc3RyaWJ1dGlvbnMpIGlzIG1vcmUgZmxleGlibGUgYW5kIHdlIG5lZWQgaXQgZm9yIHRoZSBzaXR1YXRpb25zIHdlIGRlYWwgd2l0aCBsYXRlci4NCg0KIyMjIFVzaW5nIGEgb25lLXNhbXBsZSB0LXRlc3QgYXBwcm9hY2gNCg0KV2hlbiB3ZSB3YW50IHRvIGRvIG91ciBwb3dlci1jYWxjdWxhdGlvbiBiYXNlZCBvbiB0aGUgb25lLXNhbXBsZSB0LXRlc3QgYXBwcm9hY2gsIHdlIG9ubHkgaGF2ZSB0byBzcGVjaWZ5IGEgc2luZ2xlIGRpZmZlcmVuY2Utc2NvcmUgZGlzdHJpYnV0aW9uLg0KV2UgY2FuIGRvIHRoaXMgYWdhaW4sIGJhc2VkIG9uIHRoZSAkQ29oZW4nc1wgZCQgZm9ybXVsYSwgdGhpcyB0aW1lIGZvciBhIG9uZS1zYW1wbGUgc2NlbmFyaW86DQoNCiQkIENvaGVuJ3NcIGQgPSBcZnJhY3tNX3tkaWZmfSAtIFxtdV8wfXtTRF97ZGlmZn19JCQNCg0KSW4gdGhlIGFib3ZlIGZvcm11bGEsIHRvIGdldCBvdXIgdmFsdWVzIGZvciB0aGUgc2ltdWxhdGlvbiB3ZSBjYW4gc3Vic3RpdHV0ZSB0aGUgJFxtdV8wJCBieSAwIChhcyBvdXIgbnVsbC1oeXBvdGhlc2lzIGlzIG5vIGRpZmZlcmVuY2UpIGFuZCBzb2x2ZSB0aGUgZXF1YXRpb24gaW4gdGhlIHNhbWUgd2F5IGFzIGFib3ZlIGJ5IGZpeGluZyB0aGUgbWVhbi1kaWZmZXJlbmNlIGJldHdlZW4gcHJlLSBhbmQgcG9zdC1tZWFzdXJlLCAkTV97ZGlmZn0kIHRvIDEgYW5kIGNhbGN1bGF0aW5nIHRoZSBzZCB3ZSBuZWVkIGZvciBlYWNoIGdpdmVuICRDb2hlbidzXCBkJCwgZm9yIGluc3RhbmNlDQoNCiQkIDAuNSA9IFxmcmFjezF9e1NEX3tkaWZmfX0kJA0KDQpwdXR0aW5nIHRoaXMgaW50byBgUmBzIGBzb2x2ZWAgZnVuY3Rpb24gYWdhaW4sIHdlIHVuc3VycHJpc2luZ2x5IGdldCBhIDIgaW4gdGhpcyBjYXNlLg0KDQpgYGB7ciB9DQpzb2x2ZSgwLjUsIDEpDQpgYGANCg0KVG8gcnVuIG91ciBzaW11bGF0aW9uIHdlIGp1c3QgbmVlZCB0byBtb2RpZnkgdGhlIGNvZGUgYWJvdmUgdG8gcnVuIGEgb25lLXNhbXBsZSB0LXRlc3QgcmF0aGVyIHRoYW4gYSB0d28tc2FtcGxlIHQtdGVzdCBhbmQgY2hhbmdlIHRoZSBmb3JtdWxhIGZvciAkQ29oZW4nc1wgZCQNCg0KYGBge3IgdC10ZXN0X29zdH0NCnNldC5zZWVkKDEpDQpuX3NpbXMgPC0gMTAwMCAjIHdlIHdhbnQgMTAwMCBzaW11bGF0aW9ucw0KcF92YWxzIDwtIGMoKQ0KcG93ZXJfYXRfbiA8LSBjKDApICMgdGhpcyB2ZWN0b3Igd2lsbCBjb250YWluIHRoZSBwb3dlciBmb3IgZWFjaCBzYW1wbGUtc2l6ZSAoaXQgbmVlZHMgdGhlIGluaXRpYWwgMCBmb3IgdGhlIHdoaWxlLWxvb3AgdG8gd29yaykNCmNvaGVuc19kcyA8LSBjKCkNCmNvaGVuc19kc19hdF9uIDwtIGMoKSANCm4gPC0gMiAjIHNhbXBsZS1zaXplIA0KaSA8LSAyDQp3aGlsZShwb3dlcl9hdF9uW2ktMV0gPCAuOTUpew0KICBmb3Ioc2ltIGluIDE6bl9zaW1zKXsNCiAgICBkaWZmZXJlbmNlIDwtIHJub3JtKG4sMSwyKSAjIHNpbXVsYXRlIHRoZSBkaWZmZXJlbmNlIHNjb3JlIGRpc3RyaWJ1dGlvbg0KICAgIHBfdmFsc1tzaW1dIDwtIHQudGVzdChkaWZmZXJlbmNlLCBtdSA9IDAsIGNvbmYubGV2ZWwgPSAwLjkwKSRwLnZhbHVlICMgcnVuIHQtdGVzdCBhbmQgZXh0cmFjdCB0aGUgcC12YWx1ZQ0KICAgIGNvaGVuc19kc1tzaW1dIDwtIG1lYW4oZGlmZmVyZW5jZSkvc2QoZGlmZmVyZW5jZSkgIyB3ZSBhbHNvIHNhdmUgdGhlIGNvaGVucyBkcyB0aGF0IHdlIG9ic2VydmVkIGluIGVhY2ggc2ltdWxhdGlvbiANCiAgfQ0KICAgIHBvd2VyX2F0X25baV0gPC0gbWVhbihwX3ZhbHMgPCAuMTApICMgY2hlY2sgcG93ZXIgKGkuZS4gcHJvcG9ydGlvbiBvZiBwLXZhbHVlcyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gYWxwaGEtbGV2ZWwgb2YgLjEwKQ0KICAgIGNvaGVuc19kc19hdF9uW2ldIDwtIG1lYW4oY29oZW5zX2RzKSAjIGNhbGN1bGF0ZSBtZWFucyBvZiBjb2hlbnMgZHMgZm9yIGVhY2ggc2FtcGxlLXNpemUNCiAgICBuIDwtIG4rMSAjIGluY3JlYXNlIHNhbXBsZS1zaXplIGJ5IDENCiAgICBpIDwtIGkrMSAjIGluY3JlYXNlIGluZGV4IG9mIHRoZSB3aGlsZS1sb29wIGJ5IDEgdG8gc2F2ZSBwb3dlciBhbmQgY29oZW5zIGQgdG8gdmVjdG9yDQp9DQpwb3dlcl9hdF9uIDwtIHBvd2VyX2F0X25bLTFdICMgZGVsZXRlIGZpcnN0IDAgZnJvbSB0aGUgdmVjdG9yDQpjb2hlbnNfZHNfYXRfbiA8LSBjb2hlbnNfZHNfYXRfblstMV0gIyBkZWxldGUgZmlyc3QgTkEgZnJvbSB0aGUgdmVjdG9yDQpgYGANCg0KV2Ugc2VlIHRoYXQgdGhlIGxvb3Agc3RvcHBlZCBhdCBgbmAgPSBgciBuYCBzbyB0aGUgc2FtcGxlIHNpemUgd2UgbmVlZCBpcyBgbi0xYCA9IGByIG4tMWANCg0KV2UgY2FuIHBsb3QgdGhlIHBvd2VyLWN1cnZlIGFnYWluDQoNCmBgYHtyIHBsb3RfcG93ZXJfb3N0fQ0KcGxvdCgyOihuLTEpLCBwb3dlcl9hdF9uLCB4bGFiID0gIk51bWJlciBvZiBwYXJ0aWNpcGFudHMgcGVyIGdyb3VwIiwgeWxhYiA9ICJQb3dlciIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBUUlVFKQ0KYWJsaW5lKGggPSAuOTUsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCmFuZCB0aGUgJENvaGVuJ3NcIGQkIHZhbHVlczoNCg0KYGBge3IgcGxvdF9jb2hlbnNkX29zdH0NCnBsb3QoMjoobi0xKSwgY29oZW5zX2RzX2F0X24sIHhsYWIgPSAiTnVtYmVyIG9mIHBhcnRpY2lwYW50cyBwZXIgZ3JvdXAiLCB5bGFiID0gIkNvaGVucyBEIiwgeWxpbSA9IGMoMC4wLDEuMCksIGF4ZXMgPSBUUlVFKQ0KYWJsaW5lKGggPSAuNTAsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCldlIHNlZSBhZ2FpbiwgYW5kIHRoaXMgdGltZSBtb3JlIGRyYW1hdGljYWxseSwgaG93IG91ciBzaW11bGF0ZWQgZWZmZWN0IHNpemUgYmVjb21lcyBtb3JlIGFjY3VyYXRlIHRoZSBiaWdnZXIgb3VyIHNhbXBsZSBnZXRzLg0KDQoNCiMjIyBVc2luZyBhIGNvcnJlbGF0ZWQtc2FtcGxlcyBwYWlyZWQgdC10ZXN0IGFwcHJvYWNoDQoNCg0KIyMjIyBUaGUgcmVsYXRpb25zaGlwIGJldHdlZW4gJFNEX3tkaWZmfSQgYW5kIHRoZSBjb3JyZWxhdGlvbg0KDQpJbiB0aGUgYWJvdmUgZXhhbXBsZSwgd2UgcmVzcGVjaWZpZWQgYSBwYWlyZWQgdC10ZXN0IGFzIGEgb25lLXNhbXBsZSB0LXRlc3Qgb24gdGhlIGRpZmZlcmVuY2Ugc2NvcmVzLg0KSG93ZXZlciwgd2hhdCB3ZSBhcmUgYWN0dWFsbHkgd29ya2luZyB3aXRoIGlzIHR3byBfY29ycmVsYXRlZF8gZGlzdHJpYnV0aW9ucyBvZiBtZWFzdXJlbWVudHMuDQpUbyBkZW1vbnN0cmF0ZSB0aGlzIHBvaW50LCBsZXQgdXMgaGF2ZSBhIGxvb2sgYXQgaG93IHdlIHdvdWxkIGFjdHVhbGx5IGNhbGN1bGF0ZSB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIHNjb3JlcyAoJFNEX3tkaWZmfSQpIGluIHRoZSBhYm92ZSBlcXVhdGlvbiBmb3IgJENvaGVuJ3NcIGQkLg0KVGhlIGZvcm11bGEgdG8gY2FsY3VsYXRlICRTRF97ZGlmZn0kIGZyb20gdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgdHdvIG1lYXN1cmVtZW50cyAocHJlIGFuZCBwb3N0KSBhbmQgdGhlaXIgY29ycmVsYXRpb24gaXM6DQoNCiQkU0Rfe2RpZmZ9ID0gXHNxcnR7U0Rfe3ByZX1eMitTRF97cG9zdH1eMi0yciBcdGltZXMgU0Rfe3ByZX0gXHRpbWVzIFNEX3twb3N0fX0gJCQNCg0KSXQgaXMgbm90IGltcG9ydGFudCBhdCB0aGlzIHBvaW50IHRvIHVuZGVyc3RhbmQgd2h5IHRoaXMgaXMgdGhlIGNhc2UgKHdlIHdpbGwganVzdCB0cnVzdCBbQ29oZW5dKGh0dHA6Ly93d3cudXRzdGF0LnRvcm9udG8uZWR1L35icnVubmVyL29sZGNsYXNzLzM3OGYxNi9yZWFkaW5ncy9Db2hlblBvd2VyLnBkZikgb24gdGhpcykgYnV0IHNlZSBob3cgd2UgY2FuLCBmb3IgYW55IGdpdmVuICRTRF97ZGlmZn0kIGFuZCBhc3N1bWluZyBib3RoIGdyb3VwcyBoYXZlLCBmb3IgZXhhbXBsZSwgYSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgMiwgc29sdmUgdGhlIGZvcm11bGEgdG8gc2VlIHdoYXQgY29ycmVsYXRpb24gKHRoZSAkciQgaW4gdGhlIGFib3ZlIGZvcm11bGEpIGl0IHdvdWxkIGltcGx5Lg0KDQoNCkltYWdpbmUsIGZvciBpbnN0YW5jZSwgd2UgYXNzdW1lIChsaWtlIGluIHRoZSBpbmRlcGVuZGVudC1zYW1wbGVzIHQtdGVzdCBhYm92ZSkgdGhhdCBib3RoIG1lYXN1cmVzIGhhdmUgYSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgMiBhbmQgdGhhdCB0aGUgc3RhbmRhcmQtZGV2aWF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIHNjb3JlcyB3b3VsZCBhbHNvIGJlIDIgc28gdGhhdCB3ZSB3b3VsZCBoYXZlIHRoZSBzYW1lIHNpdHVhdGlvbiBhcyBpbiB0aGUgb25lLXNhbXBsZSB0LXRlc3QgZXhhbXBsZSBhYm92ZSwgd2hlcmUgd2UgaGFkIGEgbWVhbi1kaWZmZXJlbmNlIG9mIDEgYW5kIGEgZGlmZmVyZW5jZS1zY29yZSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgMi4NCg0KRmlsbGluZyB0aGlzIGluIHdlIGdldCANCg0KJCQyID0gXHNxcnR7Ml4yKzJeMi0yciBcdGltZXMgMiBcdGltZXMgMn0gJCQNCg0KU29sdmluZyB0aGlzIGVxdWF0aW9uIGZvciAkciQsIHdlIGdldFteMl0gJHIgPSAwLjUkOg0KDQpUaGVyZWZvcmUsIGludGVyZXN0aW5nbHkgdGhlIHNpdHVhdGlvbiBpbiB3aGljaCB3ZSB1c2UgdGhlIHNhbWUgZ3JvdXBzIGFzIGFib3ZlIGFuZCBhc3N1bWUgdGhhdCB3ZSB3b3VsZCBnZXQgdGhlIHNhbWUgJFNEX3tkaWZmfSQgb2YgMiBhcyB3ZSBhc3N1bWVkIGluIG91ciBvbmUtc2FtcGxlIHNpdHVhdGlvbiB3b3VsZCBpbXBseSB0aGF0IHRoZSBjb3JyZWxhdGlvbiBiZXR3ZWVuIHRoZSBwcmUtIGFuZCB0aGUgcG9zdC1tZWFzdXJlIGlzICRyID0gMC41JC4NCldoYXQgZG9lcyB0aGlzIG1lYW4/IA0KV2VsbCwgbGV0cyBzZWUgd2hhdCBoYXBwZW5zIGlmIHdlIGFzc3VtZSBhIGNvcnJlbGF0aW9uIG9mICRyID0gLjkwJCBhbmQgc2VlIHdoYXQgJFNEX3tkaWZmfSQgd2UgZ2V0Og0KDQokJFNEX3tkaWZmfSA9IFxzcXJ0ezJeMisyXjItMiBcdGltZXMgMC45MCBcdGltZXMgMiBcdGltZXMgMn0gJCQNCg0KU29sdmluZyB0aGlzIGluIGBSYCBnaXZlcyB1czogYHNxcnQoMl4yKzJeMi0yKjAuOSoyKjIpYCA9IGByIHJvdW5kKHNxcnQoMl4yKzJeMi0yKjAuOSoyKjIpLCAyKWAuDQpUaHVzLCBpZiB0aGUgY29ycmVsYXRpb24gaW5jcmVhc2VzIHRoZSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgdGhlIGRpZmZlcmVuY2Utc2NvcmVzIGJlY29tZXMgc21hbGxlci4gDQpJZiB3ZSBkbyB0aGUgc2FtZSB3aXRoIGEgY29ycmVsYXRpb24gb2YgLjEwIHdlIGdldCBgc3FydCgyXjIrMl4yLTIqMC4xKjIqMilgID0gYHIgcm91bmQoc3FydCgyXjIrMl4yLTIqMC4xKjIqMiksIDIpYC4NClRodXMsIHdoZW4gdGhlIGNvcnJlbGF0aW9uIGRlY3JlYXNlcyB0aGUgc3RhbmRhcmQtZGV2aWF0aW9uIGJlY29tZXMgYmlnZ2VyLg0KSW50ZXJlc3RpbmdseSwgdGhpcyBkZW1vbnN0cmF0ZXMgdGhhdCBmb3IgdGhlIHNhbWUgbWVhbi1kaWZmZXJlbmNlLCBhIGhpZ2ggY29ycmVsYXRpb24gcmVzdWx0cyBpbiBhIF9sYXJnZXJfICRDb2hlbidzXCBkJCBhcyBjYWxjdWxhdGVkIGZvciB0aGUgZGlmZmVyZW5jZSBzY29yZXMgaW4gdGhlIG9uZS1zYW1wbGUgY2FzZS4NCkluIG90aGVyIHdvcmRzLCBhcyB0aGUgcHJlLXNjb3JlcyB0ZW5kIHRvIGJlIG1vcmUgc2ltaWxhciB0byB0aGUgcG9zdC1zY29yZXMgKGkuZS4gdGhleSBoYXZlIGEgaGlnaCBjb3JyZWxhdGlvbiksIHRoZSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgdGhlIGRpZmZlcmVuY2Ugc2NvcmVzIGRlY3JlYXNlcy4NClRoaXMsIGluIHR1cm4sIHJlc3VsdHMgaW4gaGlnaGVyIHBvd2VyIHRvIGRldGVjdCBhbiBlZmZlY3QuDQoNCg0KVG8gc3VtIHVwIGFsbCBvZiB0aGUgYWJvdmUsIHdlIGNhbiBlaXRoZXIgc3BlY2lmeSBhIGRpZmZlcmVuY2Utc2NvcmUgZGlzdHJpYnV0aW9uIGRpcmVjdGx5IGFuZCB0aGVyZWJ5IGltcGx5IGEgY2VydGFpbiBjb3JyZWxhdGlvbiBieSBzcGVjaWZ5aW5nIHRoZSAkU0Rfe2RpZmZ9JCwgb3Igd2UgY2FuIHNlZSB3aGF0ICRTRF97ZGlmZn0kIHdlIGdldCB3aXRoIGEgY2VydGFpbiBjb3JyZWxhdGlvbiBieSB1c2luZyB0aGUgZm9ybXVsYSBhYm92ZSBhbmQgdXNlIHRoZSByZXN1bHQgZm9yIHRoZSBvbmUtc2FtcGxlIHNpbXVsYXRpb24uDQpIb3dldmVyLCBpbnN0ZWFkIG9mIHdvcmtpbmcgd2l0aCB0aGUgb25lLXNhbXBsZSB0LXRlc3QsIGluIHRoZSBuZXh0IHNlY3Rpb24sIHdlIHdpbGwgc2VlIGhvdyB3ZSBjYW4gZGlyZWN0bHkgc2ltdWxhdGUgY29ycmVsYXRlZCBub3JtYWwtZGlzdHJpYnV0aW9ucyBpbiBgUmAuDQoNCg0KIyMjIyBTaW11bGF0aW5nIGNvcnJlbGF0ZWQgbm9ybWFsLWRpc3RyaWJ1dGlvbnMgYW5kIGRlbXlzdGlmeWluZyB0aGUgbXVsdGl2YXJpYXRlIG5vcm1hbC4NCg0KSW4gcmVhbCBsaWZlLCBhbG1vc3QgZXZlcnl0aGluZyBpcyBjb3JyZWxhdGVkIHRvIHNvbWUgZGVncmVlLiANClRob3VnaCB0aGVzZSBjb3JyZWxhdGlvbnMgYXJlIG9mdGVuIG5vdCBvZiBpbnRlcmVzdCwgdGhleSBzb21ldGltZXMgYXJlIGFuZCBpbiBhIGdvb2Qgc2ltdWxhdGlvbiB3ZSB3YW50IHRvIGFja25vd2xlZGdlIHRoZW0uIEZvciBpbnN0YW5jZSwgcHJlZGljdG9ycyBpbiBhIHJlZ3Jlc3Npb24gbWlnaHQgYmUgY29ycmVsYXRlZCBvciByYW5kb20gZWZmZWN0cyBpbiBhIG1peGVkLW1vZGVsLg0KDQpUaGUgZm9sbG93aW5nIHBhcnQgaXMgKGFnYWluKSBsb25nZXIgdGhhbiBJIGludGVuZGVkIGJ1dCBJIGZlZWwgdGhhdCBpdCBpcyBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCBob3cgd2Ugc2ltdWxhdGUgY29ycmVsYXRlZCBub3JtYWwtZGlzdHJpYnV0aW9ucyBhbmQgd2hhdCBhIG11bHRpdmFyaWF0ZSBub3JtYWwtZGlzdHJpYnV0aW9uIGlzLiANCkluIG1vc3QgY2FzZXMgbGF0ZXIgb24gd2Ugd2lsbCBkZWFsIHdpdGggc29tZSBraW5kIG9mIGNvcnJlbGF0ZWQgbm9ybWFsIGRpc3RyaWJ1dGlvbnMgKGluIG1peGVkLW1vZGVscyB3ZSB3aWxsIGFsd2F5cyBlbmNvdW50ZXIgdGhlbSBmb3IgZXhhbXBsZSkgc28gSSB0aGluayBpdCBoZWxwcyBpZiB3ZSBoYXZlIGEgbG9vayBhdCB0aGVtIG5vdyBpbiBhbiBlYXNpZXIgZXhhbXBsZSwgc28gd2UgaGF2ZSBvbmUgcHJvYmxlbSBsZXNzIHRvIHdvcnJ5IGFib3V0IGxhdGVyIG9uLg0KDQpSZXBocmFzaW5nIHRoZSBwcm9ibGVtIG9mIHNpbXVsYXRpbmcgdHdvIGNvcnJlbGF0ZWQgbm9ybWFsLWRpc3RyaWJ1dGlvbnMsIHdlIGNhbiBzYXkgdGhhdCB3ZSB3YW50IHRvIHNpbXVsYXRlIGEgX211bHRpdmFyaWF0ZSBub3JtYWwgZGlzdHJpYnV0aW9uXyBvciwgbW9yZSBzcGVjaWZpY2FsbHkgaW4gdGhpcyBjYXNlLCBhIF9iaXZhcmlhdGUgbm9ybWFsIGRpc3RyaWJ1dGlvbl8uIA0KSWYgeW91IG5ldmVyIGhlYXJkIHRoZXNlIHRlcm1zIGJlZm9yZSwgdGhleSBtaWdodCBzZWVtIHZlcnkgb3BhZ3VlLCBzbyBsZXQncyBzZWUgd2hhdCB0aGV5IGFyZS4NCkkgd2lsbCBmaXJzdCBzaG93IGhvdyB3ZSBjYW4gc2ltdWxhdGUgdGhlbSwgYW5kIGV4cGxhaW4gd2hhdCBleGFjdGx5IHRoaXMgbXVsdGl2YXJpYXRlIG5vcm1hbCBkaXN0cmlidXRpb24gbWVhbnMgYWZ0ZXJ3YXJkcyB3aXRoIGEgbGl0dGxlIHZpc3VhbCBpbnR1aXRvbi4NCldlIGNhbiBzaW11bGF0ZSBhIG11bHRpdmFyaWF0ZSBub3JtYWwgZGlzdHJpYnV0aW9uIGJ5IHVzaW5nIHRoZSBgbXZybm9ybSgpYCBmdW5jdGlvbiBmcm9tIHRoZSBgTUFTU2AgcGFja2FnZSBidXQgaXQgd29ya3Mgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gdGhlIHNpbXVsYXRpb24gZnVuY3Rpb25zIHRoYXQgd2UgaGF2ZSB1c2VkIHNvIGZhciAoYHJub3JtYCBhbmQgYHJiaW5vbWApLg0KTGV0cyBoYXZlIGEgbG9vayBhdCBob3cgdGhpcyB3b3JrcyAoY29kZSBleHBsYWluZWQgYmVsb3cpLg0KDQpgYGB7ciBzaW1fYml2bm9ybX0NCnJlcXVpcmUoTUFTUykgIyBsb2FkIE1BU1MgcGFja2FnZQ0KDQpwcmVfcG9zdF9tZWFucyA8LSBjKHByZSA9IDAscG9zdCA9IDEpICMgZGVmaW5lIG1lYW5zIG9mIHByZSBhbmQgcG9zdCBpbiBhIHZlY3Rvcg0KcHJlX3NkIDwtIDIgIyBkZWZpbmUgc2Qgb2YgcHJlLW1lYXN1cmUNCnBvc3Rfc2QgPC0gMiAjIGRlZmluZSBzZCBvZiBwb3N0LW1lYXN1cmUNCmNvcnJlbGF0aW9uIDwtIDAuNSAjIGRlZmluZSB0aGVpciBjb3JyZWxhdGlvbg0KDQpzaWdtYSA8LSBtYXRyaXgoYyhwcmVfc2ReMiwgcHJlX3NkKnBvc3Rfc2QqY29ycmVsYXRpb24sIHByZV9zZCpwb3N0X3NkKmNvcnJlbGF0aW9uLCBwb3N0X3NkXjIpLCBuY29sID0gMikgIyBkZWZpbmUgdmFyaWFuY2UtY292YXJpYW5jZSBtYXRyaXgNCg0Kc2V0LnNlZWQoMSkNCmJpdm5vcm0gPC0gZGF0YS5mcmFtZShtdnJub3JtKDEwMDAwLCBwcmVfcG9zdF9tZWFucywgc2lnbWEpKSAjIHNpbXVsYXRlIGJpdmFyaWF0ZSBub3JtYWwNCg0KYGBgDQoNClRoZSBhYm92ZSBjb2RlIHNhbXBsZXMgMTAsMDAwIG9ic2VydmF0aW9ucyBmcm9tIGEgYml2YXJpYXRlIG5vcm1hbC1kaXN0cmlidXRpb24sIG9yIGluIHRlcm1zIG9mIG91ciBleGFtcGxlLCBpdCBzYW1wbGVzIDEwLDAwMCBwcmUtbWVhc3VyZXMgd2l0aCAxMCwwMDAgY29ycmVsYXRlZCBwb3N0LW1lYXN1cmVzLg0KVGhlIGZpcnN0IHRoaW5nIHRoYXQgaXMgZGlmZmVyZW50IGZyb20gb3VyIGVhcmxpZXIgc2ltdWxhdGlvbnMgaXMgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGNvZGUgYHByZV9wb3N0X21lYW5zIDwtIGMoMCwxKWAuIA0KSW5zdGVhZCBvZiBkZWZpbmluZyBvdXIgbWVhbnMgc2VwZXJhdGVseSBmb3IgZWFjaCBtZWFzdXJlbWVudCwgYXMgd2UgaGF2ZSBkb25lIGVhcmxpZXIgaW4gdGhlIGluZGVwZW5kZW50LXNhbXBsZSBjYXNlLCB3ZSBub3cgcHV0IHRoZSBwcmUtIGFuZCBwb3N0LW1lYXN1cmVtZW50IG1lYW4gdGhhdCB3ZSBhc3N1bWUgaW50byBhIHZlY3Rvci4NClRoaXMgaXMgYmVjYXVzZSB3ZSB3aWxsIHNpbXVsYXRlIGJvdGggbWVhc3VyZW1lbnRzIHRvZ2V0aGVyIGluIHRoZSBgbXZybm9ybWAgZnVuY3Rpb24sIGFuZCB0aGVyZWZvcmUgYm90aCBtZWFucyBuZWVkIHRvIGJlIHByb3ZpZGVkIGF0IHRoZSBzYW1lIHRpbWUuDQoNClNlY29uZGx5LCB3ZSBkZWZpbmUgdGhlIHN0YW5kYXJkLWRldmlhdGlvbnMgb2YgYm90aCBtZWFzdXJlbWVudHMganVzdCBhcyB3ZSBkaWQgZWFybGllciBhbmQgYWxzbyBzcGVjaWZ5IGEgY29ycmVsYXRpb24gdGhhdCB3ZSB3b3VsZCBsaWtlIG91ciBkYXRhLXBvaW50cyB0byBoYXZlLCBpbiB0aGlzIGNhc2UgMC41Lg0KDQpOb3csIHRoZSBsaW5lIGBtYXRyaXgoYyhwcmVfc2ReMiwgcHJlX3NkKnBvc3Rfc2QqY29ycmVsYXRpb24sIHByZV9zZCpwb3N0X3NkKmNvcnJlbGF0aW9uLCBwb3N0X3NkXjIpLCBuY29sID0gMilgIGRvZXMgc29tZXRoaW5nIHRoYXQgd2UgaGF2ZSBub3QgZG9uZSBiZWZvcmUgYW5kIGl0IG1pZ2h0IGxvb2sgcXVpdGUgY29uZnVzaW5nLg0KV2hhdCB3ZSBhcmUgZG9pbmcgaGVyZSBpcyBzcGVjaWZ5aW5nIHRoZSBfdmFyaWFuY2UtY292YXJpYW5jZSBtYXRyaXhfLiANClRoaXMgaXMgbm90aGluZyBtb3JlIHRoYW4gYSB0YWJsZSBjb250YWluaW5nIHRoZSB2YXJpYW5jZXMgb2Ygb3VyIHByZS0gYW5kIHBvc3QtbWVhc3VyZW1lbnQgKHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgZW50cnkgaW4gdGhlIGxpc3QpIGFuZCB0aGUgY292YXJpYW5jZSBiZXR3ZWVuIHRoZSB0d28gdmFyaWFibGVzIHR3aWNlIC0gb25jZSBmb3IgZWFjaCBtZWFzdXJlbWVudCAodGhlIG1pZGRsZSAyIGVudHJpZXMgaW4gdGhlIGxpc3QpLg0KQ29uY2VwdHVhbGx5IHlvdSBjYW4gc2VlIHRoaXMgdmFyaWFuY2UtY292YXJpYW5jZSBtYXRyaXggYXMgdGhlIHN0YW5kYXJkLWRldmlhdGlvbiBvZiB0aGUgbXVsdGl2YXJpYXRlIG5vcm1hbCB0aGF0IGBtdnJub3JtYCBuZWVkcyBpbnN0ZWFkIG9mIHRoZSBzdGFuZGFyZC1kZXZpYXRpb24gdGhhdCB3ZSBwdXQgaW50byBgcm5vcm1gIGVhcmxpZXIuDQoNCldlIGNhbiB2aXN1YWxpemUgdGhlIHZhcmlhbmNlLWNvdmFyaWFuY2UgbWF0cml4IGBzaWdtYWAgdG8gZGVteXN0aWZ5IGl0IGEgYml0Lg0KDQpgYGB7ciB0YWJsZV9zaWdtYX0NCmNvbG5hbWVzKHNpZ21hKSA8LSBjKCJwcmUiLCAicG9zdCIpDQpyb3duYW1lcyhzaWdtYSkgPC0gYygicHJlIiwgInBvc3QiKQ0Kc2lnbWENCmBgYA0KDQpUaHVzLCB0aGlzIG1hdHJpeCBpcyBub3RoaW5nIG1vcmUgdGhhbiBhIHRhYmxlIGNvbnRhaW5pbmcgdGhlIHZhcmlhbmNlIG9mIGVhY2ggdmFyaWFibGUgKDQgaW4gZWFjaCBjYXNlKSBhbmQgdGhlaXIgY292YXJpYW5jZSAoaS5lLiB0aGUgY29ycmVsYXRpb24gb2YgdGhlIHR3byBtdWx0aXBsaWVkIGJ5IGJvdGggc3RhbmRhcmQtZGV2aWF0aW9ucyAoJENvdihwcmUscG9zdCkgPSBccmhvKHByZSxwb3N0KSpzZF97cHJlfSpzZF97cG9zdH0kKS4NCg0KSW4gdGhlIG5leHQgbGluZSBvZiB0aGUgY29kZSB3ZSBwdXQgdGhpcyBhbGwgaW50byBgbXZybm9ybWAgdG8gc2ltdWxhdGUgb3VyIGJpdmFyaWF0ZSBub3JtYWwgZGlzdHJpYnV0aW9uIGFuZCBzdG9yZSB0aGUgcmVzdWx0cyBpbiBhIGRhdGEtZnJhbWUgd2l0aCAyIGNvbHVtbnMsIGVhY2ggY29udGFpbmluZyBvbmUgbWVhc3VyZW1lbnQgcG9pbnQ6DQoNCmBgYHtyIGJpdmFyX2RhdH0NCmhlYWQoYml2bm9ybSkNCmBgYA0KDQpXaGVuIHdlIHJ1biBgY29yKGJpdm5vcm0kcHJlLCBiaXZub3JtJHBvc3QpYCB3ZSBzZWUgdGhhdCBpbmRlZWQgdGhlaXIgY29ycmVsYXRpb24gaXMgYHIgcm91bmQoY29yKGJpdm5vcm0kcHJlLCBiaXZub3JtJHBvc3QpLCAyKWAgYW5kIGNsb3NlIHRvIHdoYXQgd2Ugc3BlY2lmaWVkLg0KDQpUbyBzZWUgaG93IHdlIGNhbiBpbWFnaW5lIHN1Y2ggYSBiaXZhcmlhdGUgbm9ybWFsIGRpc3RyaWJ1dGlvbiwgd2UgY2FuIHZpc3VhbGl6ZSBpdCB0aGUgZm9sbG93aW5nIHdheS4NCg0KSWYgd2UgZHJhdyBhIGhpc3RvZ3JhbSBvZiBlYWNoIG1lYXN1cmVtZW50IGluZGl2aWR1YWxseSwgaXQgbG9va3MgbGlrZSB0aGlzLg0KDQpgYGB7ciBwbG90X2Jpdm5vcm0xfQ0KcGFyKG1mcm93PWMoMSwyKSkNCmhpc3QoYml2bm9ybSRwcmUsIG1haW4gPSAicHJlLW1lYXN1cmUiKQ0KaGlzdChiaXZub3JtJHBvc3QsIG1haW4gPSAicG9zdC1tZWFzdXJlIikNCmBgYA0KDQpIb3dldmVyLCBpbWFnaW5lIHdlIHdvdWxkIG5vdCBvbmx5IGxvb2sgYXQgZWFjaCBoaXN0b2dyYW0gc2VwZXJhdGVseSBidXQgd2Ugd291bGQgY29tYmluZSB0aGVtIGludG8gb25lIHBsb3QgYnkgcHV0dGluZyB0aGUgcHJlLW1lYXN1cmUgc2NvcmVzIG9mIGVhY2ggc2ltdWxhdGVkIGluZGl2aWR1YWwgb24gdGhlIHgtYXhpcyBhbmQgcHV0dGluZyB0aGUgcG9zdC1tZWFzdXJlcyBvbiB0aGUgeS1heGlzIGxpa2UgdGhpczoNCg0KYGBge3IgcGxvdF9iaXZub3JtMn0NCnBsb3QoYml2bm9ybSRwcmUsIGJpdm5vcm0kcG9zdCwgeGxhYiA9ICJwcmUtbWVhc3VyZSIsIHlsYWIgPSAicG9zdC1tZWFzdXJlIikNCmBgYA0KDQoNCkluIHRoZSBhYm92ZSBwbG90LCB3ZSBjYW4gY2xlYXJseSBzZWUgdGhlIGNvcnJlbGF0aW9ucyBiZXR3ZWVuIHRoZSB0d28gbWVhc3VyZW1lbnRzIHRoYXQgd2UgcHV0IGluIHRoZSBkYXRhLiANCk1vcmUgZWxlZ2FudGx5LCB3ZSBjYW4gY29tYmluZSB0aGUgdHdvIGhpc3RvZ3JhbXMgaW4gdGhlIGZvbGxvd2luZyB3YXkuDQoNCmBgYHtyIHBsb3RfYml2bm9ybTN9DQpiaXZub3JtX2tkZSA8LSBrZGUyZChiaXZub3JtWywxXSwgYml2bm9ybVssMl0sIG4gPSA1MCkgIyBjYWxjdWxhdGUga2VybmVsIGRlbnNpdHkgKGkuZS4gdGhlICJoZWlnaHQgb2YgdGhlIGNvbmUgb24gdGhlIHotYXhpcyI7IG5vdCBzbyBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCBoZXJlKQ0KcGFyKG1hciA9IGMoMCwgMCwgMCwgMCkpICMgdGVsIHIgbm90IHRvIGxlYXZlIHNvIG11Y2ggc3BhY2UgYXJvdW5kIHRoZSBwbG90DQpwZXJzcChiaXZub3JtX2tkZSwgcGhpID0gNDUsIHRoZXRhID0gMzAsIHhsYWIgPSAicHJlLW1lYXN1cmUiLCB5bGFiID0gInBvc3QtbWVhc3VyZSIsIHpsYWIgPSAiZnJlcXVlbmN5IikgIyBwbG90IHRoZSBiaXZhcmlhdGUgbm9ybWFsDQpgYGANCg0KSGVyZSwgd2Ugc2VlIGNsZWFybHkgaG93IG91ciBiaXZhcmlhdGUgbm9ybWFsIGRpc3RyaWJ1dGlvbiBpcyBub3RoaW5nIG1vcmUgdGhhbiB0aGUgMiBub3JtYWwtZGlzdHJpYnV0aW9ucyBvZiBlYWNoIG1lYXN1cmVtZW50LXBvaW50IGNvbWJpbmVkIGludG8gb25lICJjb25lLXNoYXBlZCIgbm9ybWFsIGRpc3RyaWJ1dGlvbiB0aGF0IGhhcyBhIGNlcnRhaW4gY29ycmVsYXRpb24uDQoNClRoZSBwbG90IGJlbG93IHNob3dzIGhvdyB0aGlzIGNvbmUgbG9va3Mgd2l0aCBkaWZmZXJlbnQgY29ycmVsYXRpb25zLg0KDQoNCmBgYHtyIHBsb3RfYml2bm9ybV9jb3JzLCBlY2hvID0gRkFMU0UsIG91dC53aWR0aD0nMTIwJSd9DQpjb3IxMCA8LSAuMTANCnNpZ21hXzEwIDwtIG1hdHJpeChjKHByZV9zZF4yLCBwcmVfc2QqcG9zdF9zZCpjb3IxMCwgcHJlX3NkKnBvc3Rfc2QqY29yMTAsIHBvc3Rfc2ReMiksIG5jb2wgPSAyKQ0KYml2bm9ybV8xMCA8LSBtdnJub3JtKDFlNSwgcHJlX3Bvc3RfbWVhbnMsIHNpZ21hXzEwKQ0KYml2bm9ybTEwX2tkZSA8LSBrZGUyZChiaXZub3JtXzEwWywxXSwgYml2bm9ybV8xMFssMl0sIG4gPSA1MCkNCg0KDQpjb3I5MCA8LSAuOTANCnNpZ21hXzkwIDwtIG1hdHJpeChjKHByZV9zZF4yLCBwcmVfc2QqcG9zdF9zZCpjb3I5MCwgcHJlX3NkKnBvc3Rfc2QqY29yOTAsIHBvc3Rfc2ReMiksIG5jb2wgPSAyKQ0KYml2bm9ybV85MCA8LSBtdnJub3JtKDFlNSwgcHJlX3Bvc3RfbWVhbnMsIHNpZ21hXzkwKQ0KYml2bm9ybTkwX2tkZSA8LSBrZGUyZChiaXZub3JtXzkwWywxXSwgYml2bm9ybV85MFssMl0sIG4gPSA1MCkNCg0KcGFyKG1hciA9IGMoMSwgMCwgMSwgMCkpICMgdGVsbCByIG5vdCB0byBsZWF2ZSBzbyBtdWNoIHNwYWNlIGFyb3VuZCB0aGUgcGxvdA0KcGFyKG1mcm93PWMoMSwzKSkNCnBlcnNwKGJpdm5vcm0xMF9rZGUsIHBoaSA9IDQ1LCB0aGV0YSA9IDMwLCB4bGFiID0gInByZS1tZWFzdXJlIiwgeWxhYiA9ICJwb3N0LW1lYXN1cmUiLCB6bGFiID0gImZyZXF1ZW5jeSIsIG1haW4gPSAiY29ycmVsYXRpb24gPSAuMTAiKQ0KcGVyc3AoYml2bm9ybV9rZGUsIHBoaSA9IDQ1LCB0aGV0YSA9IDMwLCB4bGFiID0gInByZS1tZWFzdXJlIiwgeWxhYiA9ICJwb3N0LW1lYXN1cmUiLCB6bGFiID0gImZyZXF1ZW5jeSIsIG1haW4gPSAiY29ycmVsYXRpb24gPSAuNTAiKQ0KcGVyc3AoYml2bm9ybTkwX2tkZSwgcGhpID0gNDUsIHRoZXRhID0gMzAsIHhsYWIgPSAicHJlLW1lYXN1cmUiLCB5bGFiID0gInBvc3QtbWVhc3VyZSIsIHpsYWIgPSAiZnJlcXVlbmN5IiwgbWFpbiA9ICJjb3JyZWxhdGlvbiA9IC45MCIpDQoNCmBgYA0KDQpOb3RpY2UgaG93IGZvciBoaWdoZXIgY29ycmVsYXRpb25zLCB0aGUgY29uZSBiZWNvbWVzIG1vcmUgYW5kIG1vcmUgbmFycm93IGFuZCBzdGFydHMgbG9va2luZyBsaWtlIGEgInNoYXJrLWZpbiIgd2l0aCBhIGNvcnJlbGF0aW9uIG9mIC45MC4NClRoaXMgIm5hcnJvd3JpbmciIG9mIHRoZSBjb25lIGlzIHRoZSB2aXN1YWxpemF0aW9uIG9mIHdoeSB0aGUgc3RhbmRhcmQtZGV2aWF0aW9ucyBvZiB0aGUgZGlmZmVyZW5jZSBzY29yZXMgZ2V0IG1vcmUgbmFycm93LiANCg0KSWYgd2UgdmlzdWFsaXplIHRoaXMgYXMgYSBwb2ludCBjbG91ZCBhZ2FpbiB0aGUgdGhyZWUgY29ycmVsYXRpb25zIGxvb2sgbGlrZSB0aGlzOg0KDQpgYGB7ciBjb3JyZWxhdGlvbl9wb2ludHBsb3RzfQ0KYml2bm9ybV8xMCA8LSBhcy5kYXRhLmZyYW1lKGJpdm5vcm1fMTApDQpiaXZub3JtXzkwIDwtIGFzLmRhdGEuZnJhbWUoYml2bm9ybV85MCkNCnBhcihtZnJvdyA9IGMoMSwzKSkNCnBsb3QoYml2bm9ybV8xMCRwcmUsIGJpdm5vcm1fMTAkcG9zdCkNCnBsb3QoYml2bm9ybSRwcmUsIGJpdm5vcm0kcG9zdCkNCnBsb3QoYml2bm9ybV85MCRwcmUsIGJpdm5vcm1fOTAkcG9zdCkNCmBgYA0KDQpUaGlzIGFnYWluLCBjbGVhcmx5IHNob3dzIHRoZSBtYW5pcHVsYXRpbm8gYmV0d2VlbiB0aGUgcHJlLSBhbmQgcG9zdCBtZWFzdXJlcy4NCg0KIyMjIyBQb3dlci1hbmFseXNpcyB3aXRoIHRoZSBtdWx0aXZhcmlhdGUgbm9ybWFsDQoNCk5vdyB0aGF0IHdlIGtub3cgd2hhdCB3ZSBhcmUgZG9pbmcgd2hlbiB1c2luZyBgbXZybm9ybWAgd2UgY2FuIGdvIGFoZWFkIGFuZCBkbyBhIHBvd2VyLXNpbXVsYXRpb24gZm9yIHRoZSBleGFtcGxlIGFib3ZlIHdpdGggYSBiaXZhcmlhdGUgbm9ybWFsLWRpc3RyaWJ1dGlvbi4NCkhvd2V2ZXIsIGFzIHdlIGFyZSBub3Qgc3VyZSBob3cgYmlnIG91ciBjb3JyZWxhdGlvbiBpcywgd2UgY2FuIHRyeSAzIGRpZmZlcmVudCBjb3JyZWxhdGlvbnMgaW4gdGhlIGNvZGUgYWJvdmUgYnkgcGxhY2luZyB0aGUgc2ltdWxhdGlvbiBpbiBhbm90aGVyIGZvci1sb29wIGFuZCB0ZWxsaW5nIGl0IHRvIHRyeSBkaWZmZXJlbnQgY29ycmVsYXRpb25zLg0KDQpgYGB7ciBsYWJlbCwgb3B0aW9uc30NCm11X3ByZV9wb3N0IDwtIGMocHJlID0gMCwgcG9zdCA9IDEpDQpzZF9wcmUgPC0gMg0Kc2RfcG9zdCA8LSAyDQpjb3JyZWxhdGlvbnMgPC0gYygwLjEsIDAuNSwgMC45KQ0KDQpzZXQuc2VlZCgxKQ0Kbl9zaW1zIDwtIDEwMDAgIyB3ZSB3YW50IDEwMDAgc2ltdWxhdGlvbnMNCnBfdmFscyA8LSBjKCkNCiMgdGhpcyB2ZWN0b3Igd2lsbCBjb250YWluIHRoZSBwb3dlciBmb3IgZWFjaCBzYW1wbGUtc2l6ZSAoaXQgbmVlZHMgdGhlIGluaXRpYWwgMCBmb3IgdGhlIHdoaWxlLWxvb3AgdG8gd29yaykNCmNvaGVuc19kcyA8LSBjKCkNCg0KcG93ZXJzX2F0X2NvciA8LSBsaXN0KCkNCmNvaGVuc19kc19hdF9jb3IgPC0gbGlzdCgpDQoNCmZvcihpY29yIGluIDE6bGVuZ3RoKGNvcnJlbGF0aW9ucykpeyAjIGRvIGEgcG93ZXItc2ltdWxhdGlvbiBmb3IgZWFjaCBzcGVjaWZpZWQgc2ltdWxhdGlvbg0KICBuIDwtIDIgIyBzYW1wbGUtc2l6ZSANCiAgaSA8LSAyICMgaW5kZXggb2YgdGhlIHdoaWxlIGxvb3AgZm9yIHNhdmluZyB0aGluZ3MgaW50byB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIGxpc3RzDQogIHBvd2VyX2F0X24gPC0gYygwKSANCiAgY29oZW5zX2RzX2F0X24gPC0gYygpIA0KICBzaWdtYSA8LSBtYXRyaXgoYyhzZF9wcmVeMiwgc2RfcHJlKnNkX3Bvc3QqY29ycmVsYXRpb25zW2ljb3JdLCBzZF9wcmUqc2RfcG9zdCpjb3JyZWxhdGlvbnNbaWNvcl0sIHNkX3Bvc3ReMiksIG5jb2wgPSAyKSAjdmFyLWNvdmFyIG1hdHJpeA0KICB3aGlsZShwb3dlcl9hdF9uW2ktMV0gPCAuOTUpew0KICAgIGZvcihzaW0gaW4gMTpuX3NpbXMpew0KICAgICAgYml2bm9ybSA8LSBkYXRhLmZyYW1lKG12cm5vcm0obiwgbXVfcHJlX3Bvc3QsIHNpZ21hKSkgIyBzaW11bGF0ZSB0aGUgYml2YXJpYXRlIG5vcm1hbA0KICAgICAgcF92YWxzW3NpbV0gPC0gdC50ZXN0KGJpdm5vcm0kcHJlLCBiaXZub3JtJHBvc3QsIHBhaXJlZCA9IFRSVUUsIHZhci5lcXVhbCA9IFRSVUUsIGNvbmYubGV2ZWwgPSAwLjkpJHAudmFsdWUgIyBydW4gdC10ZXN0IGFuZCBleHRyYWN0IHRoZSBwLXZhbHVlDQogICAgICBjb2hlbnNfZHNbc2ltXSA8LSBhYnMoKG1lYW4oYml2bm9ybSRwcmUpLW1lYW4oYml2bm9ybSRwb3N0KSkvKHNxcnQoc2QoYml2bm9ybSRwcmUpXjIrc2QoYml2bm9ybSRwb3N0KV4yLTIqY29yKGJpdm5vcm0kcHJlLCBiaXZub3JtJHBvc3QpKnNkKGJpdm5vcm0kcHJlKSpzZChiaXZub3JtJHBvc3QpKSkpICMgd2UgYWxzbyBzYXZlIHRoZSBjb2hlbnMgZHMgdGhhdCB3ZSBvYnNlcnZlZCBpbiBlYWNoIHNpbXVsYXRpb24NCiAgICB9DQogICAgcG93ZXJfYXRfbltpXSA8LSBtZWFuKHBfdmFscyA8IC4xMCkgIyBjaGVjayBwb3dlciAoaS5lLiBwcm9wb3J0aW9uIG9mIHAtdmFsdWVzIHRoYXQgYXJlIHNtYWxsZXIgdGhhbiBhbHBoYS1sZXZlbCBvZiAuMTApDQogICAgbmFtZXMocG93ZXJfYXRfbilbaV0gPC0gbg0KICAgIGNvaGVuc19kc19hdF9uW2ldIDwtIG1lYW4oY29oZW5zX2RzKSAjIGNhbGN1bGF0ZSBtZWFucyBvZiBjb2hlbnMgZHMgZm9yIGVhY2ggc2FtcGxlLXNpemUNCiAgICBuYW1lcyhjb2hlbnNfZHNfYXRfbilbaV0gPC0gbg0KICAgIG4gPC0gbisxICMgaW5jcmVhc2Ugc2FtcGxlLXNpemUgYnkgMQ0KICAgIGkgPC0gaSsxICMgaW5jcmVhc2UgaW5kZXggb2YgdGhlIHdoaWxlLWxvb3AgYnkgMSB0byBzYXZlIHBvd2VyIGFuZCBjb2hlbnMgZCB0byB2ZWN0b3INCiAgfQ0KICBwb3dlcl9hdF9uIDwtIHBvd2VyX2F0X25bLTFdICMgZGVsZXRlIGZpcnN0IDAgZnJvbSB0aGUgdmVjdG9yDQogIGNvaGVuc19kc19hdF9uIDwtIGNvaGVuc19kc19hdF9uWy0xXSAjIGRlbGV0ZSBmaXJzdCBOQSBmcm9tIHRoZSB2ZWN0b3INCiAgcG93ZXJzX2F0X2NvcltbaWNvcl1dIDwtIHBvd2VyX2F0X24gIyBzdG9yZSB0aGUgZW50aXJlIHBvd2VyIGN1cnZlIGZvciB0aGlzIGNvcnJlbGF0aW9uIGluIGEgbGlzdA0KICBjb2hlbnNfZHNfYXRfY29yW1tpY29yXV0gPC0gY29oZW5zX2RzX2F0X24gIyBkbyB0aGUgc2FtZSBmb3IgY29oZW5zIGQNCiAgbmFtZXMocG93ZXJzX2F0X2NvcilbW2ljb3JdXSA8LSBjb3JyZWxhdGlvbnNbaWNvcl0gIyBuYW1lIHRoZSBwb3dlci1jdXJ2ZSBpbiB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHRlc3RlZCBjb3JyZWxhdGlvbg0KICBuYW1lcyhjb2hlbnNfZHNfYXRfY29yKVtbaWNvcl1dIDwtIGNvcnJlbGF0aW9uc1tpY29yXSAjIHNhbWUgZm9yIGNvaGVucyBkDQp9DQpgYGANCg0KDQpBZ2FpbiwgdGhlIGFib3ZlIGNvZGUgcnVucyBhIHBvd2VyLXNpbXVsYXRpb24sIG9yIG1vcmUgc3BlY2lmaWNhbGx5IHRocmVlIHBvd2VyLWFuYWx5c2VzLCBvbmUgZm9yIGVhY2ggY29ycmVsYXRpb24gdGhhdCB3ZSB3YW50ZWQgdG8gdGVzdC4NCk5vdGljZSBob3cgdGhpcyB0aW1lIHdlIHNwZWNpZnkgYHBhaXJlZCA9IFRSVUVgIGluIHRoZSBgdC50ZXN0YCBmdW5jdGlvbiwgdG8gaW5kaWNhdGUgdGhhdCB3ZSBhcmUgZGVhbGluZyB3aXRoIG5vbi1pbmRlcGVuZGVudCBvYnNlcnZhdGlvbnMuDQpBbHNvIG5vdGUgdGhhdCBhIG5ldyBwYXJ0IG9mIHRoZSBjb2RlIHNhdmVzIHRoZSBgcG93ZXJfYXRfbmAgdmVjdG9yIHRvIGEgbGlzdCBjYWxsZWQgYHBvd2VyX2F0X2NvcmAuIA0KVGhpcyBsaXN0LCB3aWxsIGhhdmUgMyBlbGVtZW50cywgZWFjaCBvZiB0aGVtIHRoZSBwb3dlciBjdXJ2ZSBmb3Igb25lIG9mIHRoZSBjb3JyZWxhdGlvbnMuDQpXZSBjYW4gYWNjZXNzIGVhY2ggcG93ZXItY3VydmUgYmVpIGVpdGhlciBgcG93ZXJzX2F0X2NvcltbMV1dYCB0byBnZXQgdGhlIGZpcnN0IHZlY3RvciBpbiB0aGUgbGlzdCAodGhlIGRvdWJsZSBzcXVhcmUgYnJhY2tldHMgbWVhbiBmaXJzdCBlbnRpcmUgdmVjdG9yIHJhdGhlciB0aGFuIGZpcnN0IG51bWJlciBvbmx5KSBvciB3ZSBjYW4gdXNlIGl0IGJ5IGluZGljYXRpbmcgaXRzIG5hbWUgYXMgYHBvd2Vyc19hdF9jb3IkYDAuMWAgdG8gdGVsbCBSIHRoYXQgd2Ugd2FudCB0aGUgcG93ZXIgY3VydmUgZm9yIGEgY29ycmVsYXRpb24gb2YgLjEwLg0KDQpXZSBjYW4gcGxvdCB0aGVzZSBwb3dlci1jdXJ2ZXMgbmV4dCB0byBlYWNoIG90aGVyDQoNCmBgYHtyIHBvd2VyY3VydmVfY29ycl90LXRlc3QsIG91dC53aWR0aD0nMTIwJSd9DQpwYXIobWZyb3c9YygxLDMpKQ0KcGxvdCgyOihsZW5ndGgocG93ZXJzX2F0X2NvciRgMC4xYCkrMSksIHBvd2Vyc19hdF9jb3IkYDAuMWAsIHhsYWIgPSAiTnVtYmVyIG9mIHBhcnRpY2lwYW50cyIsIHlsYWIgPSAiUG93ZXIiLCB5bGltID0gYygwLDEpLCBheGVzID0gVFJVRSwgbWFpbiA9ICJjb3JyZWxhdGlvbiA9IDAuMSIpDQphYmxpbmUoaCA9IC45NSwgY29sID0gInJlZCIpDQpwbG90KDI6KGxlbmd0aChwb3dlcnNfYXRfY29yJGAwLjVgKSsxKSwgcG93ZXJzX2F0X2NvciRgMC41YCwgeGxhYiA9ICJOdW1iZXIgb2YgcGFydGljaXBhbnRzIiwgeWxhYiA9ICJQb3dlciIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBUUlVFLCBtYWluID0gImNvcnJlbGF0aW9uID0gMC41IikNCmFibGluZShoID0gLjk1LCBjb2wgPSAicmVkIikNCnBsb3QoMjoobGVuZ3RoKHBvd2Vyc19hdF9jb3IkYDAuOWApKzEpLCBwb3dlcnNfYXRfY29yJGAwLjlgLCB4bGFiID0gIk51bWJlciBvZiBwYXJ0aWNpcGFudHMiLCB5bGFiID0gIlBvd2VyIiwgeWxpbSA9IGMoMCwxKSwgYXhlcyA9IFRSVUUsIG1haW4gPSAiY29ycmVsYXRpb24gPSAwLjkiKQ0KYWJsaW5lKGggPSAuOTUsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCkhlcmUgd2Ugc2VlIGhvdyBkcmFzdGljYWxseSB0aGUgY29ycmVsYXRpb24gaW5mbHVlbmNlcyB0aGUgcG93ZXIgaW4gdGhpcyBzaXR1YXRpb24uDQpXaXRoIGEgaGlnaCBjb3JyZWxhdGlvbiwgd2UgbmVlZCBvbmx5IHZlcnkgZmV3IHBhcnRpY2lwYW50cyB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIHBvd2VyIGluIHRoZSBzcGVjaWZpZWQgY2FzZS4NCldoeSBpcyB0aGlzPyANClRoZSByZWFzb24gZm9yIHRoaXMgaXMgd2hhdCB3ZSBoYWQgYSBsb29rIGF0IGFib3ZlOiBUaGUgZGVjcmVhc2luZyBzdGFuZGFyZC1kZXZpYXRpb24gb2YgdGhlIGRpZmZlcmVuY2Ugc2NvcmVzIHRoZSBoaWdoZXIgdGhlIGNvcnJlbGF0aW9uIGdldHMuIA0KDQpUaGlzIGlzIGhvdyB0aGUgZWZmZWN0LXNpemVzIGxvb2suDQoNCmBgYHtyIGNvaGVuc19kX2NvcnJfdHRlc3QsIG91dC53aWR0aD0nMTIwJSd9DQpwYXIobWZyb3c9YygxLDMpKQ0KcGxvdCgyOihsZW5ndGgoY29oZW5zX2RzX2F0X2NvciRgMC4xYCkrMSksIGNvaGVuc19kc19hdF9jb3IkYDAuMWAsIHhsYWIgPSAiTnVtYmVyIG9mIHBhcnRpY2lwYW50cyIsIHlsYWIgPSAiQ29oZW5zIEQiLCB5bGltID0gYygwLDEpLCBheGVzID0gVFJVRSwgbWFpbiA9ICJjb3JyZWxhdGlvbiA9IDAuMSIpDQphYmxpbmUoaCA9IC41MCwgY29sID0gInJlZCIpDQpwbG90KDI6KGxlbmd0aChjb2hlbnNfZHNfYXRfY29yJGAwLjVgKSsxKSwgY29oZW5zX2RzX2F0X2NvciRgMC41YCwgeGxhYiA9ICJOdW1iZXIgb2YgcGFydGljaXBhbnRzIiwgeWxhYiA9ICJDb2hlbnMgRCIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBUUlVFLCBtYWluID0gImNvcnJlbGF0aW9uID0gMC41IikNCmFibGluZShoID0gLjUwLCBjb2wgPSAicmVkIikNCnBsb3QoMjoobGVuZ3RoKGNvaGVuc19kc19hdF9jb3IkYDAuOWApKzEpLCBjb2hlbnNfZHNfYXRfY29yJGAwLjlgLCB4bGFiID0gIk51bWJlciBvZiBwYXJ0aWNpcGFudHMiLCB5bGFiID0gIkNvaGVucyBEIiwgeWxpbSA9IGMoMCwxMCksIGF4ZXMgPSBUUlVFLCBtYWluID0gImNvcnJlbGF0aW9uID0gMC45IikNCmFibGluZShoID0gLjUwLCBjb2wgPSAicmVkIikNCmBgYA0KDQpGb3IgLjEwIHRoZSB2YWx1ZSBvZiB0aGUgZWZmZWN0LXNpemUgc2VlbXMgc2xpZ2h0bHkgdW5kZXJlc3RpbWF0ZWQsIGZvciAuNTAgaXQgYXBwcm9hY2hlcyAuNTAganVzdCBhcyBpbiB0aGUgdHdvLXNhbXBsZSBjYXNlIGFuZCBmb3IgLjkwIGl0IHNlZW1zIG92ZXJlc3RpbWF0ZWQgYnkgcXVpdGUgYSBiaXQuIA0KRGlkIHNvbWV0aGluZyBnbyB3cm9uZz8NCldlbGwgbm8uIEFzIHdlJ3ZlIHNlZW4gYWJvdmUgJENvaGVuJ3NcIGQkIGlzIGNhbGN1bGF0ZWQgYnkgZGl2aWRpbmcgdGhlIG1lYW4tZGlmZmVyZW5jZSBieSB0aGUgc3RhbmRhcmQtZGV2aWF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIHNjb3JlcyB3aGljaCBiZWNvbWVzIHNtYWxsZXIgYW5kIHNtYWxsZXIgd2l0aCBpbmNyZWFzaW5nIGNvcnJlbGF0aW9uLg0KVGhlcmVmb3JlLCBjYWxjdWxhdGVkIHRoaXMgd2F5LCAkQ29oZW4nc1wgZCQgaXMgbXVjaCBiaWdnZXIgaW4gdGhlIGNhc2Ugd2l0aCB0aGUgbGFyZ2VyIGNvcnJlbGF0aW9uLg0KVGhpcyBpcyBhbHNvIHdoeSB3ZSBzZWVtIHRvIGhhdmUgbXVjaCBiaWdnZXIgcG93ZXIgLSB3ZSBqdXN0IHdvcmsgd2l0aCBhIGxhcmdlciBlZmZlY3Qgc2l6ZSB0aGFuIHdlIGludGVuZGVkLg0KV2UgY2FuIGV2ZW4gY2FsY3VsYXRlIGJ5IGhvdyBtdWNoIHRoZSBlZmZlY3Qtc2l6ZSBpcyBpbmZsdWVuY2VkIGJ5IHRoZSBjb3JyZWxhdGlvbiBieSBkaXZpZGluZyB0aGUgZWZmZWN0LXNpemUgdGhhdCB3ZSB3b3VsZCBjYWxjdWxhdGUgYmFzZWQgb24gdGhlIG1lYW5zIGFuZCBzZHMgb2Ygb3VyIGdyb3VwcyBieSAkXHNxcnR7MigxLXIpfSQuIA0KDQpyID0gLjkwIC0tPiBgMC41L3NxcnQoMiooMS0uOTApKWAgPSBgciAwLjUvc3FydCgyKigxLS45MCkpYA0KciA9IC41MCAtLT4gYDAuNS9zcXJ0KDIqKDEtLjUwKSlgID0gYHIgMC41L3NxcnQoMiooMS0uNTApKWANCnIgPSAuMTAgLS0+IGAwLjUvc3FydCgyKigxLS4xMCkpYCA9IGByIDAuNS9zcXJ0KDIqKDEtLjEwKSlgDQoNCllvdSBtaWdodCB3b25kZXIgaG93IHdlIGNhbiBzcGVjaWZ5IGVmZmVjdC1zaXplcyBpbiB0aGVzZSBjYXNlcyBvZiBjb3JyZWxhdGVkIGRhdGEuIERvIHdlICJjb3JyZWN0IiB0aGUgZXhwZWN0ZWQgZWZmZWN0IGZvciB0aGUgY29ycmVsYXRpb24gb3IgZG8gd2UganVzdCBhc3N1bWUgdGhhdCBpdCBpcyAuNTAgYW5kIHVzZSB0aGUgb25lLXNhbXBsZSBzY2VuYXJpbyBhYm92ZT8gDQpJIGRvIG5vdCBoYXZlIGEgZ29vZCBhbnN3ZXIgZm9yIHRoaXMuIA0KSW4gbWFueSBjYXNlcyBpdCBtaWdodCBiZSBmaW5lIHRvIG9ubHkgc3BlY2lmeSB0aGUgZWZmZWN0LXNpemUgb2YgdGhlIHByZS1wb3N0IGRlc2lnbiBiYXNlZCBvbiB0aGUgZGlmZmVyZW5jZSBzY29yZXMgYXMgd2UgZGlkIGluIHRoZSBvbmUtc2FtcGxlIGNhc2UuDQpJbiBzb21lIGNhc2VzLCBob3dldmVyLCB3ZSBtaWdodCBmaW5kIHRoZSBjb3JyZWxhdGlvbiB2ZXJ5IGltcG9ydGFudCBvciBoYXZlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvcnJlbGF0aW9uIG9mIDIgbWVhc3VyZXMgdGhhbiBhYm91dCB0aGUgY2hhbmdlIGluIG1lYXN1cmVzIGR1ZSB0byBhbiBpbnRlcnZlbnRpb24uIA0KSW4gdGhvc2UgY2FzZXMsIGl0IG1pZ2h0IG1ha2Ugc2Vuc2UgdG8gYmUgdmVyeSBzcGVjaWZpYyBhYm91dCB0aGUgZXhwZWN0ZWQgY29ycmVsYXRpb25zIGFuZCBiZSBhd2FyZSB0aGF0IHdlIG1pZ2h0IG5lZWQgbW9yZSBkYXRhIGlmIHRoZSBjb3JyZWxhdGlvbiBpcyBsb3cuDQpFdmVudHVhbGx5LCBvdXIgZGF0YSBzdGVtIGZyb20gYW4gdW5kZXJseWluZyBfZGF0YSBnZW5lcmF0aW5nIHByb2Nlc3NfIHRoYXQgaW5jbHVkZXMgdGhlIGNvcnJlbGF0aW9uIGJldHdlZW4gdmFyaWFibGVzIGFuZCBtZWFzdXJlcyBhbmQgaXQgaXMgYWx3YXlzIGdvb2QgdG8gYmUgYXdhcmUgb2YgdGhlIGZhY3RvcnMgdGhhdCBtaWdodCBwb3NzaWJseSBpbmZsdWVuY2UgdGhlIHJlc3VsdHMuIA0KV2hlbiB3ZSBjb2xsZWN0IGRhdGEgaW4gYSBwcmUtcG9zdCBkZXNpZ24sIHdlIF9kb18gaW4gZmFjdCBtZWFzdXJlIGEgc2NvcmUgYXQgMiB0aW1lLXBvaW50cyBhbmQgZG8gbm90IGRpcmVjdGx5IGFzc2VzcyB0aGUgZGlmZmVyZW5jZS4gDQpXaGVuIHdlIHNwZWNpZnkgdGhlIHN0YW5kYXJkLWRldmlhdGlvbiBvZiB0aGUgZGlmZmVyZW5jZSBzY29yZXMgaG93ZXZlciwgdG8gYXJyaXZlIGF0IGEgZ2l2ZW4gJENvaGVuJ3NcIGQkLCB3ZSBpbXBsaWNpdGVseSBtYWtlIGFzc3VtcHRpb25zIGFib3V0IHRoZSBjb3JyZWxhdGlvbnMgb2YgdGhlc2UgdHdvIG1lYXN1cmVzLg0KDQpUaGUgVGFrZS1ob21lIG1lc3NhZ2UgaGVyZSBpcyB0aGF0IGNvcnJlbGF0aW9ucyBtYXR0ZXIgYW5kIHRoYXQgd2UgbmVlZCB0byBiZSBhd2FyZSBvZiB0aGlzLiBUaGUgZ29vZCBuZXdzIGlzIHRoYXQgcG93ZXItc2ltdWxhdGlvbnMgd2lsbCBhdCBsZWFzdCBtYWtlIHVzIGF3YXJlIG9mIHRoZXNlIGZhY3RvcnMgYW5kIHNob3cgdXMgaG93IGRpZmZlcmVudCBhc3N1bXB0aW9ucyBsZWFkIHRvIGRpZmZlcmVudCByZXN1bHRzLiANCg0KDQojIyBTdW1tYXJ5OiBPdXIgZmlyc3Qgc2ltdWxhdGlvbnMgd2l0aCB0LXRlc3RzDQoNClRoaXMgd2FzIHRoZSBsYXN0IGJpdCB0aGF0IEkgd2FudGVkIHRvIGRpc2N1c3MgYWJvdXQgc2ltdWxhdGluZyB0LXRlc3RzIGFuZCB0aGUgZW5kIG9mIHBhcnQgSUkgb2YgdGhpcyB0dXRvcmlhbC4NCldlIGhhdmUgbm93IGxlYXJuZWQgaG93IHRvIHNpbXVsYXRlIGEgdC10ZXN0IGJ5IHVzaW5nIGVpdGhlciAkQ29oZW4nc1wgZCQgYXMgYW4gZWZmZWN0LXNpemUgZXN0aW1hdGUgYW5kLCBpZiBuZWNlc3NhcnksIHRlbGwgYFJgIHRoYXQgb3VyIHR3byBncm91cHMsIG9yIG1lYXN1cmVtZW50cywgYXJlIGNvcnJlbGF0ZWQgaW4gc29tZSB3YXkuDQpXaGF0IHdlIGxlYXJuZWQgYWJvdmUgaXMgbm90IHJlc3RyaWN0ZWQgdG8gZG9pbmcgdC10ZXN0cyBob3dldmVyLg0KU2ltdWxhdGluZyB1bml2YXJpYXRlIChpLmUuIHVuY29ycmVsYXRlZCkgb3IgbXVsdGl2YXJpYXRlIChpLmUuIGNvcnJlbGF0ZWQpIG5vcm1hbC1kaXN0cmlidXRpb25zIHdpbGwgYmUgd2hhdCB3ZSBkbyBtb3N0IG9mIHRoZSB0aW1lIGluIHBhcnQgSUlJIGFuZCBwYXJ0IElWIG9mIHRoZSB0dXRvcmlhbC4NClRoZSBvbmx5IHRoaW5nIHRoYXQgd2lsbCBjaGFuZ2UgZm9yIG1vcmUgY29tcGxpY2F0ZWQgZGVzaWducyBpcyBob3cgd2UgY29tYmluZSB0aGUgZGlmZmVyZW50IHRvb2xzIHRoYXQgd2UgbGVhcm5lZCBpbiB0aGlzIHBhcnQgdG8gYWNoaWV2ZSBvdXIgZ29hbC4NCg0KSW4gcGFydCBJSUkgb2YgdGhpcyB0dXRvcmlhbCwgd2Ugd2lsbCBzZWUgaG93IHdlIGNhbiBiYXNpY2FsbHkgcnVuIGV2ZXJ5IGFuYWx5c2lzIGFzIGEgbGluZWFyIG1vZGVsIHVzaW5nIHRoZSBgbG1gIGZ1bmN0aW9uIGluc3RlYWQgb2YgdXNpbmcgdGhlIGB0LnRlc3RgIGZ1bmN0aW9uIGZvciB0LXRlc3RzLCB0aGUgYGFvdmAgZnVuY3Rpb24gZm9yIEFOT1ZBLWRlc2lnbnMgYW5kIHNvIGZvcnRoLg0KQnkgZXhwbG9yaW5nIGhvdyB0aGlzIHdvcmtzIGZvciB0LXRlc3QsIGFub3ZhIGFuZCByZWdyZXNzaW9uIHdlIHdpbGwgc2ltdWxhdGUgb3VyIHdheSB0aHJvdWdoIHRoZSB0aGlyZCBwYXJ0IGFuZCBiZSBmbGV4aWJsZSBlbm91Z2ggdG8gc2ltdWxhdGUgYW55IGNsYXNzaWNhbCByZXNlYXJjaCBkZXNpZ25zIHRoYXQgd2Ugd291bGQsIGZvciBleGFtcGxlLCBiZSBhYmxlIHRvIGRvIGluIEdQb3dlci4gSW4gcGFydCBJViB3ZSB3aWxsIGdvIGJleW9uZCB0aGlzIGFuZCBzaW11bGF0ZSBtaXhlZC1lZmZlY3QgbW9kZWxzLg0KDQojIEZvb3Rub3Rlcw0KDQpbXjFdOg0KVGhpbmsgYmFjayB0byB0aGUgcG9zc2libGUgc2VxdWVuY2VzIG9mIGNvaW4gdG9zc2VzIGluIHBhcnQgSS4gDQpJbnN0ZWFkIG9mIHBvc3NpYmxlIHNlcXVlbmNlcyBvZiBjb2luLXRvc3Nlcywgd2UgZGVhbCB3aXRoIHBvc3NpYmxlIHNlcXVlbmNlcyBvZiBwZW9wbGUtc2NvcmVzIGhlcmUsIGFzc3VtaW5nIHRoYXQgdGhleSBjb21lIGZyb20gdGhlIHVuZGVybHlpbmcgZGlzdHJpYnV0aW9uIHRoYXQgd2Ugc3BlY2lmeS4NClRvIGdldCBhIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBhbGwgdGhlIHBvc3NpYmxlIHNhbXBsZXMgdGhhdCB3ZSBjb3VsZCBnZXQgdGhhdCBzdGlsbCBmb2xsb3cgdGhlIHNwZWNpZmllZCBkaXN0cmlidXRpb24sIHdlIG5lZWQgdG8gc2ltdWxhdGUgbWFueSwgbWFueSB0aW1lcy4NCg0KW14yXTogDQpUaGlzIGlzIGhvdyB3ZSBzb2x2ZSBmb3Igcjo8bWF0aCB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCIgZGlzcGxheT0iYmxvY2siPg0KICA8bXRhYmxlIGRpc3BsYXlzdHlsZT0idHJ1ZSIgY29sdW1uYWxpZ249InJpZ2h0IGxlZnQgcmlnaHQgbGVmdCByaWdodCBsZWZ0IHJpZ2h0IGxlZnQgcmlnaHQgbGVmdCByaWdodCBsZWZ0IiBjb2x1bW5zcGFjaW5nPSIwZW0gMmVtIDBlbSAyZW0gMGVtIDJlbSAwZW0gMmVtIDBlbSAyZW0gMGVtIiByb3dzcGFjaW5nPSIzcHQiPg0KICAgIDxtdHI+DQogICAgICA8bXRkPjwvbXRkPg0KICAgICAgPG10ZD4NCiAgICAgICAgPG1uPjI8L21uPg0KICAgICAgICA8bW8+PTwvbW8+DQogICAgICAgIDxtc3FydD4NCiAgICAgICAgICA8bXN1cD4NCiAgICAgICAgICAgIDxtbj4yPC9tbj4NCiAgICAgICAgICAgIDxtbj4yPC9tbj4NCiAgICAgICAgICA8L21zdXA+DQogICAgICAgICAgPG1vPis8L21vPg0KICAgICAgICAgIDxtc3VwPg0KICAgICAgICAgICAgPG1uPjI8L21uPg0KICAgICAgICAgICAgPG1uPjI8L21uPg0KICAgICAgICAgIDwvbXN1cD4NCiAgICAgICAgICA8bW8+JiN4MjIxMjs8L21vPg0KICAgICAgICAgIDxtbj4yPC9tbj4NCiAgICAgICAgICA8bWk+cjwvbWk+DQogICAgICAgICAgPG1vPiYjeEQ3OzwvbW8+DQogICAgICAgICAgPG1uPjI8L21uPg0KICAgICAgICAgIDxtbz4mI3hENzs8L21vPg0KICAgICAgICAgIDxtbj4yPC9tbj4NCiAgICAgICAgPC9tc3FydD4NCiAgICAgIDwvbXRkPg0KICAgIDwvbXRyPg0KICAgIDxtdHI+DQogICAgICA8bXRkPg0KICAgICAgICA8bXN0eWxlIHNjcmlwdGxldmVsPSIwIj4NCiAgICAgICAgICA8bXNwYWNlIHdpZHRoPSJ0aGlja21hdGhzcGFjZSI+PC9tc3BhY2U+DQogICAgICAgIDwvbXN0eWxlPg0KICAgICAgICA8bW8gc3RyZXRjaHk9ImZhbHNlIj4mI3gyN0ZBOzwvbW8+DQogICAgICAgIDxtc3R5bGUgc2NyaXB0bGV2ZWw9IjAiPg0KICAgICAgICAgIDxtc3BhY2Ugd2lkdGg9InRoaWNrbWF0aHNwYWNlIj48L21zcGFjZT4NCiAgICAgICAgPC9tc3R5bGU+DQogICAgICA8L210ZD4NCiAgICAgIDxtdGQ+DQogICAgICAgIDxtbj4yPC9tbj4NCiAgICAgICAgPG1vPj08L21vPg0KICAgICAgICA8bXNxcnQ+DQogICAgICAgICAgPG1uPjg8L21uPg0KICAgICAgICAgIDxtbz4mI3gyMjEyOzwvbW8+DQogICAgICAgICAgPG1uPjg8L21uPg0KICAgICAgICAgIDxtaT5yPC9taT4NCiAgICAgICAgPC9tc3FydD4NCiAgICAgIDwvbXRkPg0KICAgICAgPG10ZD4NCiAgICAgICAgPG1pPjwvbWk+DQogICAgICAgIDxtc3VwPg0KICAgICAgICAgIDxtbyBzdHJldGNoeT0iZmFsc2UiPnw8L21vPg0KICAgICAgICAgIDxtbj4yPC9tbj4NCiAgICAgICAgPC9tc3VwPg0KICAgICAgPC9tdGQ+DQogICAgPC9tdHI+DQogICAgPG10cj4NCiAgICAgIDxtdGQ+DQogICAgICAgIDxtc3R5bGUgc2NyaXB0bGV2ZWw9IjAiPg0KICAgICAgICAgIDxtc3BhY2Ugd2lkdGg9InRoaWNrbWF0aHNwYWNlIj48L21zcGFjZT4NCiAgICAgICAgPC9tc3R5bGU+DQogICAgICAgIDxtbyBzdHJldGNoeT0iZmFsc2UiPiYjeDI3RkE7PC9tbz4NCiAgICAgICAgPG1zdHlsZSBzY3JpcHRsZXZlbD0iMCI+DQogICAgICAgICAgPG1zcGFjZSB3aWR0aD0idGhpY2ttYXRoc3BhY2UiPjwvbXNwYWNlPg0KICAgICAgICA8L21zdHlsZT4NCiAgICAgIDwvbXRkPg0KICAgICAgPG10ZD4NCiAgICAgICAgPG1uPjQ8L21uPg0KICAgICAgICA8bW8+PTwvbW8+DQogICAgICAgIDxtbj44PC9tbj4NCiAgICAgICAgPG1vPiYjeDIyMTI7PC9tbz4NCiAgICAgICAgPG1uPjg8L21uPg0KICAgICAgICA8bWk+cjwvbWk+DQogICAgICA8L210ZD4NCiAgICAgIDxtdGQ+DQogICAgICAgIDxtaT48L21pPg0KICAgICAgICA8bXJvdz4NCiAgICAgICAgICA8bW8gc3RyZXRjaHk9ImZhbHNlIj58PC9tbz4NCiAgICAgICAgPC9tcm93Pg0KICAgICAgICA8bW8+JiN4MjIxMjs8L21vPg0KICAgICAgICA8bW4+ODwvbW4+DQogICAgICAgIDxtbz47PC9tbz4NCiAgICAgICAgPG1vPiYjeEY3OzwvbW8+DQogICAgICAgIDxtbyBzdHJldGNoeT0iZmFsc2UiPig8L21vPg0KICAgICAgICA8bW8+JiN4MjIxMjs8L21vPg0KICAgICAgICA8bW4+ODwvbW4+DQogICAgICAgIDxtbyBzdHJldGNoeT0iZmFsc2UiPik8L21vPg0KICAgICAgPC9tdGQ+DQogICAgPC9tdHI+DQogICAgPG10cj4NCiAgICAgIDxtdGQ+DQogICAgICAgIDxtc3R5bGUgc2NyaXB0bGV2ZWw9IjAiPg0KICAgICAgICAgIDxtc3BhY2Ugd2lkdGg9InRoaWNrbWF0aHNwYWNlIj48L21zcGFjZT4NCiAgICAgICAgPC9tc3R5bGU+DQogICAgICAgIDxtbyBzdHJldGNoeT0iZmFsc2UiPiYjeDI3RkE7PC9tbz4NCiAgICAgICAgPG1zdHlsZSBzY3JpcHRsZXZlbD0iMCI+DQogICAgICAgICAgPG1zcGFjZSB3aWR0aD0idGhpY2ttYXRoc3BhY2UiPjwvbXNwYWNlPg0KICAgICAgICA8L21zdHlsZT4NCiAgICAgIDwvbXRkPg0KICAgICAgPG10ZD4NCiAgICAgICAgPG1uPjAuNTwvbW4+DQogICAgICAgIDxtbz49PC9tbz4NCiAgICAgICAgPG1pPnI8L21pPg0KICAgICAgPC9tdGQ+DQogICAgPC9tdHI+DQogIDwvbXRhYmxlPg0KPC9tYXRoPg0KDQoNCg==" download="power-analysis-by-data-simulation-in-r-part-iii.Rmd">Download power-analysis-by-data-simulation-in-r-part-iii.Rmd</a>
<style type="text/css">
button.btn.collapsed:before
{
    content:'+' ;
    display:block;
    width:15px;
}
button.btn:before
{
    content:'-' ;
    display:block;
    width:15px;
}
</style>
<div id="the-power-analysis-by-simulation-in-r-for-really-any-design---part-iii" class="section level1">
<h1>The Power Analysis by simulation in <code>R</code> for really any design - Part III</h1>
<p>This is Part III of my tutorial on how to do power-analysis by simulation.
In Part I, we saw how to do a simulation for a simple toy-example with a coin-toss.
In part II we learned how to simulate univariate and multivariate normal-distributions, specify our assumptions about the expected effect and test our simulated data with different t-tests.
In this part, we will focus on how we can write a flexible test for any model by making use of the fact that many statistical standard methods (e.g. t-test, ANOVA) can be rewritten as a linear model.
This way, no matter what situation we find ourselves in, we will always be able to use the same power-simulation with only slight changes.</p>
<p>In part IV we will learn how to apply this technique to complicated designs such as linear mixed-effects models and generalized mixed-effects models.</p>
<div id="revisiting-the-t-test-just-another-linear-model" class="section level2">
<h2>Revisiting the t-test: just another linear model</h2>
<p>Before I even start with this topic, I want to point out that I took much of the information I present here from Jonas Kristoffer Lindelov’s <strong>fantastic</strong> blog post <a href="https://lindeloev.github.io/tests-as-linear/">“Common statistical tests are linear models (or: how to teach stats)”</a>.
If you have not read it yet, you should definitely do so, either now or after you finished this part of the tutorial.
Seriously, it is a great blog-post that inspired me to write up this part of the tutorial in a similar way in which we want to learn one flexible method of data-simulation rather than changing what we are doing for each different situation.</p>
<p>Ok so what does it mean to say that, for instance, a t-test is just a linear model?
First of all, here is a quick reminder about the linear model with a quick example:</p>
<p><span class="math display">\[
y_i = \beta_0 + \beta_1x_i
\]</span></p>
<p>The above formula states that each value of y (the little i can be read as “each”) can be described by adding a value <span class="math inline">\(\beta_0\)</span> and the product of <span class="math inline">\(beta_0 \times x\)</span>.
Now, how does this relate to the t-test? Again, if you want a more in-depth discussion read the blog-post above.
To demonstrate the point, lets revisit the example from part II of this tutorial.
We had 2 groups and we assumed that one group can be described as <code>group1 = normal(0,2)</code> and the other group can be described as <code>group2 = normal(1,2)</code>.
Now if we want to test whether the difference in means is significant, we can run a independent-samples t-test.
However, if we rephrase the problem what we want to know whether group membership (whether you belong to group1 or group2; the <span class="math inline">\(x\)</span> variable in this case) significantly <em>predicts</em> the person’s score (y in this case).
To do so, we can just assume let <span class="math inline">\(beta_0\)</span> describe the mean of, say, group1 in this case.
If we do this and if we re-write model above to predict the mean of group1, it looks the following way:</p>
<p><span class="math display">\[
M_{group1} = M_{group1}+\beta_1\times x
\]</span></p>
<p>What should <span class="math inline">\(\beta_1\)</span> and <span class="math inline">\(x\)</span> be in this case?
Well, as we already have the mean of group1 on the right side in the term that was previously <span class="math inline">\(beta_0\)</span>, we do not want to add <em>anything</em> to it.
Thus, if someone member from group1, to predict the mean-score we should have an observed value for group-membership of 0.
This way, the formula becomes</p>
<p><span class="math display">\[
M_{group1} = M_{group1}+\beta_1\times 0
\]</span></p>
<p>and the <span class="math inline">\(\beta_1\)</span> term becomes 0 entirely. Note that we of course do not know the mean of group1 as we will <em>simulate</em> it.
<span class="math inline">\(\beta_0\)</span> (or <span class="math inline">\(M_{group1}\)</span> here) is a <em>parameter</em>, i.e. something that we want the model to estimate because we do not know it.</p>
<p>What if we want to describe the mean of a person in group2?
We can do this by just adding something to the mean of group1, namely the <em>difference</em> between the two groups.
In other words, we can describe the mean of group2 by saying its the mean of group1 + the difference of their means times x:</p>
<p><span class="math display">\[
M_{group2} = M_{group1}+(M_{group2}-M_{group1})\times x
\]</span></p>
<p>What should <span class="math inline">\(\beta_1\)</span> and <span class="math inline">\(x\)</span> be now?
Just like <span class="math inline">\(\beta_0\)</span>, our new mean-difference parameter <span class="math inline">\(\beta_1\)</span> is an unknown that depends on our simulated means and will be estimated by the model.
<span class="math inline">\(x\)</span> on the other hand should be 1, because if someone is from group2 we want the predicted mean of that person to be the mean of group1 + <strong>1 times</strong> the difference between group1 and group2.</p>
<p>Therefore if someone is from group2 our model becomes:</p>
<p><span class="math display">\[
M_{group2} = M_{group1}+(M_{group2}-M_{group1})\times 1
\]</span></p>
<p>What we just did is so-called <em>dummy coding</em>, i.e. we made a new dummy variable that tells us someone’s group membership:</p>
<ul>
<li>0 if the person is in group1</li>
<li>1 if the person is in group2</li>
</ul>
<p>If we use this dummy variable in the linear model we can do exactly the same test that we did with the t-test earlier.
Let me demonstrate with the exact same groups that we simulated in the beginning of part II of this tutorial.</p>
<pre class="r"><code>set.seed(1234)
group1 &lt;- rnorm(30, 1, 2)
group2 &lt;- rnorm(30, 0, 2)</code></pre>
<p>Now we can run the independent-samples t-test again, yielding the same results as in part II.</p>
<pre class="r"><code>t.test(group1, group2, paired = FALSE, var.equal = TRUE, conf.level = 0.9)</code></pre>
<pre><code>## 
##  Two Sample t-test
## 
## data:  group1 and group2
## t = 3.1402, df = 58, p-value = 0.002656
## alternative hypothesis: true difference in means is not equal to 0
## 90 percent confidence interval:
##  0.7064042 2.3143690
## sample estimates:
## mean of x mean of y 
##  0.407150 -1.103237</code></pre>
<p>To do our linear model analysis instead, we first have to create a data-frame that contains the 2 groups and tells us about their group membership.
In other words we will make a data-set that has the variables <code>score</code> which are the values in the vectors of group1 and group2 and a variable <code>group</code> that will be 0 if a person is from group1 and 1 if the person is from group2.
In this case, after putting the data together, we create a dummy variable with <code>ifelse</code> a function that you can read like: if the group variable has value “group1” in a certain row, then make dummy_group in that row = 0, else make it 1.</p>
<pre class="r"><code>names(group1) &lt;- rep(&quot;group1&quot;, length(group1)) # name the vectors to use the names as the group variable
names(group2) &lt;- rep(&quot;group2&quot;, length(group2))

lm_groupdat &lt;- data.frame(score = c(group1,group2), group = c(names(group1), names(group2))) # make data-set from scores and names

lm_groupdat$dummy_group &lt;- ifelse(lm_groupdat$group == &quot;group1&quot;, 0, 1) # create dummy variable </code></pre>
<p>Now we can use this to run our linear model with the <code>lm</code> function.
In case you have not used it before, we indicate the <em>intercept</em>, i.e. <span class="math inline">\(beta_0\)</span> with a 1 in this case, to tell the model that we want 1 times <span class="math inline">\(beta_0\)</span> in there and tell it that we want dummy_group times the difference between the groups, <span class="math inline">\(beta_1\)</span> in there.
The code looks like this:</p>
<pre class="r"><code>summary(lm(score ~ 1+ dummy_group, dat = lm_groupdat)) # use summary function to get p-values</code></pre>
<pre><code>## 
## Call:
## lm(formula = score ~ 1 + dummy_group, data = lm_groupdat)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -4.0985 -1.1327 -0.4088  0.7360  5.4245 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)   
## (Intercept)   0.4072     0.3401   1.197  0.23612   
## dummy_group  -1.5104     0.4810  -3.140  0.00266 **
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.863 on 58 degrees of freedom
## Multiple R-squared:  0.1453, Adjusted R-squared:  0.1306 
## F-statistic: 9.861 on 1 and 58 DF,  p-value: 0.002656</code></pre>
<p>First let us see what the estimates mean in this case.
The intercept has an estimate of .4072.
As we said earlier, this, <span class="math inline">\(\beta_0\)</span>, should be the group-mean of group1 and indeed wee see that <code>mean(group1)</code> = 0.40715 gives us the same result.
What is the second estimate, <span class="math inline">\(\beta_1\)</span> for dummy_group should yield the difference between the means.
We can confirm that <code>mean(group2)-mean(group1)</code> = -1.5103866 gives us the same result in this case.
Further we see that the DFs, t-value and p-value are identical to the earlier t-test.</p>
<p>This method would also work with the one-sample t-test approach and the paired-samples t-test approach from part II of the tutorial, but I will leave it as an exercise to the reader to try it out, as I do want to move on to other situations.
Again (cannot mention this enough) make sure you head to Jonas Kristoffer Lindelov’s <a href="https://lindeloev.github.io/tests-as-linear/">blog post</a> if you want to see how to do this or if you want to read more on this topic.</p>
</div>
<div id="simulating-a-2x2-between-subject-anova-as-a-linear-model" class="section level2">
<h2>Simulating a 2x2 between-subject ANOVA (as a linear model)</h2>
<div id="how-to-specify-raw-effect-sizes-with-no-prior-data" class="section level3">
<h3>How to specify raw effect-sizes with no prior data</h3>
<p>In this part, I will give an example of how we could specify prior effect-sizes for our research design given we have not collected any prior data and are only working with assumptions.</p>
<p>Ok time to move on to more sophisticated designs.
Imagine you are interested in students attitude towards smoking and how it depends on the medium of the message and the focus of the message.
More precisely we want to know whether people’s attitude is different after seeing a visual anti-smoking message (these pictures on the package) vs a text-message (the text belonging to that picture).
Moreover, we are interested in whether the attitude that people report is different after seeing a message that regards the consequences on other people (e.g. smoking can harm your loved ones) as compared to yourself (smoking can cause cancer).
Thus we have the following design</p>
<p><em>Disclaimer: This is just an example that i made up so it does not reflect any real-life effect and one might easily argue a different way as this RQ is not based on any underlying theory but it allows me to demonstrate the point without further elaborating on any psychological theory.</em></p>
<p>DV: attitude towards smoking (0-100)
IV1: medium (text vs. visual)
IV2: focus (internal vs. external)</p>
<p>This is, there are 4 groups:</p>
<ul>
<li>group_TI will receive text-messages that are internal</li>
<li>group_TE will receive text-messages that are external</li>
<li>group_VI will receive visual messages that are internal</li>
<li>group_VE will receive visual messages that are external</li>
</ul>
<p>Lets assume that we expect that people’s attitude will be more negative after seeing a visual rather than text message if the focus is internal (i.e. the message is about yourself) because it might be difficult to imagine that oneself would get cancer after reading a text but seeing a picture might cause fear regardless.
For the external focus on the other hand, we expect a more negative attitude after reading a text as compared to seeing a picture, as it might have more impact on attitude to imagine a loved one get hurt than seeing a stranger in a picture suffering from the consequences of second-hand smoking.
Furthermore, we expect that the internal focus messages will be related to lower attitudes compared to the external focus messages on average but we expect no main-effect of picture vs. text-messages.</p>
<p>Thus, we expect:</p>
<ul>
<li>no main-effect of medium</li>
<li>main-effect of focus</li>
<li>crossover-interaction of medium x focus</li>
</ul>
<p>At this point, in my opinion it is more difficult to work with standardized effect-sizes like partial correlations e.g. in this case then just to specify everything on the response scale directly.
A first good step is to visualize some rough means that show the desired behavior that we described in words earlier and see where we are going, starting with the main-effects.</p>
<p>We expect a main effect of focus so the means of the 2 internal groups should be lower (more negative attitude) than the means of the external groups.
For example, we could make the overall mean of the internal focus groups (group_TI and group_VI) 20 and the mean of the external groups (group_TE and group_VE) 50.
Note how this would already reflect the main-effect but also a belief that the smoking-attitudes are on average quite negative as we assume both means to be on the low end of the scale.
However, for now we just want to make a rough guess and we might adjust our expectations in a second.</p>
<p>Ok so now what we have to do is specify the means for the media groups in a way that reflects our interaction hypothesis.
We could for example assume that the mean of group_TI is 30 while the mean of group_VI is 10 and we could assume that the mean of group_TE is 40 and the mean of group_VE is 60.</p>
<p>This way, for the internal groups, visual messages are more negative than texts, while for the external groups texts are more negative than visual messages.</p>
<p>We could plot this to see how it looks like</p>
<pre class="r"><code>focus &lt;- rep(c(&quot;internal&quot;, &quot;external&quot;), each = 2)
media &lt;- rep(c(&quot;text&quot;, &quot;visual&quot;), times = 2)
mean_TI &lt;- 50
mean_VI &lt;- 20
mean_TE &lt;- 30
mean_VE &lt;- 60

pd &lt;- data.frame(score = c(mean_TI, mean_VI, mean_TE, mean_VE), focus = focus, media = media)

interaction.plot(pd$focus, pd$media, pd$score, ylim = c(0,100))</code></pre>
<p><img src="/post/2020-06-16-power-analysis-by-data-simulation-in-r-part-iii_files/figure-html/plot_exp1-1.png" width="672" /></p>
<pre class="r"><code>mean(pd$score[pd$focus == &quot;internal&quot;]) != mean(pd$score[pd$focus == &quot;external&quot;])</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>mean(pd$score[pd$media == &quot;text&quot;]) == mean(pd$score[pd$media == &quot;visual&quot;])</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>We can see that the above situation satisfies all things that we wanted to specify:</p>
<ul>
<li>The means of the two focus groups are not the same so that internal are lower than external values if we pool over the media conditions.</li>
<li>The mean for both media conditions are the same so there is no main-effect.</li>
<li>The lines cross over showing the interaction that we wanted.</li>
</ul>
<p>However, three problems remain here.
First of all, the simple slope for the visual messages is steeper than the simple slope for the text messages, which is not something we specified in our hypotheses beforehand.
It rather comes as a side-effect of that we want our internal means to be lower than the external means but we also want the visual messages to be more impactful in the internal condition while our text-messages should be more impactful on the external conditions.
Do we find this plausible or do we think this would rather be the other way around?</p>
<div class="notebox">
<p>
This a good point for a short reflection: You might already be overwhelmed how complicated power-analysis by simulation already is with these still relatively simple designs.
However, notice that e.g. the follow-up tests for the slopes are things that we <em>can</em> care about but we do not <em>need</em> to care about them.
Our interaction-hypothesis is mainly interested in whether the difference in scores between the visual and the text messages when comparing the internal focus group is the same as the difference for the external groups.
As this is clearly not the case in this example, we are good to go and test the interaction hypothesis.
However, if we clearly are interested in the simple slopes and have hypotheses about them, we <em>can</em> put it in our simulation, and that of course urges us to think some more but it is a <em>great</em> tool to see whether we actually thought about everything, as this might be a point that would have slipped our attention entirely when running a classical power-analysis and pre-registering the overall interaction only.
Now, we can think about it if we <em>want</em> to or continue by saying that for now we only want to specify the interaction.
</p>
</div>
<p>Let us assume that we are fine with the fact that visual messages differ somewhat more than text messages.
However, the numbers we have chosen so far are all but plausible.
In this case, if we want to come up with more plausible numbers it is good if, instead of thinking about means directly, we make assumptions about how each of the group-means will differ from the overall <em>population</em> mean.
For instance, we can assume in this case that all groups might actually have a more negative attitude towards smoking after seeing the text or visual message no matter whether they were externally and internally (ideally we would of course use a pre-post test design but lets keep that for later).
Thus, we could for example assume that (having no better data on this) people are on average indifferent about smoking, therefore assuming the population mean is 50.
Now lets see what this would imply in terms of change scores for the numbers above:</p>
<pre class="r"><code>change_TI &lt;- mean_TI-50
change_VI &lt;- mean_VI-50
change_TE &lt;- mean_TE-50
change_VE &lt;- mean_VE-50

barplot(c(change_TI, change_VI, change_TE, change_VE), names.arg = c(&quot;TI&quot;, &quot;VI&quot;, &quot;TE&quot;, &quot;VE&quot;))</code></pre>
<p><img src="/post/2020-06-16-power-analysis-by-data-simulation-in-r-part-iii_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Thus, this does not seem entirely plausible.
The VE group increases in their attitude towards cigarettes compared to the assumed population mean and the TI group does not change at all.
This is not what we would expect.
However, as we want to keep the rank-order of the bars the same (i.e. order of difference-magnitudes between the groups should stay the same as above) we will start with the highest bar here and adjust it to a position where it would actually make sense compared to the population mean.
Lets assume that the looking at these external pictures would actually decrease the population mean of smoking attitude by 3 points on average.
This is just a consequence of that I think an intervention of this would be rather weak as most people do not see these pictures for the first time and also might not be influences so much by looking at them to begin with.
Thus my mean of group_VE becomes 47.</p>
<p>Next, when looking at the TI group, I think hat this group might decrease more strongly compared to the other group (it is internal), so the new mean after reading texts about yourself might be 45 in this case.</p>
<p>The next group is the TE group which should be lower than the other two groups before. However given that it is also an external group, and I expect internal messages to work better, it is probably not much stronger than the TI group, so I will assume the mean is 43.</p>
<p>Last, the strongest of the changes I would probably expect for the VI group so I can assume that the change might be 10 points in this case so that their mean will become 40.</p>
<p>Let us plot these new means again.</p>
<pre class="r"><code>focus &lt;- rep(c(&quot;internal&quot;, &quot;external&quot;), each = 2)
media &lt;- rep(c(&quot;text&quot;, &quot;visual&quot;), times = 2)
mean_TI &lt;- 43
mean_VI &lt;- 40
mean_TE &lt;- 45
mean_VE &lt;- 47

pd &lt;- data.frame(score = c(mean_TI, mean_VI, mean_TE, mean_VE), focus = focus, media = media)

interaction.plot(pd$focus, pd$media, pd$score, ylim = c(0,100))</code></pre>
<p><img src="/post/2020-06-16-power-analysis-by-data-simulation-in-r-part-iii_files/figure-html/plot_exp2-1.png" width="672" /></p>
<pre class="r"><code>mean(pd$score[pd$focus == &quot;internal&quot;]) != mean(pd$score[pd$focus == &quot;external&quot;])</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>mean(pd$score[pd$media == &quot;text&quot;]) == mean(pd$score[pd$media == &quot;visual&quot;])</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Note that in this new example, technically there is a difference between the two media groups on average but it is only .50 points, so I would argue that it is small enough to represent our assumption of “no” effect, as in real-life “no” effect in terms of a difference being actually 0 is rather rare anyway.</p>
<p>Ok, so after rule-of-thumbing our way through all the different group-means, we have to consider what standard deviation we find plausible in this situation.</p>
<p>It is plausible, that the intervention that we are administering might not directly influence the spread in each group, so we might as well assume that the spread is the same in each group.
What should we choose in this case?
Let us think about the population.
We said that people would in average be indifferent about smoking with a mean of 50 on a 100-point scale.
How big should the spread on this scale be, i.e. between which values do we assume most people to be on this scale.
It is probably likely that most people will not have a very good attitude about smoking, say 80 or higher.
The lower end is more difficult to predict in this case, there might as well be more people that have a very negative opinion.
In fact, the distribution might be skewed rather than symmetric, with more people having very negative opinions and a rather long tail.
In any case, we will use this upper-limit assumption to come up with some reasonable standard-deviation.
If we start at 50 and we want most people to be &lt; 80, we can set the 2-SD bound at 80 to get a standard-deviation of 15 (80-50)/2.
Thus let us assume that each of our groups has a standard-deviation of 15 points.</p>
<p>Thus our distributions that we would have are</p>
<pre><code>group_TI = normal(n, 43, 15)
group_VI = normal(n, 40, 15)
group_TE = normal(n, 45, 15)
group_VE = normal(n, 47, 15)</code></pre>
<p>With these groups we can now run an ANOVA.
Before getting into the power-analysis part lets just have a look what would happen if we had 10,000 people per group and would use this in our ANOVA.
First we will do this by using the <code>aov_car</code> function from the <code>afex</code> package.</p>
<pre><code>## Loading required package: afex</code></pre>
<pre><code>## Loading required package: lme4</code></pre>
<pre><code>## Loading required package: Matrix</code></pre>
<pre><code>## Registered S3 methods overwritten by &#39;car&#39;:
##   method                          from
##   influence.merMod                lme4
##   cooks.distance.influence.merMod lme4
##   dfbeta.influence.merMod         lme4
##   dfbetas.influence.merMod        lme4</code></pre>
<pre><code>## ************
## Welcome to afex. For support visit: http://afex.singmann.science/</code></pre>
<pre><code>## - Functions for ANOVAs: aov_car(), aov_ez(), and aov_4()
## - Methods for calculating p-values with mixed(): &#39;KR&#39;, &#39;S&#39;, &#39;LRT&#39;, and &#39;PB&#39;
## - &#39;afex_aov&#39; and &#39;mixed&#39; objects can be passed to emmeans() for follow-up tests
## - NEWS: library(&#39;emmeans&#39;) now needs to be called explicitly!
## - Get and set global package options with: afex_options()
## - Set orthogonal sum-to-zero contrasts globally: set_sum_contrasts()
## - For example analyses see: browseVignettes(&quot;afex&quot;)
## ************</code></pre>
<pre><code>## 
## Attaching package: &#39;afex&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:lme4&#39;:
## 
##     lmer</code></pre>
<pre class="r"><code>require(afex)</code></pre>
<pre class="r"><code>n &lt;- 1e5
group_TI &lt;-  rnorm(n, 43, 15)
group_VI &lt;-  rnorm(n, 40, 15)
group_TE &lt;-  rnorm(n, 45, 15)
group_VE &lt;-  rnorm(n, 47, 15)

participant &lt;- c(1:(n*4))
focus &lt;- rep(c(&quot;internal&quot;, &quot;external&quot;), each = n*2)
media &lt;- rep(c(&quot;text&quot;, &quot;visual&quot;), each = n, times = 2)

aov_dat &lt;- data.frame(participant = participant, focus = focus, media = media, score = c(group_TI, group_VI, group_TE, group_VE))


aov_car(score ~ focus*media+ Error(participant), data = aov_dat, type = 3)</code></pre>
<pre><code>## Contrasts set to contr.sum for the following variables: focus, media</code></pre>
<pre><code>## Anova Table (Type 3 tests)
## 
## Response: score
##        Effect        df    MSE           F   ges p.value
## 1       focus 1, 399996 225.28 8811.28 ***   .02  &lt;.0001
## 2       media 1, 399996 225.28  126.75 *** .0003  &lt;.0001
## 3 focus:media 1, 399996 225.28 2703.27 ***  .007  &lt;.0001
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;+&#39; 0.1 &#39; &#39; 1</code></pre>
<p>We see that, if we collect 10,000 people per group, everything would be significant with focus having the biggest effect (look at the <code>ges</code> column in the table for generalized eta-squared values) and with media having the smallest effect (in fact close to 0 as we wanted).
That even the main-effect for media is still significant just shows that this happens even with very small deviations from the exact null-hypothesis in these huge samples.</p>
<p>Note that again we could rewrite this anova as a dummy-coded linear model as:</p>
<p><span class="math display">\[
score_i = \beta_0 + \beta_1X_1 + \beta_2X_2 + \beta_3X_1X_2 
\]</span></p>
<p>By making dummy-variables we can code this in <code>lm</code></p>
<pre class="r"><code>aov_dat$focus_dummy &lt;- ifelse(aov_dat$focus == &quot;internal&quot;, 0 , 1)
aov_dat$media_dummy &lt;- ifelse(aov_dat$media == &quot;text&quot;, 0 , 1)

lm_int &lt;- lm(score ~ 1 + focus_dummy + media_dummy + focus_dummy:media_dummy, data = aov_dat)</code></pre>
<p>From the estimates that we get here we see how the model is estimated:</p>
<p><span class="math inline">\(\beta_0\)</span> = <code>mean(group_TI)</code> as both dummies are 0 for this one.
<span class="math inline">\(\beta_1\)</span> = <code>mean(group_TE)-mean(group_TI)</code> as the focus variable changes from 0 to 1 within the text-group
<span class="math inline">\(\beta_2\)</span> = <code>mean(group_VI)-mean(group_TI)</code> as the media variable changes from 0 to 1 within the internal focus group
<span class="math inline">\(\beta_3\)</span> = <code>mean(group_VE)-mean(group_TE)+mean(group_TI)-mean(group_VI)</code> to see what a crossover of the variables (i.e. the interaction) compares to <span class="math inline">\(\beta_0\)</span></p>
<p>If we want to test whether the effect of the interaction, for instance is significant, we can conduct an ANOVA for the interaction to see how the model <em>with</em> the interaction compares to a model <em>without</em> the interaction, which we do in the following code-block by fitting a model that does not have the interaction in their and compare it with the <code>anova</code> function.</p>
<pre class="r"><code>lm_null &lt;- lm(score ~ 1 + focus_dummy + media_dummy, data = aov_dat)
anova(lm_null, lm_int)</code></pre>
<pre><code>## Analysis of Variance Table
## 
## Model 1: score ~ 1 + focus_dummy + media_dummy
## Model 2: score ~ 1 + focus_dummy + media_dummy + focus_dummy:media_dummy
##   Res.Df      RSS Df Sum of Sq      F    Pr(&gt;F)    
## 1 399997 90721027                                  
## 2 399996 90112027  1    609000 2703.3 &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Again, we find the same F-value and p-value as before, which should not be surprising considering we did the same test.
I will leave it to you which of the two methods, i.e. using the regular <code>aov</code> functions or specifying linear models, you prefer.
An obvious advantage of the <code>aov</code> function is that we do not have to specify nested models but it is also sort of a black-box approach, while in the linear models, we get estimated effects and can see whether the model does actually behaves as we would expect.</p>
</div>
<div id="quick-detour-contrast-coding-and-centering" class="section level3">
<h3>Quick detour: Contrast Coding and Centering</h3>
<p>Going back to the <code>aov_car</code> output above, you might have noticed that the function informed us that it <em>set [contrasts] to contr.sum for the following variables: focus, media</em>.
What does this mean?
It means that instead of using dummy-coding as we did when we created the dummy variables, it instead assigned a -1 to a level of the variable while setting a 1 to the other level.
We can check what this looks like if we set it manually to the variables in the data-set.</p>
<pre class="r"><code>aov_dat$media_sum &lt;- factor(aov_dat$media)
contrasts(aov_dat$media_sum) &lt;- contr.sum(2)
contrasts(aov_dat$media_sum)</code></pre>
<pre><code>##        [,1]
## text      1
## visual   -1</code></pre>
<pre class="r"><code>aov_dat$focus_sum &lt;- factor(aov_dat$focus)
contrasts(aov_dat$focus_sum) &lt;- contr.sum(2)
contrasts(aov_dat$focus_sum)</code></pre>
<pre><code>##          [,1]
## external    1
## internal   -1</code></pre>
<p>If we compare this to our dummy variables:</p>
<p>media:</p>
<ul>
<li>text = 0</li>
<li>visual = 1</li>
</ul>
<p>focus:</p>
<ul>
<li>internal = 0</li>
<li>external = 1</li>
</ul>
<p>Let’s re-run the linear model with these variables and see what we get.</p>
<pre class="r"><code>aov_dat$media_sum_num &lt;- ifelse(aov_dat$media == &quot;text&quot;, 1, -1)
aov_dat$focus_sum_num &lt;- ifelse(aov_dat$focus == &quot;external&quot;, 1, -1)

lm_int_sum &lt;- lm(score ~ 1 + focus_sum_num + media_sum_num + focus_sum_num:media_sum_num, data = aov_dat)
lm_int_sum</code></pre>
<pre><code>## 
## Call:
## lm(formula = score ~ 1 + focus_sum_num + media_sum_num + focus_sum_num:media_sum_num, 
##     data = aov_dat)
## 
## Coefficients:
##                 (Intercept)                focus_sum_num  
##                     43.7756                       2.2277  
##               media_sum_num  focus_sum_num:media_sum_num  
##                      0.2672                      -1.2339</code></pre>
<pre class="r"><code>lm_null_sum &lt;- lm(score ~ 1 + focus_sum_num + media_sum_num, data = aov_dat)
lm_null_sum</code></pre>
<pre><code>## 
## Call:
## lm(formula = score ~ 1 + focus_sum_num + media_sum_num, data = aov_dat)
## 
## Coefficients:
##   (Intercept)  focus_sum_num  media_sum_num  
##       43.7756         2.2277         0.2672</code></pre>
<pre class="r"><code>anova(lm_null_sum,lm_int_sum)</code></pre>
<pre><code>## Analysis of Variance Table
## 
## Model 1: score ~ 1 + focus_sum_num + media_sum_num
## Model 2: score ~ 1 + focus_sum_num + media_sum_num + focus_sum_num:media_sum_num
##   Res.Df      RSS Df Sum of Sq      F    Pr(&gt;F)    
## 1 399997 90721027                                  
## 2 399996 90112027  1    609000 2703.3 &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>We see immediately that the estimates changed somewhat.
Now, for example the intercept represents the mean of all 4 other means (i.e. the grand mean):</p>
<p><code>mean(c(mean(group_TI), mean(group_TE), mean(group_VE), mean(group_VI)))</code> = 43.775609.</p>
<p>and the first estimate represents the difference of each focus level from that grand-mean, for the “internal groups this is”</p>
<p><code>mean(c(mean(group_TI), mean(group_VI)))-mean(c(mean(group_TI), mean(group_TE), mean(group_VE), mean(group_VI)))</code> = -2.2276811</p>
<p>and for the external groups this is</p>
<p><code>mean(c(mean(group_TE), mean(group_VE)))-mean(c(mean(group_TI), mean(group_TE), mean(group_VE), mean(group_VI)))</code> = 2.2276811</p>
<p>respectively.</p>
<p>Why would we use this coding-scheme in the linear model instead of the other one?
The p-value for the interaction is exactly the same in both cases.
However, if we compare the p-values of main-effects here, we will see how they differ.</p>
<p>For instance, if we tell <code>aov_car</code> that we want to keep our dummy-coding instead of changing it, we can see how the two outputs differ.</p>
<pre class="r"><code>aov_car(score ~ focus*media+ Error(participant), data = aov_dat, type = 3, afex_options(&quot;check_contrasts&quot; = FALSE))</code></pre>
<pre><code>## Anova Table (Type 3 tests)
## 
## Response: score
##        Effect        df    MSE           F  ges p.value
## 1       focus 1, 399996 225.28  876.77 *** .002  &lt;.0001
## 2       media 1, 399996 225.28  829.66 *** .002  &lt;.0001
## 3 focus:media 1, 399996 225.28 2703.27 *** .007  &lt;.0001
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;+&#39; 0.1 &#39; &#39; 1</code></pre>
<p>As you can see, these results are a bit weird, as we seem to have the same effect-size for both main-effects, but did we not simulate a much bigger effect of focus compared to media<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>?
Something seems to be off here.
This has to do with the fact that in classical dummy-coding (also called treatment coding) you cannot easily test main-effects when interactions are present in the model.
For the interaction on the other hand it does not matter.
You can read more about this in <a href="http://talklab.psy.gla.ac.uk/tvw/catpred/#why-does-it-matter">this blog post by Dale Barr</a> but the take-home message here is that, whenever we have an interaction in our model, we want to use sum-to-zero coding rather than dummy-coding.
This is why the results of the last anova do not show the behavior that we simulated.</p>
<p>Thus, for the rest of the tutorial we will use sum-to-zero contrasts coding.</p>
</div>
<div id="running-the-power-analysis" class="section level3">
<h3>Running the power-analysis</h3>
<p>I will use the <code>lm</code> way here as it is much faster (about 8 times faster in a quick test) than the <code>aov_car</code> method.
To track our power, we can directly extract p-values from the <code>anova</code> object, just as we did for the <code>t.test</code> objects earlier.</p>
<p>The only thing that we still need to do is specify our test criteria.
Imagine that this time we are hired by the government and are asked to evaluate which of the health-warnings on cigarette packages would work best in which of the situations that we investigate.
They gave us a lot of money to do this, but they do not want to draw any conclusions that are unwarranted as implementing new laws costs a lot of money.
Thus, we want to set our alpha-level quite conservatively at <span class="math inline">\(\alpha = .001\)</span> to only make a non-warranted claim about the interaction effect in 1 of every 1,000 experiments.
Moreover, we also want to be sure that we actually detect an effect and therefore want to keep our power high at 95% to be sure that if there <em>is</em> an interaction we would detect it in 19 out of 20 cases.</p>
<p>Now we have everything that we need to set up the code-chunk below to run a power-analysis similar to the ones we have been running previously, just this time with an ANOVA coded as a linear model.
If we would again try out every sample-size, this would take a very long time until we reach our power criterion and we would probably still be sitting here tomorrow or the day after.
In these cases, it makes sense to run a two-stage power analysis in which we, in the first stage, try out various sample-sizes with a very low resolution (e.g. n = 10, n = 100, n = 200) etc. to get a rough idea of where we can expect our loop to end.
Afterwards, we will increase the resolution to find how many participants exactly we would need.
The first step with the low resolution is performed below.</p>
<pre class="r"><code>set.seed(1)
n_sims &lt;- 1000 # we want 1000 simulations
p_vals &lt;- c()
power_at_n &lt;- c(0) # this vector will contain the power for each sample-size (it needs the initial 0 for the while-loop to work)
n &lt;- 100 # sample-size and start at 100 as we can be pretty sure this will not suffice for such a small effect
n_increase &lt;- 100 # by which stepsize should n be increased
i &lt;- 2

power_crit &lt;- .95
alpha &lt;- .001

while(power_at_n[i-1] &lt; power_crit){
  for(sim in 1:n_sims){
    group_TI &lt;-  rnorm(n, 43, 15)
    group_VI &lt;-  rnorm(n, 40, 15)
    group_TE &lt;-  rnorm(n, 45, 15)
    group_VE &lt;-  rnorm(n, 47, 15)
    
    participant &lt;- c(1:(n*4))
    focus &lt;- rep(c(&quot;internal&quot;, &quot;external&quot;), each = n*2)
    media &lt;- rep(c(&quot;text&quot;, &quot;visual&quot;), each = n, times = 2)
    
    aov_dat &lt;- data.frame(participant = participant, focus = focus, media = media, score = c(group_TI, group_VI, group_TE, group_VE))
    aov_dat$media_sum_num &lt;- ifelse(aov_dat$media == &quot;text&quot;, 1, -1) # apply sum-to-zero coding
    aov_dat$focus_sum_num &lt;- ifelse(aov_dat$focus == &quot;external&quot;, 1, -1) 
    lm_int &lt;- lm(score ~ 1 + focus_sum_num + media_sum_num + focus_sum_num:media_sum_num, data = aov_dat) # fit the model with the interaction
    lm_null &lt;- lm(score ~ 1 + focus_sum_num + media_sum_num, data = aov_dat) # fit the model without the interaction
    p_vals[sim] &lt;- anova(lm_int, lm_null)$`Pr(&gt;F)`[2] # put the p-values in a list
  }
    print(n)
    power_at_n[i] &lt;- mean(p_vals &lt; alpha) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)
    names(power_at_n)[i] &lt;- n
    n &lt;- n+n_increase # increase sample-size by 100 for low-resolution testing first
    i &lt;- i+1 # increase index of the while-loop by 1 to save power and cohens d to vector
}</code></pre>
<pre><code>## [1] 100
## [1] 200
## [1] 300
## [1] 400
## [1] 500
## [1] 600
## [1] 700
## [1] 800
## [1] 900</code></pre>
<pre class="r"><code>power_at_n &lt;- power_at_n[-1] # delete first 0 from the vector</code></pre>
<pre class="r"><code>plot(as.numeric(names(power_at_n)), power_at_n, xlab = &quot;Number of participants per group&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = TRUE)
abline(h = .95, col = &quot;red&quot;)</code></pre>
<p><img src="/post/2020-06-16-power-analysis-by-data-simulation-in-r-part-iii_files/figure-html/plot_power_low_res-1.png" width="672" /></p>
<p>We see that at roughly 900 participants our loop ran into a situation where we have sufficient power.
Thank god we did not do this 1-by-1.
Now we can have a closer look at sample-sizes between 800 and 900.
Probably, at this sample-size it does not really matter whether we calculate +/- 10 participants in terms of budget, so we can start at 800 and increase in steps of 10 and instead increase the simulation-number per sample-size to 10,000 to get even more precise results for each particular sample-size, as this is a rather important power-analysis impact-wise.
Afterwards, if we <em>really</em> wanted to we could of course run a third round between the last two 10-people cutoffs and increase the sample-size by 1 to reach an exact sample-size.</p>
<pre class="r"><code>set.seed(1)
n_sims &lt;- 10000 # we want 10000 simulations
p_vals &lt;- c()
power_at_n &lt;- c(0) # this vector will contain the power for each sample-size (it needs the initial 0 for the while-loop to work)
delta_r2s&lt;- c()
delta_r2s_at_n &lt;- c(0)
n &lt;- 800 # sample-size and start at 800 as we can be pretty sure this will not suffice for such a small effect
n_increase &lt;- 10 # by which stepsize should n be increased
i &lt;- 2

power_crit &lt;- .95
alpha &lt;- .001

while(power_at_n[i-1] &lt; power_crit){
  for(sim in 1:n_sims){
    group_TI &lt;-  rnorm(n, 43, 15)
    group_VI &lt;-  rnorm(n, 40, 15)
    group_TE &lt;-  rnorm(n, 45, 15)
    group_VE &lt;-  rnorm(n, 47, 15)
    
    participant &lt;- c(1:(n*4))
    focus &lt;- rep(c(&quot;internal&quot;, &quot;external&quot;), each = n*2)
    media &lt;- rep(c(&quot;text&quot;, &quot;visual&quot;), each = n, times = 2)
    
    aov_dat &lt;- data.frame(participant = participant, focus = focus, media = media, score = c(group_TI, group_VI, group_TE, group_VE))
    aov_dat$media_sum_num &lt;- ifelse(aov_dat$media == &quot;text&quot;, 1, -1)
    aov_dat$focus_sum_num &lt;- ifelse(aov_dat$focus == &quot;external&quot;, 1, -1)
    lm_int &lt;- lm(score ~ 1 + focus_sum_num + media_sum_num + focus_sum_num:media_sum_num, data = aov_dat)
    lm_null &lt;- lm(score ~ 1 + focus_sum_num + media_sum_num, data = aov_dat)
    p_vals[sim] &lt;- anova(lm_null, lm_int)$`Pr(&gt;F)`[2]
    delta_r2s[sim]&lt;- summary(lm_int)$adj.r.squared-summary(lm_null)$adj.r.squared
    }
    print(n)
    power_at_n[i] &lt;- mean(p_vals &lt; alpha) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)
    delta_r2s_at_n[i] &lt;- mean(delta_r2s)
    names(power_at_n)[i] &lt;- n
    names(delta_r2s_at_n)[i] &lt;- n
    n &lt;- n+n_increase # increase sample-size by 100 for low-resolution testing first
    i &lt;- i+1 # increase index of the while-loop by 1 to save power and cohens d to vector
}</code></pre>
<pre><code>## [1] 800
## [1] 810
## [1] 820
## [1] 830
## [1] 840
## [1] 850
## [1] 860
## [1] 870
## [1] 880
## [1] 890</code></pre>
<pre class="r"><code>power_at_n &lt;- power_at_n[-1] # delete first 0 from the vector
delta_r2s_at_n &lt;- delta_r2s_at_n[-1] # delete first 0 from the vector</code></pre>
<p>As you will notice when you run this yourself, this simulation already takes quite some time.
Later, when we work with mixed models in part IV, we will see how we can run such a simulation on multiple processor-cores simultaneously to solve this problem to at least some extent.</p>
<pre class="r"><code>plot(as.numeric(names(power_at_n)), power_at_n, xlab = &quot;Number of participants per group&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = TRUE)
abline(h = .95, col = &quot;red&quot;)</code></pre>
<p><img src="/post/2020-06-16-power-analysis-by-data-simulation-in-r-part-iii_files/figure-html/plot_power-1.png" width="672" /></p>
<p>This power-curve looks a bit odd, as it looks almost flat.
What this shows however, is that power is not increasing linearly but tends to increase faster at the beginning and slower towards reaching 1.</p>
<p>In any case, 890 people <em>per group</em> would be enough to reach our desired power of .95.
Note how close this is to the 900 from our low-resolution simulation above, showing the merits of this approach.
Also note that the change in amount of variance explained <span class="math inline">\(\Delta R^2\)</span> only increases by about <code>delta_r2s_at_n[length(delta_r2s_at_n)]</code> = 0.0067977.
Whether this ~0.6% is a meaningful amount of added variance explained to begin with and whether it is worth spending money in order to test about 3,500 people without even knowing what this attitude measure in this case even tells us in terms of smoking-behavior is a whole other question and cannot be answered with power-analysis (probably the answer would be that it is not so important though).</p>
</div>
</div>
<div id="adding-a-numeric-predictor" class="section level2">
<h2>Adding a Numeric Predictor</h2>
<p>In this last bit of part III of this tutorial I want to demonstrate how we can add numeric predictors to our models as, so far, we only worked with factors.
Again, knowing how to re-specify an ANOVA as a linear model is helpful in this case if we have both, factorial and numerical predictors.</p>
<p>We could also assume that the effect that our predictors have depend on other factors.
For example, we could think that the more cigarettes a person smokes each day, the less effective any treatment would be independent of what strategy we would use.
Thus, if we assume that the aforementioned effect-sizes would be the expected value for a non-smoking population, including smokers would make this effect less pronounced.
In other words, the more a person smokes, the smaller the expected effect size for that person should be.</p>
<p>How do we do this?
If we reformulate our problem above we could say that if a person smokes 0 cigarettes a day she should get 100% of the expected effect (e.g. the decrease of 7 points in the internal text-group).
Now, we can take the maximum amount of cigarettes that we think a person can smoke per day (or what we expect the 95% CI to be in a smoking population for instance).
Let us say we assume this to be 36 cigarettes a day (about 2 packages).
Now if we want a person that smokes 0 cigarettes to get the full 7 points and a person who smokes 36 cigarettes to get 0 percent of the effect, we can rewrite the effect like this</p>
<p><span class="math display">\[y{_i} =  \bar y \times \frac{max_{n}-n}{max_n}\]</span></p>
<p>or if we fill in the numbers for a non-smoker:</p>
<p><span class="math display">\[y{_i} = 7 \times \frac{36-0}{36} = 7\]</span></p>
<p>and someone who smokes 14 cigarettes a day:</p>
<p><span class="math display">\[y{_i} = 7 \times \frac{36-14}{36} = 5.64\]</span></p>
<p>Thus, our effect of 7 points now depends on how much someone smokes.</p>
<p>Now we have to come up with an assumption of how much people smoke in the population.
A quick <a href="https://www.trimbos.nl/docs/9a7f5384-36fa-4edc-815f-1d0388960f46.pdf">google search</a> can tell us that, in the Netherlands, 23.1% of adults smoke.
We can also find that people who smoke consume ca. 11 cigarettes on average.
Thus, we will make a population in which 76.9 percent of the people do not smoke and 23.1 percent smokes 11 cigarettes on average.
For the cigarette count in the smoking population we will choose a <em>Poisson</em> distribution, as it is often a good representation of count-data like this.</p>
<div class="notebox">
<p>
You might never have heard of a Poisson distribution and to avoid confusion here: We could just use a uniform distribution between 1 and 36 for example so that smoking 30 cigarettes a day is just as likely as smoking 1 cigarette, given that a person is a smoker.
However, I do not think that this is the case and that the likelihood of a smoker smoking 30 cigarettes is smaller compared to only smoking 5 cigarettes.
The Poisson distribution mainly carries this assumption forward into the simulation.
As you continue simulating stuff in the future, you will probably get to know more of these useful distributions that neatly describe certain assumptions that we have about the data.
</p>
</div>
<p>To create a population like this we can do the following:</p>
<pre class="r"><code>n &lt;- 1000# sample size

smoke_yes_no &lt;- ifelse(runif(n, 0, 100) &lt; 77, 0, 1) # vector telling us whether each &quot;person&quot; smokes or not

n_smoke &lt;- c() # vector that will contain number of cigarettes per day smoked by each person

# create the number of smoked cigarettes
for(i in 1:length(smoke_yes_no)){ 
  if(smoke_yes_no[i] == 1){
    n_smoke[i] &lt;- rpois(1,11) # simulate 1 cigarette count from a poisson distribution with mean 11
  } else{ 
    n_smoke[i] &lt;- 0}
}</code></pre>
<p>In the above code we check for each person whether they are a smoker or not and if so, say that the person’s number of cigarettes smoked comes from a Poisson distribution or otherwise it will be 0 by definition.</p>
<p>To implement this for each group, we can just replace the means of the groups by this formula:</p>
<pre class="r"><code>set.seed(1234)
group_TI &lt;-  rnorm(n, (50-(7*((max(n_smoke)-n_smoke)/max(n_smoke)))), 15)
group_VI &lt;-  rnorm(n, (50-(10*((max(n_smoke)-n_smoke)/max(n_smoke)))), 15)
group_TE &lt;-  rnorm(n, (50-(5*((max(n_smoke)-n_smoke)/max(n_smoke)))), 15)
group_VE &lt;-  rnorm(n, (50-(3*((max(n_smoke)-n_smoke)/max(n_smoke)))), 15)

participant &lt;- c(1:(n*4))
focus &lt;- rep(c(&quot;internal&quot;, &quot;external&quot;), each = n*2)
media &lt;- rep(c(&quot;text&quot;, &quot;visual&quot;), each = n, times = 2)

aov_dat &lt;- data.frame(participant = participant, focus = focus, media = media, score = c(group_TI, group_VI, group_TE, group_VE))

aov_dat$media_sum_num &lt;- ifelse(aov_dat$media == &quot;text&quot;, 1, -1)
aov_dat$focus_sum_num &lt;- ifelse(aov_dat$focus == &quot;external&quot;, 1, -1)
aov_dat$n_smoke &lt;- rep(scale(n_smoke))

lm_int &lt;- lm(score ~ 1 + focus_sum_num * media_sum_num * n_smoke, data = aov_dat)
summary(lm_int)</code></pre>
<pre><code>## 
## Call:
## lm(formula = score ~ 1 + focus_sum_num * media_sum_num * n_smoke, 
##     data = aov_dat)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -50.287 -10.129   0.189   9.930  48.593 
## 
## Coefficients:
##                                     Estimate Std. Error t value
## (Intercept)                         44.44569    0.23621 188.160
## focus_sum_num                        2.12720    0.23621   9.005
## media_sum_num                        0.21372    0.23621   0.905
## n_smoke                              1.77929    0.23633   7.529
## focus_sum_num:media_sum_num         -0.81755    0.23621  -3.461
## focus_sum_num:n_smoke               -0.27972    0.23633  -1.184
## media_sum_num:n_smoke               -0.10452    0.23633  -0.442
## focus_sum_num:media_sum_num:n_smoke  0.06719    0.23633   0.284
##                                               Pr(&gt;|t|)    
## (Intercept)                                    &lt; 2e-16 ***
## focus_sum_num                                  &lt; 2e-16 ***
## media_sum_num                                 0.365634    
## n_smoke                             0.0000000000000629 ***
## focus_sum_num:media_sum_num                   0.000544 ***
## focus_sum_num:n_smoke                         0.236651    
## media_sum_num:n_smoke                         0.658334    
## focus_sum_num:media_sum_num:n_smoke           0.776180    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 14.94 on 3992 degrees of freedom
## Multiple R-squared:  0.03674,    Adjusted R-squared:  0.03505 
## F-statistic: 21.75 on 7 and 3992 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Note how the effects that we put in before are still there but they are weaker now as we have smokers included in our sample.
Moreover, smoking causes a more positive attitude towards smoking, just as we wanted, and the interaction between media and focus is not influenced by whether someone smokes or not, as we put the same punishment for the treatment effect in all the groups, leaving the interaction uninfluenced by whether someone smokes or not.</p>
</div>
<div id="summary" class="section level2">
<h2>Summary</h2>
<p>So now we have seen how we can simulate data for analyses that many people use in their everyday life as a (psychological) researcher.
So far, all of the power-analyses that we did can also be done in standard software like G*Power (though in part I of this tutorial I explained why I still prefer simulation).
However, as nice as these analyses are, we often deal with more complicated situations where we have to deal with hierarchical or cross-classified data.
In these cases, other approaches like linear-mixed effects models, also called hierarchical models, need to be used to analyse our data.
This is where simulation really shines as the structure of the data strongly depends on the research design and in a point-and-click software (though existing) it is difficult to offer all the flexibility that we might need.
Thus, in the fourth part, we will see how we can simulate data and run a power-analysis in these cases.</p>
</div>
</div>
<div id="footnotes" class="section level1">
<h1>Footnotes</h1>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>We can actually see that this is the case by calculating cohens d for both assuming that we would perform a t-test for each of the 2 factors with the between-subject cohens d formula from part II of this tutorial:
<strong>focus</strong>:
<code>(mean(aov_dat$score[aov_dat$focus == "internal"])-mean(aov_dat$score[aov_dat$focus == "external"]))/sqrt((sd(aov_dat$score[aov_dat$focus == "internal"])^2+sd(aov_dat$score[aov_dat$focus == "external"])^2)/2)</code> = -0.2824849
<strong>media</strong>:
<code>(mean(aov_dat$score[aov_dat$media == "text"])-mean(aov_dat$score[aov_dat$media == "visual"]))/sqrt((sd(aov_dat$score[aov_dat$media == "text"])^2+sd(aov_dat$score[aov_dat$media == "visual"])^2)/2)</code> = 0.0281052<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
]]>
      </description>
    </item>
    
    <item>
      <title>Power Analysis by Data Simulation in R - Part II</title>
      <link>/post/power-analysis-by-data-simulation-in-r-part-ii/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      <guid>/post/power-analysis-by-data-simulation-in-r-part-ii/</guid>
      <description><![CDATA[
        
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#the-power-analysis-by-simulation-in-r-for-really-any-design---part-ii">The Power Analysis by simulation in <code>R</code> for really any design - Part II</a>
<ul>
<li><a href="#simulating-a-between-subjects-t-test">Simulating a between-subjects t-test</a></li>
<li><a href="#simulating-a-within-subject-t-test">Simulating a within-subject t-test</a>
<ul>
<li><a href="#using-a-one-sample-t-test-approach">Using a one-sample t-test approach</a></li>
<li><a href="#using-a-correlated-samples-paired-t-test-approach">Using a correlated-samples paired t-test approach</a></li>
</ul></li>
<li><a href="#summary-our-first-simulations-with-t-tests">Summary: Our first simulations with t-tests</a></li>
</ul></li>
<li><a href="#footnotes">Footnotes</a></li>
</ul>
</div>

<html>
<link rel="stylesheet" href="/css/style.css" />
</html>
<p><div class="alert alert-note">
  <div>
    <!-- raw HTML omitted -->Click below to download the .Rmd file<!-- raw HTML omitted -->
  </div>
</div>
</p>
<a href="data:text/x-markdown;base64,LS0tDQp0aXRsZTogUG93ZXIgQW5hbHlzaXMgYnkgRGF0YSBTaW11bGF0aW9uIGluIFIgLSBQYXJ0IElJDQphdXRob3I6IH4NCmRhdGU6ICcyMDIwLTA1LTEyJw0Kc2x1ZzogcG93ZXItYW5hbHlzaXMtYnktZGF0YS1zaW11bGF0aW9uLWluLXItcGFydC1paQ0KY2F0ZWdvcmllczogW1Bvd2VyIEFuYWx5c2lzXQ0KdGFnczogW3Bvd2VyLCBkYXRhLXNpbXVsYXRpb25dDQpzdWJ0aXRsZTogJ1BhcnQgSUkgLSBzaW11bGF0aW5nIGdyb3VwcyBhbmQgcG93ZXJpbmcgdC10ZXN0cycNCnN1bW1hcnk6ICdUaGlzIHBhcnQgZm91Y3VzZXMgb24gc2ltcGxlIHNjZW5hcmlvcyAodC10ZXN0cykgdG8gaW50cm9kdWNlIHRoZSBzaW11bGF0aW9uIG9mIGNvcnJlbGF0ZWQgbWVhc3VyZW1lbnRzIGFuZCBtdWx0aXZhcmlhdGUgbm9ybWFsLWRpc3RyaWJ1dGlvbnMnDQphdXRob3JzOiBbXQ0KbGFzdG1vZDogImByIGZvcm1hdChTeXMudGltZSgpKWAiDQpmZWF0dXJlZDogbm8NCmNvZGVfZG93bmxvYWQ6IHRydWUNCmltYWdlOg0KICBjYXB0aW9uOiAnJw0KICBmb2NhbF9wb2ludDogJycNCiAgcHJldmlld19vbmx5OiBubw0KcHJvamVjdHM6IFtQb3dlciBBbmFseXNpcyBUdXRvcmlhbF0NCm91dHB1dDoNCiAgYmxvZ2Rvd246Omh0bWxfcGFnZToNCiAgICB0b2M6IHRydWUNCiAgICB0b2NfZGVwdGg6IDENCi0tLQ0KDQo8aHRtbD4NCiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Ii9jc3Mvc3R5bGUuY3NzIiAvPg0KPC9odG1sPg0KDQoNCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQ0KcmVxdWlyZShrbml0cikNCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVCwgd2FybmluZyA9IEYsIGNhY2hlID0gVCkNCm9wdGlvbnMod2lkdGggPSA4MCkNCm9wdGlvbnMoc2NpcGVuID0gMTApDQojc291cmNlKCJjb21tb25fcGFja2FnZXMuUiIpDQpkZXZBc2tOZXdQYWdlKGFzayA9IEZBTFNFKQ0KYGBgDQoNCnt7JSBhbGVydCBub3RlICV9fQ0KX19DbGljayBiZWxvdyB0byBkb3dubG9hZCB0aGUgLlJtZCBmaWxlX18NCnt7JSAvYWxlcnQgJX19DQoNCmBgYHtyIGVjaG89RkFMU0V9DQp4ZnVuOjplbWJlZF9maWxlKCcuLzIwMjAtMDUtMTItcG93ZXItYW5hbHlzaXMtYnktZGF0YS1zaW11bGF0aW9uLWluLXItcGFydC1paS5SbWQnLCAicG93ZXItYW5hbHlzaXMtYnktZGF0YS1zaW11bGF0aW9uLWluLXItcGFydC1paS5SbWQiKQ0KYGBgDQoNCg0KYGBge2NzcyxlY2hvPUZBTFNFfQ0KYnV0dG9uLmJ0bi5jb2xsYXBzZWQ6YmVmb3JlDQp7DQogICAgY29udGVudDonKycgOw0KICAgIGRpc3BsYXk6YmxvY2s7DQogICAgd2lkdGg6MTVweDsNCn0NCmJ1dHRvbi5idG46YmVmb3JlDQp7DQogICAgY29udGVudDonLScgOw0KICAgIGRpc3BsYXk6YmxvY2s7DQogICAgd2lkdGg6MTVweDsNCn0NCmBgYA0KDQpgYGB7cixlY2hvPUZBTFNFLHJlc3VsdHM9J2hpZGUnfQ0Ka25pdHI6OmtuaXRfaG9va3Mkc2V0KGRyb3AxPWZ1bmN0aW9uKGJlZm9yZSwgb3B0aW9ucywgZW52aXIpIHsNCiAgICBpZiAoYmVmb3JlKSB7DQogICAgICAgIHBhc3RlKA0KICAgICAgICAgICAgJzxwPicsDQonPGJ1dHRvbiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IGNvbGxhcHNlZCIgZGF0YS10b2dnbGU9ImNvbGxhcHNlIiBkYXRhLXRhcmdldD0iI2NlMSI+JywNCic8L2J1dHRvbj4nLA0KJzwvcD4nLA0KJzxkaXYgY2xhc3M9ImNvbGxhcHNlIiBpZD0iY2UxIj4nLA0KJzxkaXYgY2xhc3M9ImNhcmQgY2FyZC1ib2R5Ij4nLCAgc2VwID0gIlxuIikNCiAgICB9IGVsc2Ugew0KICAgICAgICBwYXN0ZSgiPC9kaXY+IiwgIjwvZGl2PiIsIHNlcCA9ICJcbiIpDQogICAgfQ0KfSkNCmBgYA0KDQojIFRoZSBQb3dlciBBbmFseXNpcyBieSBzaW11bGF0aW9uIGluIGBSYCBmb3IgcmVhbGx5IGFueSBkZXNpZ24gLSBQYXJ0IElJDQoNClRoaXMgaXMgUGFydCBJSSBvZiBteSB0dXRvcmlhbCBvbiBob3cgdG8gZG8gcG93ZXItYW5hbHlzaXMgYnkgc2ltdWxhdGlvbi4NCkluIFBhcnQgSSwgd2Ugc2F3IGhvdyB0byBkbyBhIHNpbXVsYXRpb24gZm9yIGEgc2ltcGxlIHRveS1leGFtcGxlIHdpdGggYSBjb2luLXRvc3MuDQpJbiB0aGlzIHBhcnQsIHdlIHdpbGwgdXNlIGEgbW9yZSByZWFsaXN0aWMgcHJvYmxlbSB0aGF0IHdlIG1pZ2h0IGVuY291bnRlciBpbiBvdXIgZGFpbHkgcmVzZWFyY2ggbGlmZSBhbmQgc2VlIGhvdyB0byBzaW11bGF0ZSB0aGUgcG93ZXIgZm9yIHRoZXNlIGRlc2lnbnMuDQpCeSBsb29raW5nIGF0IGhvdyB0byBkbyBwb3dlci1zaW11bGF0aW9uIGZvciB0aGUgaW5kZXBlbmRlbnQtc2FtcGxlcyB0LXRlc3QgYW5kIHRoZSBwYWlyZWQgdC10ZXN0IHdlIHdpbGwgbGVhcm4gaG93IHRvIHNpbXVsYXRlIG5vcm1hbC1kaXN0cmlidXRpb25zLCBob3cgdG8gc3BlY2lmeSB0aGVpciBlZmZlY3Qtc2l6ZXMsIGluIHRlcm1zIG9mICRDb2hlbidzXCBkJC4gTW9yZW92ZXIsIHdlIHNpbXVsYXRlIGNvcnJlbGF0ZWQgKGkuZS4gbXVsdGl2YXJpYXRlKSBub3JtYWwgZGlzdHJpYnV0aW9ucyBpbiBjYXNlcyB3aGVyZSB3ZSBoYXZlIGNvcnJlbGF0ZWQgb2JzZXJ2YXRpb25zIChlLmcuIHBhaXJlZC1zYW1wbGUgdC10ZXN0KS4NClRoaXMgd2lsbCBiZSBhbiBpbXBvcnRhbnQgdG9vbCBmb3IgbGF0ZXIgcGFydHMgb2YgdGhpcyB0dXRvcmlhbC4NCg0KSW4gcGFydCBJSUkgb2YgdGhpcyB0dXRvcmlhbCB3ZSB3aWxsIGxlYXJuIGhvdyB3ZSBjYW4gY29uY2VwdHVhbGl6ZSBiYXNpY2FsbHkgX2FueV8gZGVzaWduIGFzIGEgbGluZWFyIG1vZGVsIGFuZCB0aGVyZWJ5IGJlIHZlcnkgZmxleGlibGUgaW4gb3VyIHBvd2VyIGFuYWx5c2lzLg0KSW4gcGFydCBJViB3ZSB3aWxsIGxlYXJuIGhvdyB0byBhcHBseSB0aGlzIHRlY2huaXF1ZSB0byBjb21wbGljYXRlZCBkZXNpZ25zIHN1Y2ggYXMgbGluZWFyIG1peGVkLWVmZmVjdHMgbW9kZWxzIGFuZCBnZW5lcmFsaXplZCBtaXhlZC1lZmZlY3RzIG1vZGVscy4NCg0KDQojIyBTaW11bGF0aW5nIGEgYmV0d2Vlbi1zdWJqZWN0cyB0LXRlc3QNCg0KTGV0J3MgZ2V0IHRvIGl0Lg0KVGhlIGZpcnN0IHRoaW5nIHdlIHdpbGwgbmVlZCBhZ2FpbiBpbiBvdXIgc2ltdWxhdGlvbiBpcyBvbmUgb2YgdGhlIGltcGxlbWVudGVkIHNpbXVsYXRpb24gZnVuY3Rpb25zIGluIFIgKHRob3NlIHRoYXQgbGV0IGBSYCBydW4gdGhlb3JldGljYWwgZXhwZXJpbWVudHMgZm9yIHVzKSwgYnV0IHRoaXMgdGltZSBpdCBpcyBub3QgYHJiaW5vbWAgYXMgd2UgYXJlIG5vdCB3b3JraW5nIHdpdGggY29pbi1mbGlwcyBidXQgYHJub3JtYCAtIHRoZSBzaW11bGF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgbm9ybWFsIGRpc3RyaWJ1dGlvbi4NCkxldCdzIGhhdmUgYSBzaG9ydCBsb29rIGF0IHRoYXQgZnVuY3Rpb24gYXMgd2Ugd2lsbCBrZWVwIHdvcmtpbmcgd2l0aCBpdCB0aHJvdWdob3V0IHRoZSB0dXRvcmlhbC4NCg0KYHJub3JtKG4sIG1lYW4sIHNkKWAgdGFrZXMgdGhyZWUgYXJndW1lbnRzLCBhIHNhbXBsZS1zaXplIGBuYCwgYSBgbWVhbmAgYW5kIGEgc3RhbmRhcmQtZGV2aWF0aW9uIGBzZGAuDQpCeSBzcGVjaWZ5aW5nIHRoZXNlIHZhbHVlcywgd2UgY2FuIHNhbXBsZSByYW5kb20gJ3Blb3BsZScgKG9yIG9ic2VydmF0aW9ucykgdGhhdCBhcmUgcGFydGljaXBhdGluZyBpbiBvdXIgc2ltdWxhdGVkIGV4cGVyaW1lbnRzLg0KSW1hZ2luZSwgZm9yIGV4YW1wbGUsIHRoYXQgd2UgaGF2ZSBhbiBpbnRlcnZlbnRpb24gc3R1ZHkgaW4gd2hpY2ggd2UgaGF2ZSBhIHRyZWF0bWVudCBncm91cCBhbmQgYSBjb250cm9sIGdyb3VwLg0KV2UgY2FuIGVhc2lseSBzaW11bGF0ZSBib3RoIGdyb3VwcyB3aXRoIGBybm9ybWAgYnV0IHdoYXQgc2hvdWxkIHRoZSBtZWFucyBhbmQgc2RzIG9mIHRoZSBncm91cHMgYmU/DQoNClRoZXJlIGFyZSB0d28gd2F5cyB3ZSBjYW4gYXBwcm9hY2ggdGhpcy4gDQoNCjEuIFdlIGNvdWxkIHRoaW5rIGFib3V0IHdoYXQgZ3JvdXAgbWVhbnMgd2UgZXhwZWN0IGluIG91ciBnaXZlbiBjYXNlIGFuZCB3aGF0IHdlIGV4cGVjdCB0aGUgc3ByZWFkIG9mIHRoZSBncm91cHMgdG8gYmUgX29uIHRoZSBtZWFzdXJtZW50IHNjYWxlIHRoYXQgd2UgYXJlIHdvcmtpbmcgd2l0aF8uDQpGb3IgZXhhbXBsZSwgaWYgd2UgdXNlIGEgNDAtcG9pbnQgc2NhbGUgZm9yIGEgY2xpbmljYWwgdGVzdCB3ZSBtaWdodCBrbm93IHRoYXQgYSBncm91cCB3aXRoIGRlZmljaWVuY2llcyBvbiB0aGUgdGhpbmcgdGhhdCB3ZSBtZWFzdXJlIHdvdWxkIHByb2JhYmx5IHNjb3JlIGFyb3VuZCAxMCBwb2ludHMgYW5kIHRoYXQgYWxtb3N0IGV2ZXJ5b25lIGZyb20gdGhhdCBncm91cCB3b3VsZCBzY29yZSBsb3dlciB0aGFuIDIwIHBvaW50cy4NClRoaXMgc3RhdGVtZW50IChtb3N0IHBlb3BsZSBzY29yZSBhcm91bmQgMTAsIGFsbW9zdCBldmVyeW9uZSBzY29yZXMgbG93ZXIgdGhhbiB0aWZpZWQgYXMgbm9ybWFsIGRpc3RyaWJ1dGlvbiB3aXRoIGEgbWVhbiBvZiAxMCBhbmQgYSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgNS4gSW4gdGhpcyBjYXNlIG9ubHkgMi41JSBvZiB0aGUgdmFsdWVzIChpLmUuIHRoZSB2YWx1ZXMgb3V0c2lkZSB0aGUgOTUlIENJKSB3aWxsIGJlIGhpZ2hlciB0aGFuIDIwLg0KMS4gSW4gYSBuZXcgcmVzZWFyY2ggcHJvamVjdCwgd2UgbWlnaHQgbm90IGJlIGFibGUgb3Igd2lsbGluZyB0byB0byBtYWtlIHRoZXNlIHN0YXRlbWVudHMuIA0KSW4gdGhpcyBjYXNlLCBieSBtYWtpbmcgc29tZSBleHRyYSBhc3N1bXB0aW9ucywgd2UgY2FuIGZhbGwgYmFjayB0byB0aGUgYXBwcm9hY2ggdGhhdCB3ZSBhbHNvIHVzZSBpbiBwb3dlci1jYWxjdWxhdGlvbiBzb2Z0d2FyZSBpbiBtb3N0IGNhc2VzIGFuZCBkZWZpbmUgYSBfc3RhbmRhcmRpemVkIGVmZmVjdCBzaXplXyB0aGF0IHdlIGNhbiB1c2UgdG8gc2ltdWxhdGUgZGF0YSByYXRoZXIgdGhhbiBkZWZpbmluZyB0aGUgZ3JvdXAgbWVhbnMgYW5kIHN0YW5kYXJkLWRldmlhdGlvbnMgZGlyZWN0bHkuDQoNCkkgcGVyc29uYWxseSB0cnkgdG8gZ28gd2l0aCB0aGUgZmlyc3QgYXBwcm9hY2ggd2hlbmV2ZXIgcG9zc2libGUsIGFzIEkgdGhpbmsgdGhhdCBpbiBtYW55IGNhc2VzIHdlIGtub3cgbW9yZSBhYm91dCB3aGF0IHdlIGV4cGVjdCBmcm9tIG91ciBkYXRhIHRoYW4gd2UgdGhpbmssIGV2ZW4gaW4gbmV3IHByb2plY3RzLiANCkV2ZW4gaWYgd2UgX19kbyBub3RfXyBrbm93IGEgbG90IGFib3V0IG91ciBkYXRhLCB3ZSBtaWdodCBzdGlsbCB0cnkgb3V0IGRpZmZlcmVudCBhc3N1bXB0aW9ucyAoaS5lLiBtZWFucyBhbmQgc2RzKSBmb3IgdGhlIGdyb3VwcyBpbiBvdXIgc2ltdWxhdGlvbiB0byBzZWUgd2hhdCBwb3dlciB3ZSB3b3VsZCBnZXQgZm9yIGVhY2ggb2YgdGhlbS4NClRoaXMgd2F5LCB3ZSBjYW4gbWFrZSBpbmZvcm1lZCBkZWNpc2lvbnMgYWJvdXQgb3VyIHNhbXBsZSBzaXplIHRoYXQgYXJlIG1vcmUgbnVhbmNlZCB0aGFuIHRoZSBvbmUgaW4gd2hpY2ggd2UganVzdCBhc3N1bWUgYSBzdGFuZGFyZGl6ZWQgZWZmZWN0IHNpemUgYW5kIHNlZSB3aGF0IHNhbXBsZS1zaXplIGl0IGltcGxpZXMgYW5kIGFyZSBmb3JjZWQgdG8gdGhpbmsgaGFyZGVyIGFib3V0IG91ciBkYXRhIC0gc29tZXRoaW5nIHRoYXQgbWlnaHQgc2VlbSBkaWZmaWN1bHQgYW5kIGFubm95aW5nIGF0IGZpcnN0LCBidXQgaXMgZXh0cmVtZWx5IHVzZWZ1bCBhbmQgZWR1dWNhdGlvbmFsLg0KQW5vdGhlciBhZHZhbnRhZ2Ugb2Ygc3BlY2lmeWluZyB0aGUgZ3JvdXBzIGRpcmVjdGx5IGlzIHRoYXQgd2UgY2FuIGRvIHRoaXMgZm9yIGFueSBhcmJpdHJhcmlseSBjb21wbGV4IGRlc2lnbiB3aGVyZSBzdGFuZGFyZGl6ZWQgZWZmZWN0IHNpemVzIGFyZSBvZnRlbiBkaWZmaWN1bHQgdG8gY2FsY3VsYXRlLg0KDQpUaGlzIHNhaWQsIGZvciB0aGUgY2FzZXMgd2hlcmUgd2UgbWlnaHQgcmVhbGx5IG5vdCBiZSB3aWxsaW5nIHRvIHNwZWNpZnkgZ3JvdXBzIGRpcmVjdGx5LCBhbmQgYmVjYXVzZSBpdCBhbGxvd3MgbWUgdG8gZGVtb25zdHJhdGUgc29tZSBvdGhlciBpbnRlcmVzdGluZyBwb2ludHMsIGluIHRoaXMgcGFydCBJIHdpbGwgZGlzY3VzcyBob3cgd2UgY2FuIHVzZSBzdGFuZGFyZGl6ZWQgZWZmZWN0LXNpemVzIGluIG91ciBzaW11bGF0aW9uLg0KSW4gcGFydCBJSUkgYW5kIElWIGhvd2V2ZXIsIHdlIHdpbGwgYWx3YXlzIHNwZWNpZnkgZWZmZWN0cyBvbiB0aGUgcmF3IHNjYWxlLg0KDQoNCklmIHdlIHdlcmUgdXNpbmcgR1Bvd2VyIG5vdywgd2Ugd291bGQgbW9zdCBsaWtlbHkganVzdCBmaWxsIGluIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIGdyb3VwcyBpbiAkQ29oZW4nc1wgZCQgYW5kIGJlIGRvbmUgd2l0aCBpdC4gDQpXZSBjb3VsZCBvZiBjb3Vyc2UgYWxzbyBmb2xsb3cgdGhpcyBhcHByb2FjIGluIGEgc2ltdWxhdGlvbiBieSBkZWZpbmluZyB0aGUgZ3JvdXBzIGJhc2VkIG9uIHRoZSBpbXBsaWVkICRDb2hlbidzXCBkJC4gDQpGb3IgaW5zdGFuY2UsIHdlIGNhbiBqdXN0IGFzc3VtZSB0aGF0IGdyb3VwIDEgYXMgYHJub3JtKG4sIDEsMilgLg0KTm93LCBmb2xsb3dpbmcgZnJvbSB0aGUgZm9ybXVsYSBmb3IgQ29oZW4ncyBkOg0KDQokJENvaGVuJ3NcIGQgPSAgXGZyYWN7KE1fMSAtIE1fMil9e3Bvb2xlZCBcIHNkfSQkDQoNCndoZXJlDQoNCiQkcG9vbGVkXCBzZCA9ICBcc3FydFxmcmFjeyhzZF8xXjIrc2RfMl4yKX17Mn0kJA0KIA0KIGFuZCBhZGhlcmluZyB0byB0aGUgc3R1ZGVudCB0LXRlc3QgYXNzdW1wdGlvbiBvZiBlcXVhbCB2YXJpYW5jZXMgd2UgY2FuIGZpbGwgaW4gdGhlIHBvb2xlZCBzZCBmb3JtdWxhIGFib3ZlIGFzDQoNCiQkcG9vbGVkXCBzZCA9ICBcc3FydFxmcmFjeygyXjIrMl4yKX17Mn0gPSAyJCQNCg0KdG8gZ2V0IGEgJENvaGVuJ3NcIGQkIG9mIC41MDoNCg0KJCRDb2hlbidzXCBkID0gIFxmcmFjeygxIC0gMCl9ezJ9ID0gMC41JCQNCg0KVG8gZ2V0IGFueSBvdGhlciB2YWx1ZSBmb3IgJENvaGVuJ3NcIGQkIHdlIGNhbiBqdXN0IGNoYW5nZSB0aGUgcG9vbGVkIHNkIHZhbHVlIHRvIHdoYXRldmVyIHdlIHdhbnQuDQpNb3JlIGdlbmVyYWxseSwgd2Ugd2FudCB0byBzb2x2ZSB0aGUgZXF1YXRpb24gYWJvdmUgZm9yIHRoZSBwb29sZWQgc2QgYWZ0ZXIgc3BlY2lmeWluZyBhbnkgJENvaGVuJ3NcIGQkLCBlLmcuOg0KDQokJDAuNT0gIFxmcmFjeygxIC0gMCl9e3Bvb2xlZFwgc2R9JCQNCg0KV2UgY2FuIHNvbHZlIGFuIGVxdWF0aW9uIGxpa2UgdGhhdCB3aXRoIGBSYCdzIHNvbWV3aGF0IHVuaW50dWl0aXZlIGBzb2x2ZWAgZnVuY3Rpb24gbGlrZSB0aGlzOg0KDQpgYGB7ciBzb2x2ZV9jb2hlbnNkfQ0Kc29sdmUoMC41LDEpICMgY29oZW5zIGQgb2YgLjUNCnNvbHZlKDAuMjUsMSkgIyBjb2hlbnMgZCBvZiAuMjUNCnNvbHZlKDIsMSkgIyBjb2hlbnMgZCBvZiAyDQoNCmBgYA0KDQpnaXZpbmcgdXMgdGhyZWUgZXhhbXBsZXMgb2YgaG93IHdlIHdvdWxkIG5lZWQgdG8gc3BlY2lmeSBwb29sZWQgc2QgdG8gYXJyaXZlIGF0IGEgcGFydGljdWxhciAkQ29oZW4nc1wgZCQuDQoNClRodXMsIGlmIHdlIHdhbnQgdG8gZG8gYSB0LXRlc3Qgd2l0aCB0d28gc2ltdWxhdGVkIGdyb3VwcyBhbmQgYSBjb2hlbidzIGQgb2YgMC41IHdlIGNhbiBzaW11bGF0ZSB0d28gZ3JvdXBzIG9mIGEgcGFydGljdWxhciBzYW1wbGUtc2l6ZSBieSB1c2luZyB0aGUgYHJub3JtYCBmdW5jdGlvbi4NCkxldCdzIHNheSB3ZSBoYXZlIDMwIHBhcnRpY2lwYW50cyBpbiBlYWNoIGdyb3VwLg0KDQpgYGB7ciBzaW1fZ3JvdXBzMX0NCnNldC5zZWVkKDEyMzQpDQpncm91cDEgPC0gcm5vcm0oMzAsIDEsIDIpDQpncm91cDIgPC0gcm5vcm0oMzAsIDAsIDIpDQpgYGANCg0KV2UgY2FuIHZpc3VhbGl6ZSB0aGUgZ3JvdXBzIHRoYXQgd2UgZ290IGluIGEgcGxvdCBsaWtlIHRoaXM6DQoNCmBgYHtyIHBsb3RfZ3JvdXBzMX0NCmhpc3QoZ3JvdXAxLCBjb2wgPSAiI2FkZGQ4ZSIsIGJyZWFrcyA9IDEwLCBtYWluID0gIkhpc3RvZ3JhbSBvZiBib3RoIGdyb3VwcyIsIHhsYWIgPSAiIikNCmhpc3QoZ3JvdXAyLCBhZGQgPSBUUlVFLCBicmVha3MgPSAxMCwgY29sPSAiIzMxYTM1NCIpDQpgYGANCg0KV2UgY2FuIGFscmVhZHkgbWFrZSBpbXBvcnRhbnQgb2JzZXJ2YXRpb25zIGZyb20gdGhpcyBwbG90Og0KDQpXZSB3YW50ZWQgdG8gZ2V0IG5vcm1hbCBkaXN0cmlidXRpb25zLCBidXQgd2hhdCB3ZSBnb3QgaGVyZSBkb2VzIG5vdCByZWFsbHkgbG9vayBub3JtYWwuIA0KV2h5IGlzIHRoYXQ/IEJlY2F1c2Ugd2Ugb25seSBoYXZlIDMwIHBlb3BsZSBwZXIgZ3JvdXAgYW5kIHRha2luZyBvbmx5IDMwIHZhbHVlcyBmcm9tIHRoZSBzcGVjaWZpZWQgbm9ybWFsIGRpc3RyaWJ1dGlvbnMgZG9lcyBub3QgcmVhbGx5IGdpdmUgdXMgYSBnb29kIGFwcHJveGltYXRpb24gb2YgdGhlIHJlYWwgZGlzdHJpYnV0aW9uLg0KX19UaGlzIHBvaW50IGlzIGltcG9ydGFudF9fOiBUaGUgc2FtcGxpbmcgdmFyaWFiaWxpdHkgaW4gc3VjaCBzbWFsbCBncm91cHMgaXMgaGlnaCBhbmQgb2Z0ZW4sIGlmIHNtYWxsIHNhbXBsZS1zdHVkaWVzIChpLmUuIHVuZGVycG93ZXJlZCBzdHVkaWVzKSBmaW5kICJlZmZlY3RzIiwgdGhleSBhcmUgb2Z0ZW4gcmF0aGVyIGJpZyBhbmQgdGhlIGNvbnNlcXVlbmNlIG9mIHRoaXMgc2FtcGxpbmcgdmFyaWFiaWxpdHkgcmF0aGVyIHRoYW4gcmVhbCBkaWZmZXJlbmNlcyBvZiBncm91cHMuDQpGb3IgZXhhbXBsZSwgYnkgbG9va2luZyBhdCB0aGUgbWVhbnMgb2Ygb3VyIHNhbXBsZWQgZ3JvdXBzIGBtZWFuKGdyb3VwMSlgID0gYHIgbWVhbihncm91cDEpYCBhbmQgYG1lYW4oZ3JvdXAyKWAgPSBgciBtZWFuKGdyb3VwMilgIHdlIHNlZSB0aGF0IHRoZSBncm91cCBtZWFuIG9mIGdyb3VwIDEgaXMgYWN0dWFsbHkgY2xvc2VyIHRvIHRoZSBtZWFuIHRoYXQgd2Ugc3BlY2lmaWVkIGZvciBncm91cCAyIChpLmUuIDApIHRoYW4gdG8gaXRzIG93biBtZWFuLCB3aGlsZSB0aGUgbWVhbiBmb3IgZ3JvdXAgMiBpcyBmYXIgYXdheSBmcm9tIG91ciBpbnRlbmRlZCBtZWFuLiANCkxvb2tpbmcgYXQgdGhlIHNkcyBhY3R1YWxseSBzaG93cyB0aGF0IHRoZXkgYXJlIHF1aXRlIGNsb3NlIHRvIHdoYXQgd2Ugd2FudGVkIGBzZChncm91cDEpYCA9IGByIHNkKGdyb3VwMSlgIGFuZCBgc2QoZ3JvdXAyKWAgPSBgciBzZChncm91cDIpYC4NClRoZSAkQ29oZW4nc1wgZCQgdGhhdCB3ZSB3YW50ZWQgaXMgYWxzbyBub3QgcHJlc2VudGVkIHZlcnkgYWNjdXJhdGVseSBhdCBgKG1lYW4oZ3JvdXAxKS1tZWFuKGdyb3VwMikpLyhzcXJ0KChzZChncm91cDEpXjIrc2QoZ3JvdXAyKV4yKS8yKSlgID0gYHIgKG1lYW4oZ3JvdXAxKS1tZWFuKGdyb3VwMikpLyhzcXJ0KChzZChncm91cDEpXjIrc2QoZ3JvdXAyKV4yKS8yKSlgLg0KQWdhaW4sIGlmIHdlIHdvdWxkIGRvIHRoaXMgaW4gR3Bvd2VyLCBhbmQgc3BlY2lmeSBhICRDb2hlbidzXCBkJCwgd2Ugd2lsbCBhbHdheXMgd29yayB3aXRoIGFuIF9leGFjdF8gJENvaGVuJ3NcIGQkLCBpbiBhIHNpbXVsYXRpb24gYXBwcm9hY2ggd2UgZG8gX19ub3RfXy4gDQoNCg0KU28gbGV0IHVzIHJ1biBhIHQtdGVzdCB0byBzZWUgd2hldGhlciB0aGVyZSBpcyBhIHNpZ25pZmljYW50IGRpZmZlcmVuY2UgaGVyZS4NCkZpcnN0LCB3ZSBuZWVkIHRvIGRlY2lkZSBvbiBhbiBhbHBoYS1sZXZlbCBhZ2Fpbi4NCldoYXQgd2lsbCB3ZSBjaG9vc2U/DQpXZWxsLCB0byBoYXZlIGEgZ29vZCBqdXN0aWZpY2F0aW9uIHdlIGhhdmUgdG8gZWxhYm9yYXRlIG9uIHdoYXQgdGhlIGdyb3VwcyBhY3R1YWxseSByZXByZXNlbnQuDQpMZXQgdXMgc2F5IHRoYXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBncm91cHMgaXMgcmVsYXRlZCB0byBhbiBpbnRlcnZlbnRpb24gdGhhdCBjYW4gZWxldmF0ZSBkZXByZXNzaXZlIHN5bXB0b21zLiANClRodXMsIHRoZSBjb250cm9sIGdyb3VwIChncm91cDEpIGRpZCBub3QgZ2V0IHRoZSBpbnRlcnZlbnRpb24gYW5kIHNjb3JlcyBoaWdoZXIgb24gZGVwcmVzc2l2ZSBzeW1wdG9tcyB3aGlsZSB0aGUgdHJlYXRtZW50IGdyb3VwIChncm91cDIpIGlzIGV4cGVjdGVkIHRvIHNjb3JlIGxvd2VyLg0KTGV0IHVzIGFzc3VtZSB0aGF0IHRoaXMgaXMgdGhlIGZpcnN0IHN0dWR5IHRoYXQgd2UgcnVuIGFuZCB0aGF0LCBpZiB3ZSBmaW5kIGFueXRoaW5nIHdlIHdpbGwgZm9sbG93IGl0IHVwIGJ5IG1vcmUgZXh0ZW5zaXZlIHN0dWRpZXMgYW55d2F5LiBUaGVyZWZvcmUsIHdlIG1pZ2h0IG5vdCB3YW50IHRvIG1pc3MgYSBwb3NzaWJsZSBlZmZlY3QgYnkgc2V0dGluZyBhIHRvbyBjb25zZXJ2YXRpdmUgYWxwaGEtbGV2ZWwuDQpJZiB3ZSBmaW5kIHNvbWV0aGluZyBpbiB0aGlzIHN0dWR5LCB3ZSB3aWxsIGNvbmR1Y3QgZnVydGhlciBzdHVkaWVzIGluIHdoaWNoIHdlIGFyZSBtb3JlIHN0cmljdCBhYm91dCB0aGUgYWxwaGEgbGV2ZWwuDQpUaHVzLCB3ZSBjaG9vc2UgLjEwIGZvciB0aGlzIGZpcnN0ICJwaWxvdCIgc3R1ZHkuDQoNCnt7JSBhbGVydCBub3RlICV9fQ0KVGhlIGFscGhhLWxldmVsICJqdXNmaWNpY2F0aW9ucyIgaW4gdGhpcyB0dXRvcmlhbCBhcmUgZm9yIGVkdWNhdGlvbmFsIHB1cnBvc2VzIGFuZCB0byBwcm92aWRlIGEgc3RhcnRpbmcgcG9pbnQuIFRoZXkgYXJlIG9idmlvdXNseSBub3QgYXMgcmlnb3JvdXMgYXMgd2Ugd291bGQgbGlrZSBpbiBhIHJlYWwgcmVzZWFyY2ggcHJvamVjdC4gSWYgeW91IGZpbmQgeW91cnNlbGYgaW4gYSBzaXR1YXRpb24gd2hlcmUgeW91IHdhbnQgdG8ganVzdGlmeSB5b3VyIGFscGhhLWxldmVsIHNlZSBbSnVzdGlmeSB5b3VyIGFscGhhIGJ5IExha2VucyBldCBhbC5dKGh0dHBzOi8vd3d3Lm5hdHVyZS5jb20vYXJ0aWNsZXMvczQxNTYyLTAxOC0wMzExLXgpIGZvciBhIGdvb2QgZGlzY3Vzc2lvbiBvbiB0aGlzLg0Ke3slIC9hbGVydCAlfX0NCg0KV2UgY2FuIG5vdyBydW4gYSB0LXRlc3Qgd2l0aCBSJ3MgaW50ZWdyYXRlZCBgdC50ZXN0YCBmdW5jdGlvbi4NCg0KYGBge3IgdC10ZXN0MX0NCnQudGVzdChncm91cDEsIGdyb3VwMiwgcGFpcmVkID0gRkFMU0UsIHZhci5lcXVhbCA9IFRSVUUsIGNvbmYubGV2ZWwgPSAwLjkpDQpgYGANCg0KVGhlIHQtdGVzdCBzaG93cywgdGhhdCB0aGlzIGVmZmVjdCB3b3VsZCBiZSBzaWduaWZpY2FudC4NCkhvd2V2ZXIsIHdlIGFsc28gZ290ICJsdWNreSIgYW5kIGhhZCBhIGxhcmdlciBlZmZlY3QgdGhhbiB3ZSBpbnRlbmRlZCB0byBoYXZlLg0KVG8gZG8gYSBwcm9wZXIgcG93ZXIgYW5hbHlzaXMgKGxldHMgc2F5IHdlIGZpcnN0IHdhbnQgdG8gc2VlIHdoZXRoZXIgMzAgcGVvcGxlIHBlciBncm91cCBhcmUgZW5vdWdoKSB3ZSBuZWVkIHRvIG5vdCBvbmx5IHNpbXVsYXRlIGVhY2ggZ3JvdXAgb25jZSwgYnV0IG1hbnkgbWFueSB0aW1lcyBhbmQgc2VlIGhvdyBvZnRlbiB3ZSBnZXQgYSBzaWduaWZpY2FudCByZXN1bHQgYXQgdGhlIGRlc2lyZWQgYWxwaGEtbGV2ZWxbXjFdLg0KTW9yZW92ZXIsIHdlIHdvdWxkIGxpa2UgdG8gaGF2ZSBhIHBvd2VyIG9mIGF0IGxlYXN0IDk1JSwgYWdhaW4gcmVmbGVjdGluZyBvdXIgdmlldyB0aGF0IHdlIGRvIG5vdCB3YW50IHRvIG1pc3MgYSBwb3NzaWJsZSBlZmZlY3QuDQoNCkluIG5vcm1hbCBsYW5ndWFnZSB0aGVzZSBhc3N1bXB0aW9ucyBtZWFuIHRoYXQgaWYgdGhlcmUgaXMgYSBkaWZmZXJlbmNlLCB3ZSB3aWxsIGRldGVjdCBpdCBpbiAxOSBvdXQgb2YgMjAgY2FzZXMgd2hpbGUsIGlmIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UsIHdlIHdpbGwgb25seSBiZSBpbmNvcnJlY3RseSBjbGFpbWluZyB0aGF0IHRoZXJlIGlzIG9uZSBpbiAxIG91dCBvZiAxMCBjYXNlcy4NCg0KV2Ugd2lsbCBkbyB0aGlzIHNpbWlsYXJseSB0byBvdXIgc2ltdWxhdGlvbnMgaW4gcGFydCAxIG9mIHRoaXMgdHV0b3JpYWwuDQoNCmBgYHtyIHNpbV90dGVzdF9wcDMwfQ0Kc2V0LnNlZWQoMSkNCm5fc2ltcyA8LSAxMDAwICMgd2Ugd2FudCAxMDAwIHNpbXVsYXRpb25zDQpwX3ZhbHMgPC0gYygpDQpmb3IoaSBpbiAxOm5fc2ltcyl7DQogIGdyb3VwMSA8LSBybm9ybSgzMCwxLDIpICMgc2ltdWxhdGUgZ3JvdXAgMQ0KICBncm91cDIgPC0gcm5vcm0oMzAsMCwyKSAjIHNpbXVsYXRlIGdyb3VwIDINCiAgcF92YWxzW2ldIDwtIHQudGVzdChncm91cDEsIGdyb3VwMiwgcGFpcmVkID0gRkFMU0UsIHZhci5lcXVhbCA9IFRSVUUsIGNvbmYubGV2ZWwgPSAwLjkwKSRwLnZhbHVlICMgcnVuIHQtdGVzdCBhbmQgZXh0cmFjdCB0aGUgcC12YWx1ZQ0KfQ0KbWVhbihwX3ZhbHMgPCAuMTApICMgY2hlY2sgcG93ZXIgKGkuZS4gcHJvcG9ydGlvbiBvZiBwLXZhbHVlcyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gYWxwaGEtbGV2ZWwgb2YgLjEwKQ0KDQpgYGANCg0KQWhhLCBzbyBpdCBhcHBlYXJzIHRoYXQgb3VyIHBvd2VyIGBtZWFuKHBfdmFscyA8IC4xMClgID0gYHIgbWVhbihwX3ZhbHMgPCAuMTApYCBpcyBtdWNoIGxvd2VyIHRoYW4gdGhlIDk1JSB0aGF0IHdlIGRlc2lyZWQuDQpUaHVzLCB3ZSBkaWQgcmVhbGx5IGdldCBsdWNreSBpbiBvdXIgZXhhbXBsZSBhYm92ZSB3aGVuIHdlIGZvdW5kIGFuIGVmZmVjdCBvZiBvdXIgaW50ZXJ2ZW50aW9uLg0KDQpUbyBhY3R1YWxseSBkbyBhIGxlZ2l0IHBvd2VyLWFuYWx5c2lzIGhvd2V2ZXIsIHdlIHdvdWxkIGxpa2UgdG8ga25vdyBob3cgbWFueSBwZW9wbGUgd2UgZG8gbmVlZCBmb3IgYSBwb3dlciBvZiA5NSBwZXJjZW50Lg0KQWdhaW4gd2UgY2FuIG1vZGlmeSB0aGUgY29kZSBhYm92ZSB0byB0YWtlIHRoaXMgaW50byBhY2NvdW50Lg0KDQpgYGB7ciB0X3Rlc3RfdHN9DQpzZXQuc2VlZCgxKQ0Kbl9zaW1zIDwtIDEwMDAgIyB3ZSB3YW50IDEwMDAgc2ltdWxhdGlvbnMNCnBfdmFscyA8LSBjKCkNCnBvd2VyX2F0X24gPC0gYygwKSAjIHRoaXMgdmVjdG9yIHdpbGwgY29udGFpbiB0aGUgcG93ZXIgZm9yIGVhY2ggc2FtcGxlLXNpemUgKGl0IG5lZWRzIHRoZSBpbml0aWFsIDAgZm9yIHRoZSB3aGlsZS1sb29wIHRvIHdvcmspDQpjb2hlbnNfZHMgPC0gYygpDQpjb2hlbnNfZHNfYXRfbiA8LSBjKCkgDQpuIDwtIDMwICMgc2FtcGxlLXNpemUgDQppIDwtIDINCndoaWxlKHBvd2VyX2F0X25baS0xXSA8IC45NSl7DQogIGZvcihzaW0gaW4gMTpuX3NpbXMpew0KICAgIGdyb3VwMSA8LSBybm9ybShuLDEsMikgIyBzaW11bGF0ZSBncm91cCAxDQogICAgZ3JvdXAyIDwtIHJub3JtKG4sMCwyKSAjIHNpbXVsYXRlIGdyb3VwIDINCiAgICBwX3ZhbHNbc2ltXSA8LSB0LnRlc3QoZ3JvdXAxLCBncm91cDIsIHBhaXJlZCA9IEZBTFNFLCB2YXIuZXF1YWwgPSBUUlVFLCBjb25mLmxldmVsID0gMC45KSRwLnZhbHVlICMgcnVuIHQtdGVzdCBhbmQgZXh0cmFjdCB0aGUgcC12YWx1ZQ0KICAgIGNvaGVuc19kc1tzaW1dIDwtIGFicygobWVhbihncm91cDEpLW1lYW4oZ3JvdXAyKSkvKHNxcnQoKHNkKGdyb3VwMSleMitzZChncm91cDIpXjIpLzIpKSkgIyB3ZSBhbHNvIHNhdmUgdGhlIGNvaGVucyBkcyB0aGF0IHdlIG9ic2VydmVkIGluIGVhY2ggc2ltdWxhdGlvbg0KICB9DQogICAgcG93ZXJfYXRfbltpXSA8LSBtZWFuKHBfdmFscyA8IC4xMCkgIyBjaGVjayBwb3dlciAoaS5lLiBwcm9wb3J0aW9uIG9mIHAtdmFsdWVzIHRoYXQgYXJlIHNtYWxsZXIgdGhhbiBhbHBoYS1sZXZlbCBvZiAuMTApDQogICAgY29oZW5zX2RzX2F0X25baV0gPC0gbWVhbihjb2hlbnNfZHMpICMgY2FsY3VsYXRlIG1lYW5zIG9mIGNvaGVucyBkcyBmb3IgZWFjaCBzYW1wbGUtc2l6ZQ0KICAgIG4gPC0gbisxICMgaW5jcmVhc2Ugc2FtcGxlLXNpemUgYnkgMQ0KICAgIGkgPC0gaSsxICMgaW5jcmVhc2UgaW5kZXggb2YgdGhlIHdoaWxlLWxvb3AgYnkgMSB0byBzYXZlIHBvd2VyIGFuZCBjb2hlbnMgZCB0byB2ZWN0b3INCn0NCnBvd2VyX2F0X24gPC0gcG93ZXJfYXRfblstMV0gIyBkZWxldGUgZmlyc3QgMCBmcm9tIHRoZSB2ZWN0b3INCmNvaGVuc19kc19hdF9uIDwtIGNvaGVuc19kc19hdF9uWy0xXSAjIGRlbGV0ZSBmaXJzdCBOQSBmcm9tIHRoZSB2ZWN0b3INCmBgYA0KDQpUaGUgbG9vcCBzdG9wcGVkIGF0IGEgc2FtcGxlLXNpemUgb2YgYG4tMWAgPSBgciBuLTFgIHBhcnRpY2lwYW50cyBwZXIgZ3JvdXAuDQpUaHVzIG1ha2UgYSBjb25jbHVzaW9uIGFib3V0IHRoZSBlZmZlY3RpdmVuZXNzIG9mIG91ciBpbnRlcnZlbnRpb24gYXQgdGhlIHNwZWNpZmllZCBhbHBoYS1sZXZlbCB3aXRoIHRoZSBkZXNpcmVkIHBvd2VyIHdlIG5lZWQgYHIgKG4tMSkqMmAgcGVvcGxlIGluIHRvdGFsLg0KDQpUbyB2aXN1YWxpemUgdGhlIHBvd2VyIHdlIGNhbiBwbG90IGl0IGFnYWluLCBqdXN0IGFzIGluIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSB0dXRvcmlhbC4NCg0KYGBge3IgcGxvdF9wb3dlcjF9DQpwbG90KDMwOihuLTEpLCBwb3dlcl9hdF9uLCB4bGFiID0gIk51bWJlciBvZiBwYXJ0aWNpcGFudHMgcGVyIGdyb3VwIiwgeWxhYiA9ICJQb3dlciIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBUUlVFKQ0KYWJsaW5lKGggPSAuOTUsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCkFnYWluLCB0aGlzIHBsb3Qgc2hvd3MgdXMgaG93IG91ciBwb3dlciB0byBkZXRlY3QgdGhlIGVmZmVjdCBzbG93bHkgaW5jcmVhc2VzIGlmIHdlIGluY3JlYXNlIHRoZSBzYW1wbGUtc2l6ZSB1bnRpbCBpdCByZWFjaGVzIG91ciBkZXNpcmVkIHBvd2VyLg0KDQoNClRoZXJlIGlzIGFub3RoZXIgaW50ZXJlc3Rpbmcgb2JzZXJ2YXRpb24gdG8gbWFrZSBoZXJlLiANCkluIHRoZSBjb2RlIGFib3ZlLCBJIGFsc28gY2FsY3VsYXRlIHRoZSBhdmVyYWdlICRDb2hlbidzXCBkJCBmb3IgZWFjaCBzYW1wbGUgc2l6ZSBhbmQgdGhlIHBsb3QgYmVsb3cgc2hvd3MgaG93IGl0IGNoYW5nZXMgd2l0aCBpbmNyZWFzaW5nIHNhbXBsZS1zaXplLg0KDQpgYGB7ciBwbG90X2NvaGVuc2QxfQ0KcGxvdCgzMDoobi0xKSwgY29oZW5zX2RzX2F0X24sIHhsYWIgPSAiTnVtYmVyIG9mIHBhcnRpY2lwYW50cyBwZXIgZ3JvdXAiLCB5bGFiID0gIkNvaGVucyBEIiwgeWxpbSA9IGMoMC40NSwwLjU1KSwgYXhlcyA9IFRSVUUpDQphYmxpbmUoaCA9IC41MCwgY29sID0gInJlZCIpDQpgYGANCg0KSXQgaXMgbm90IHN1cGVyIG9idmlvdXMgaW4gdGhpcyBwbG90IGFuZCBJIGhhZCB0byBjaGFuZ2UgdGhlIHNjYWxlIG9mIHRoZSB5LWF4aXMgcXVpdGUgYSBiaXQgdG8gbWFrZSBpdCB2aXNpYmxlLCBidXQgd2UgY2FuIGFjdHVhbGx5IHNlZSBob3cgb3VyIGF2ZXJhZ2UgJENvaGVuJ3NcIGQkIGluaXRpYWxseSBkZXZpYXRlcyBzbGlnaHRseSBtb3JlIGZyb20gdGhlIGRlc2lyZWQgJENvaGVuJ3NcIGQkIG9mIC41MCB0aGFuIGluIGRlIGVuZC4NCkluIG90aGVyIHdvcmRzLCBpbiB0aGUgYmVnaW5uaW5nLCBmb3Igc21hbGwgc2FtcGxlLXNpemVzIHRoZXJlIGlzIG1vcmUgZmx1Y3R1YXRpb24gdGhhbiBmb3IgYmlnZ2VyIHNhbXBsZS1zaXplcy4NClRoYXQgaXMgcHJldHR5IG5lYXQsIGFzIGl0IHNlZW1zIHZlcnkgZGVzaXJhYmxlIHRoYXQgYSBwb3dlci1lc3RpbWF0aW9uIHByb2NlZHVyZSB0YWtlcyBpbnRvIGFjY291bnQgdGhhdCBmb3Igc21hbGxlciBzYW1wbGUtc2l6ZXMsIGV2ZW4gaWYgdGhlIGVmZmVjdCBpbiB0aGUgcG9wdWxhdGlvbiBpcyBleGFjdGx5IHRoZSBzYW1lIChpLmUuIHdlIGFsd2F5cyBzYW1wbGUgZ3JvdXBzIHdpdGggYSBkaWZmZXJlbmNlIG9mICRDb2hlbidzXCBkJCA9IC41MCkgaXQgaXMganVzdCBsZXNzIHByZWNpc2UuDQoNCg0KTGV0J3MgaGF2ZSBhIGJyaWVmIHN1bW1hcnkgb2Ygd2hhdCB3ZSBkaWQgc28gZmFyLg0KV2UganVzdCB1c2VkIHRoZSBmb3JtdWxhIGZvciAkQ29oZW4nc1wgZCQgdG8gZ2l2ZSBvdXIgZ3JvdXBzIGEgY2VydGFpbiBkaWZmZXJlbmNlIHRoYXQgd2UgYXJlIGludGVyZXN0ZWQgaW4sIHJhbiAxMDAwIHNpbXVsYXRlZCBleHBlcmltZW50cyBmb3IgZWFjaCBzYW1wbGUtc2l6ZSBhbmQgY2FsY3VsYXRlZCB0aGUgcG93ZXIsIGp1c3QgYXMgaW4gdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHR1dG9yaWFsLg0KDQpIb3dldmVyLCBJIHdhbnQgdG8gbWVudGlvbiBhZ2FpbiB0aGF0LCBldmVuIHRob3VnaCBpdCBpcyBjb252ZW5pZW50IHRvIHNwZWNpZnkgdGhlIGVmZmVjdC1zaXplIHRoaXMgd2F5IGFzIGl0IHNhdmVzIHVzIGZyb20gaGF2aW5nIHRvIHNwZWNpZnkgcHJlY2lzZSBncm91cCBtZWFucyBhbmQgc3RhbmRhcmQtZGV2aWF0aW9ucyBkaXJlY3R5IGFuZCBtYWtlcyB0aGUgc3BlY2lmaWNhdGlvbiBtb3JlIGNvbXBhcmFibGUsIGl0IGlzIG9mdGVuIHByZWZlcmFibGUgdG8gc3BlY2lmeSB0aGUgcGFyYW1ldGVycyBvbiB0aGUgb3JpZ2luYWwgc2NhbGUgdGhhdCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi4NClRoaXMgaXMgZXNwZWNpYWxseSB0aGUgY2FzZSBpZiB3ZSBoYXZlIHByZXZpb3VzIGRhdGEgb24gYSByZXNlYXJjaCB0b3BpYyB0aGF0IHdlIGNhbiBtYWtlIHVzZSBvZi4gDQpNb3Jlb3ZlciwgZm9yIG1vcmUgY29tcGxleCBkZXNpZ25zIHdpdGggbWFueSBwYXJhbWV0ZXJzLCBzdGFuZGFyZGl6ZWQgZWZmZWN0IHNpemVzIGFyZSBvZnRlbiBkaWZmaWN1bHQgdG8gb2J0YWluIGFuZCB3ZSBhcmUgZm9yY2VkIHRvIG1ha2Ugb3VyIGFzc3VtcHRpb25zIG9uIHRoZSBvcmlnaW5hbCBzY2FsZSBvZiB0aGUgZGF0YS4NCldlIHdpbGwgc2VlIHRoaXMgaW4gbGF0ZXIgZXhhbXBsZXMuDQoNCg0KIyMgU2ltdWxhdGluZyBhIHdpdGhpbi1zdWJqZWN0IHQtdGVzdA0KDQpJbnR1aXRpdmVseSwgaXQgbWlnaHQgc2VlbSB0aGF0IHdlIGNhbiB1c2UgdGhlIGV4YWN0IHNhbWUgYXBwcm9hY2ggYWJvdmUgZm9yIGEgcGFpcmVkIHQtdGVzdCBhcyB3ZWxsLiANCkhvd2V2ZXIsIHRoZSBwcm9ibGVtIHdpdGggdGhpcyBpcyB0aGF0IGluIGEgcGFpcmVkIHQtdGVzdCB3ZSBnZXQgMiBkYXRhLXBvaW50cyBmcm9tIHRoZSBzYW1lIGluZGl2aWR1YWwuIA0KRm9yIGV4YW1wbGUsIGltYWdlIHdlIGhhdmUgYSBncm91cCBvZiBwZW9wbGUgdGhhdCBnZXQgYW4gaW50ZXJ2ZW50aW9uIGFuZCB3ZSBtZWFzdXJlIHRoZWlyIHNjb3JlIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGludGVydmVudGlvbiBhbmQgd2FudCB0byBjb21wYXJlIHRoZW0gd2l0aCBhIHBhaXJlZCB0LXRlc3QuDQpJbiB0aGlzIGNhc2UsIHRoZSBzY29yZSBvZiB0aGUgcG9zdC1tZWFzdXJlIG9mIGEgZ2l2ZW4gaW5kaXZpZHVhbCBpcyBub3QgY29tcGxldGVseSBpbmRlcGVuZGVudCBvZiB0aGUgc2NvcmUgb2YgdGhlIHByZS1tZWFzdXJlLiANCkluIG90aGVyIHdvcmRzLCBzb21lYm9keSB3aG8gc2NvcmVzIHZlcnkgbG93IG9uIHRoZSBwcmUtbWVhc3VyZSB3aWxsIG1vc3QgbGlrZWx5IG5vdCBzY29yZSB2ZXJ5IGhpZ2ggb24gdGhlIHBvc3QtbWVhc3VyZSBhbmQgdmljZSB2ZXJzYS4NCg0KVGh1cywgdGhlcmUgaXMgYSBfY29ycmVsYXRpb25fIGJldHdlZW4gdGhlIHByZS0gYW5kIHRoZSBwb3N0LW1lYXN1cmVzIGluIHRoYXQgdGhlIHByZS1tZWFzdXJlcyBhbHJlYWR5IHRlbGwgdXMgYSBsaXR0bGUgYml0IGFib3V0IHdoYXQgd2UgY2FuIGV4cGVjdCBvbiB0aGUgcG9zdC1tZWFzdXJlLg0KWW91IHByb2JhYmx5IGFscmVhZHkga25ldyB0aGlzIGJ1dCB3aHkgZG9lcyB0aGlzIG1hdHRlciBmb3IgcG93ZXIgc2ltdWxhdGlvbiwgeW91IG1pZ2h0IHdvbmRlci4gDQpJdCBtYXR0ZXJzIGFzIGl0IGRpcmVjdGx5IGluZmx1ZW5jZXMgb3VyIHBvd2VyIHRvIGRldGVjdCBhbiBlZmZlY3QgYXMgd2Ugd2lsbCBzZWUgbGF0ZXIuDQpGb3Igbm93IGxldCdzIGp1c3Qga2VlcCBpbiBtaW5kIHRoYXQgaXQgaXMgaW1wb3J0YW50Lg0KDQoNClNvIHdoYXQgZG8gd2UgZG8gaW4gYSBzaXR1YXRpb24gd2l0aCBjb3JyZWxhdGVkIGRhdGEgYXMgaW4gdGhlIHByZS1wb3N0IGludGVydmVudGlvbiBzaXR1YXRpb24/DQpUaGVyZSBhcmUgdHdvIHdheXMgd2UgY2FuIGdvIGZyb20gaGVyZS4gDQpGaXJzdCwgd2UgY2FuIHNpbXVsYXRlIGNvcnJlbGF0ZWQgbm9ybWFsIGRpc3RyaWJ1dGlvbnMsIGFzIGFscmVhZHkgbWVudGlvbmVkIGFib3ZlLg0KSG93ZXZlciwgZm9yIHRoZSBwYXJ0aWN1bGFyIGNhc2Ugb2YgYSBwYWlyZWQgc2FtcGxlIHQtdGVzdCwgd2UgY2FuIGFsc28ganVzdCBtYWtlIHVzZSBvZiB0aGUgZmFjdCB0aGF0LCBpbiB0aGUgZW5kLCB3ZSBhcmUgdGVzdGluZyB3aGV0aGVyIHRoZSBfX2RpZmZlcmVuY2VfXyBiZXR3ZWVuIHBvc3QtIGFuZCBwcmUtbWVhc3VyZXMgaXMgZGlmZmVyZW50IGZyb20gMC4gDQpJbiB0aGlzIGNhc2UsIHRoZSBjb3JyZWxhdGlvbiBiZXR3ZWVuIHRoZSBwcmUgYW5kIHRoZSBwb3N0LW1lYXN1cmUgaXMgaW1wbGljaXRlbHkgaGFuZGxlZCB3aGVuIHN1YnN0cmFjdGluZyB0aGUgdHdvIG1lYXN1cmVzLiBUaGlzIHdheSwgd2UgZG8gbm90IG5lZWQgdG8gZGlyZWN0bHkgc3BlY2lmeSBpdC4gDQpJZiB0aGUgY29ycmVsYXRpb24gaXMgY2xvc2UgdG8gb25lLCB0aGUgc3RhbmRhcmQtZGV2aWF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIHNjb3JlcyB3aWxsIGJlIHZlcnkgc21hbGwsIGlmIGl0IGlzIHplcm8sIHdlIHdpbGwgZW5kIHVwIHdpdGggdGhlIHNhbWUgc2l0dWF0aW9uIHRoYXQgd2UgaGF2ZSBpbiB0aGUgaW5kZXBlbmRlbnQtc2FtcGxlIHQtdGVzdC4NClRodXMsIHdlIGNhbiBqdXN0IG1ha2UgdXNlIG9mIGEgb25lLXNhbXBsZSBpbiB3aGljaCB3ZSB0ZXN0IHdoZXRoZXIgdGhlIGRpc3RyaWJ1dGlvbiBvZiBkaWZmZXJlbmNlLXNjb3JlcyBkaWZmZXJzIGZyb20gemVybyBhcyB0aGUgcGFpcmVkIHQtdGVzdCBpcyBlcXVpdmFsZW50IHRvIHRoZSBvbmUtc2FtcGxlIHQtdGVzdCBvbiBkaWZmZXJlbmNlIHNjb3JlcyBbKHNlZSBMYWtlbnMsIDIwMTMgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGlzKV0oaHR0cHM6Ly93d3cubmNiaS5ubG0ubmloLmdvdi9wbWMvYXJ0aWNsZXMvUE1DMzg0MDMzMS8pLg0KDQpUaG91Z2ggdGhlIG9uZS1zYW1wbGUgYXBwcm9hY2ggaXMgZWFzaWVyIHRvIHNpbXVsYXRlLCBJIHdpbGwgZGVzY3JpYmUgYm90aCBhcHByb2FjaGVzIGluIHRoZSBmb2xsb3dpbmcgYXMgdGhlIGZpcnN0IGFwcHJvYWNoIChzaW11bGF0aW5nIGNvcnJlbGF0ZWQgbm9ybWFsLWRpc3RyaWJ1dGlvbnMpIGlzIG1vcmUgZmxleGlibGUgYW5kIHdlIG5lZWQgaXQgZm9yIHRoZSBzaXR1YXRpb25zIHdlIGRlYWwgd2l0aCBsYXRlci4NCg0KIyMjIFVzaW5nIGEgb25lLXNhbXBsZSB0LXRlc3QgYXBwcm9hY2gNCg0KV2hlbiB3ZSB3YW50IHRvIGRvIG91ciBwb3dlci1jYWxjdWxhdGlvbiBiYXNlZCBvbiB0aGUgb25lLXNhbXBsZSB0LXRlc3QgYXBwcm9hY2gsIHdlIG9ubHkgaGF2ZSB0byBzcGVjaWZ5IGEgc2luZ2xlIGRpZmZlcmVuY2Utc2NvcmUgZGlzdHJpYnV0aW9uLg0KV2UgY2FuIGRvIHRoaXMgYWdhaW4sIGJhc2VkIG9uIHRoZSAkQ29oZW4nc1wgZCQgZm9ybXVsYSwgdGhpcyB0aW1lIGZvciBhIG9uZS1zYW1wbGUgc2NlbmFyaW86DQoNCiQkIENvaGVuJ3NcIGQgPSBcZnJhY3tNX3tkaWZmfSAtIFxtdV8wfXtTRF97ZGlmZn19JCQNCg0KSW4gdGhlIGFib3ZlIGZvcm11bGEsIHRvIGdldCBvdXIgdmFsdWVzIGZvciB0aGUgc2ltdWxhdGlvbiB3ZSBjYW4gc3Vic3RpdHV0ZSB0aGUgJFxtdV8wJCBieSAwIChhcyBvdXIgbnVsbC1oeXBvdGhlc2lzIGlzIG5vIGRpZmZlcmVuY2UpIGFuZCBzb2x2ZSB0aGUgZXF1YXRpb24gaW4gdGhlIHNhbWUgd2F5IGFzIGFib3ZlIGJ5IGZpeGluZyB0aGUgbWVhbi1kaWZmZXJlbmNlIGJldHdlZW4gcHJlLSBhbmQgcG9zdC1tZWFzdXJlLCAkTV97ZGlmZn0kIHRvIDEgYW5kIGNhbGN1bGF0aW5nIHRoZSBzZCB3ZSBuZWVkIGZvciBlYWNoIGdpdmVuICRDb2hlbidzXCBkJCwgZm9yIGluc3RhbmNlDQoNCiQkIDAuNSA9IFxmcmFjezF9e1NEX3tkaWZmfX0kJA0KDQpwdXR0aW5nIHRoaXMgaW50byBgUmBzIGBzb2x2ZWAgZnVuY3Rpb24gYWdhaW4sIHdlIHVuc3VycHJpc2luZ2x5IGdldCBhIDIgaW4gdGhpcyBjYXNlLg0KDQpgYGB7ciB9DQpzb2x2ZSgwLjUsIDEpDQpgYGANCg0KVG8gcnVuIG91ciBzaW11bGF0aW9uIHdlIGp1c3QgbmVlZCB0byBtb2RpZnkgdGhlIGNvZGUgYWJvdmUgdG8gcnVuIGEgb25lLXNhbXBsZSB0LXRlc3QgcmF0aGVyIHRoYW4gYSB0d28tc2FtcGxlIHQtdGVzdCBhbmQgY2hhbmdlIHRoZSBmb3JtdWxhIGZvciAkQ29oZW4nc1wgZCQNCg0KYGBge3IgdC10ZXN0X29zdH0NCnNldC5zZWVkKDEpDQpuX3NpbXMgPC0gMTAwMCAjIHdlIHdhbnQgMTAwMCBzaW11bGF0aW9ucw0KcF92YWxzIDwtIGMoKQ0KcG93ZXJfYXRfbiA8LSBjKDApICMgdGhpcyB2ZWN0b3Igd2lsbCBjb250YWluIHRoZSBwb3dlciBmb3IgZWFjaCBzYW1wbGUtc2l6ZSAoaXQgbmVlZHMgdGhlIGluaXRpYWwgMCBmb3IgdGhlIHdoaWxlLWxvb3AgdG8gd29yaykNCmNvaGVuc19kcyA8LSBjKCkNCmNvaGVuc19kc19hdF9uIDwtIGMoKSANCm4gPC0gMiAjIHNhbXBsZS1zaXplIA0KaSA8LSAyDQp3aGlsZShwb3dlcl9hdF9uW2ktMV0gPCAuOTUpew0KICBmb3Ioc2ltIGluIDE6bl9zaW1zKXsNCiAgICBkaWZmZXJlbmNlIDwtIHJub3JtKG4sMSwyKSAjIHNpbXVsYXRlIHRoZSBkaWZmZXJlbmNlIHNjb3JlIGRpc3RyaWJ1dGlvbg0KICAgIHBfdmFsc1tzaW1dIDwtIHQudGVzdChkaWZmZXJlbmNlLCBtdSA9IDAsIGNvbmYubGV2ZWwgPSAwLjkwKSRwLnZhbHVlICMgcnVuIHQtdGVzdCBhbmQgZXh0cmFjdCB0aGUgcC12YWx1ZQ0KICAgIGNvaGVuc19kc1tzaW1dIDwtIG1lYW4oZGlmZmVyZW5jZSkvc2QoZGlmZmVyZW5jZSkgIyB3ZSBhbHNvIHNhdmUgdGhlIGNvaGVucyBkcyB0aGF0IHdlIG9ic2VydmVkIGluIGVhY2ggc2ltdWxhdGlvbiANCiAgfQ0KICAgIHBvd2VyX2F0X25baV0gPC0gbWVhbihwX3ZhbHMgPCAuMTApICMgY2hlY2sgcG93ZXIgKGkuZS4gcHJvcG9ydGlvbiBvZiBwLXZhbHVlcyB0aGF0IGFyZSBzbWFsbGVyIHRoYW4gYWxwaGEtbGV2ZWwgb2YgLjEwKQ0KICAgIGNvaGVuc19kc19hdF9uW2ldIDwtIG1lYW4oY29oZW5zX2RzKSAjIGNhbGN1bGF0ZSBtZWFucyBvZiBjb2hlbnMgZHMgZm9yIGVhY2ggc2FtcGxlLXNpemUNCiAgICBuIDwtIG4rMSAjIGluY3JlYXNlIHNhbXBsZS1zaXplIGJ5IDENCiAgICBpIDwtIGkrMSAjIGluY3JlYXNlIGluZGV4IG9mIHRoZSB3aGlsZS1sb29wIGJ5IDEgdG8gc2F2ZSBwb3dlciBhbmQgY29oZW5zIGQgdG8gdmVjdG9yDQp9DQpwb3dlcl9hdF9uIDwtIHBvd2VyX2F0X25bLTFdICMgZGVsZXRlIGZpcnN0IDAgZnJvbSB0aGUgdmVjdG9yDQpjb2hlbnNfZHNfYXRfbiA8LSBjb2hlbnNfZHNfYXRfblstMV0gIyBkZWxldGUgZmlyc3QgTkEgZnJvbSB0aGUgdmVjdG9yDQpgYGANCg0KV2Ugc2VlIHRoYXQgdGhlIGxvb3Agc3RvcHBlZCBhdCBgbmAgPSBgciBuYCBzbyB0aGUgc2FtcGxlIHNpemUgd2UgbmVlZCBpcyBgbi0xYCA9IGByIG4tMWANCg0KV2UgY2FuIHBsb3QgdGhlIHBvd2VyLWN1cnZlIGFnYWluDQoNCmBgYHtyIHBsb3RfcG93ZXJfb3N0fQ0KcGxvdCgyOihuLTEpLCBwb3dlcl9hdF9uLCB4bGFiID0gIk51bWJlciBvZiBwYXJ0aWNpcGFudHMgcGVyIGdyb3VwIiwgeWxhYiA9ICJQb3dlciIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBUUlVFKQ0KYWJsaW5lKGggPSAuOTUsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCmFuZCB0aGUgJENvaGVuJ3NcIGQkIHZhbHVlczoNCg0KYGBge3IgcGxvdF9jb2hlbnNkX29zdH0NCnBsb3QoMjoobi0xKSwgY29oZW5zX2RzX2F0X24sIHhsYWIgPSAiTnVtYmVyIG9mIHBhcnRpY2lwYW50cyBwZXIgZ3JvdXAiLCB5bGFiID0gIkNvaGVucyBEIiwgeWxpbSA9IGMoMC4wLDEuMCksIGF4ZXMgPSBUUlVFKQ0KYWJsaW5lKGggPSAuNTAsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCldlIHNlZSBhZ2FpbiwgYW5kIHRoaXMgdGltZSBtb3JlIGRyYW1hdGljYWxseSwgaG93IG91ciBzaW11bGF0ZWQgZWZmZWN0IHNpemUgYmVjb21lcyBtb3JlIGFjY3VyYXRlIHRoZSBiaWdnZXIgb3VyIHNhbXBsZSBnZXRzLg0KDQoNCiMjIyBVc2luZyBhIGNvcnJlbGF0ZWQtc2FtcGxlcyBwYWlyZWQgdC10ZXN0IGFwcHJvYWNoDQoNCg0KIyMjIyBUaGUgcmVsYXRpb25zaGlwIGJldHdlZW4gJFNEX3tkaWZmfSQgYW5kIHRoZSBjb3JyZWxhdGlvbg0KDQpJbiB0aGUgYWJvdmUgZXhhbXBsZSwgd2UgcmVzcGVjaWZpZWQgYSBwYWlyZWQgdC10ZXN0IGFzIGEgb25lLXNhbXBsZSB0LXRlc3Qgb24gdGhlIGRpZmZlcmVuY2Ugc2NvcmVzLg0KSG93ZXZlciwgd2hhdCB3ZSBhcmUgYWN0dWFsbHkgd29ya2luZyB3aXRoIGlzIHR3byBfY29ycmVsYXRlZF8gZGlzdHJpYnV0aW9ucyBvZiBtZWFzdXJlbWVudHMuDQpUbyBkZW1vbnN0cmF0ZSB0aGlzIHBvaW50LCBsZXQgdXMgaGF2ZSBhIGxvb2sgYXQgaG93IHdlIHdvdWxkIGFjdHVhbGx5IGNhbGN1bGF0ZSB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIHNjb3JlcyAoJFNEX3tkaWZmfSQpIGluIHRoZSBhYm92ZSBlcXVhdGlvbiBmb3IgJENvaGVuJ3NcIGQkLg0KVGhlIGZvcm11bGEgdG8gY2FsY3VsYXRlICRTRF97ZGlmZn0kIGZyb20gdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgdHdvIG1lYXN1cmVtZW50cyAocHJlIGFuZCBwb3N0KSBhbmQgdGhlaXIgY29ycmVsYXRpb24gaXM6DQoNCiQkU0Rfe2RpZmZ9ID0gXHNxcnR7U0Rfe3ByZX1eMitTRF97cG9zdH1eMi0yciBcdGltZXMgU0Rfe3ByZX0gXHRpbWVzIFNEX3twb3N0fX0gJCQNCg0KSXQgaXMgbm90IGltcG9ydGFudCBhdCB0aGlzIHBvaW50IHRvIHVuZGVyc3RhbmQgd2h5IHRoaXMgaXMgdGhlIGNhc2UgKHdlIHdpbGwganVzdCB0cnVzdCBbQ29oZW5dKGh0dHA6Ly93d3cudXRzdGF0LnRvcm9udG8uZWR1L35icnVubmVyL29sZGNsYXNzLzM3OGYxNi9yZWFkaW5ncy9Db2hlblBvd2VyLnBkZikgb24gdGhpcykgYnV0IHNlZSBob3cgd2UgY2FuLCBmb3IgYW55IGdpdmVuICRTRF97ZGlmZn0kIGFuZCBhc3N1bWluZyBib3RoIGdyb3VwcyBoYXZlLCBmb3IgZXhhbXBsZSwgYSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgMiwgc29sdmUgdGhlIGZvcm11bGEgdG8gc2VlIHdoYXQgY29ycmVsYXRpb24gKHRoZSAkciQgaW4gdGhlIGFib3ZlIGZvcm11bGEpIGl0IHdvdWxkIGltcGx5Lg0KDQoNCkltYWdpbmUsIGZvciBpbnN0YW5jZSwgd2UgYXNzdW1lIChsaWtlIGluIHRoZSBpbmRlcGVuZGVudC1zYW1wbGVzIHQtdGVzdCBhYm92ZSkgdGhhdCBib3RoIG1lYXN1cmVzIGhhdmUgYSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgMiBhbmQgdGhhdCB0aGUgc3RhbmRhcmQtZGV2aWF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIHNjb3JlcyB3b3VsZCBhbHNvIGJlIDIgc28gdGhhdCB3ZSB3b3VsZCBoYXZlIHRoZSBzYW1lIHNpdHVhdGlvbiBhcyBpbiB0aGUgb25lLXNhbXBsZSB0LXRlc3QgZXhhbXBsZSBhYm92ZSwgd2hlcmUgd2UgaGFkIGEgbWVhbi1kaWZmZXJlbmNlIG9mIDEgYW5kIGEgZGlmZmVyZW5jZS1zY29yZSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgMi4NCg0KRmlsbGluZyB0aGlzIGluIHdlIGdldCANCg0KJCQyID0gXHNxcnR7Ml4yKzJeMi0yciBcdGltZXMgMiBcdGltZXMgMn0gJCQNCg0KU29sdmluZyB0aGlzIGVxdWF0aW9uIGZvciAkciQsIHdlIGdldFteMl0gJHIgPSAwLjUkOg0KDQpUaGVyZWZvcmUsIGludGVyZXN0aW5nbHkgdGhlIHNpdHVhdGlvbiBpbiB3aGljaCB3ZSB1c2UgdGhlIHNhbWUgZ3JvdXBzIGFzIGFib3ZlIGFuZCBhc3N1bWUgdGhhdCB3ZSB3b3VsZCBnZXQgdGhlIHNhbWUgJFNEX3tkaWZmfSQgb2YgMiBhcyB3ZSBhc3N1bWVkIGluIG91ciBvbmUtc2FtcGxlIHNpdHVhdGlvbiB3b3VsZCBpbXBseSB0aGF0IHRoZSBjb3JyZWxhdGlvbiBiZXR3ZWVuIHRoZSBwcmUtIGFuZCB0aGUgcG9zdC1tZWFzdXJlIGlzICRyID0gMC41JC4NCldoYXQgZG9lcyB0aGlzIG1lYW4/IA0KV2VsbCwgbGV0cyBzZWUgd2hhdCBoYXBwZW5zIGlmIHdlIGFzc3VtZSBhIGNvcnJlbGF0aW9uIG9mICRyID0gLjkwJCBhbmQgc2VlIHdoYXQgJFNEX3tkaWZmfSQgd2UgZ2V0Og0KDQokJFNEX3tkaWZmfSA9IFxzcXJ0ezJeMisyXjItMiBcdGltZXMgMC45MCBcdGltZXMgMiBcdGltZXMgMn0gJCQNCg0KU29sdmluZyB0aGlzIGluIGBSYCBnaXZlcyB1czogYHNxcnQoMl4yKzJeMi0yKjAuOSoyKjIpYCA9IGByIHJvdW5kKHNxcnQoMl4yKzJeMi0yKjAuOSoyKjIpLCAyKWAuDQpUaHVzLCBpZiB0aGUgY29ycmVsYXRpb24gaW5jcmVhc2VzIHRoZSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgdGhlIGRpZmZlcmVuY2Utc2NvcmVzIGJlY29tZXMgc21hbGxlci4gDQpJZiB3ZSBkbyB0aGUgc2FtZSB3aXRoIGEgY29ycmVsYXRpb24gb2YgLjEwIHdlIGdldCBgc3FydCgyXjIrMl4yLTIqMC4xKjIqMilgID0gYHIgcm91bmQoc3FydCgyXjIrMl4yLTIqMC4xKjIqMiksIDIpYC4NClRodXMsIHdoZW4gdGhlIGNvcnJlbGF0aW9uIGRlY3JlYXNlcyB0aGUgc3RhbmRhcmQtZGV2aWF0aW9uIGJlY29tZXMgYmlnZ2VyLg0KSW50ZXJlc3RpbmdseSwgdGhpcyBkZW1vbnN0cmF0ZXMgdGhhdCBmb3IgdGhlIHNhbWUgbWVhbi1kaWZmZXJlbmNlLCBhIGhpZ2ggY29ycmVsYXRpb24gcmVzdWx0cyBpbiBhIF9sYXJnZXJfICRDb2hlbidzXCBkJCBhcyBjYWxjdWxhdGVkIGZvciB0aGUgZGlmZmVyZW5jZSBzY29yZXMgaW4gdGhlIG9uZS1zYW1wbGUgY2FzZS4NCkluIG90aGVyIHdvcmRzLCBhcyB0aGUgcHJlLXNjb3JlcyB0ZW5kIHRvIGJlIG1vcmUgc2ltaWxhciB0byB0aGUgcG9zdC1zY29yZXMgKGkuZS4gdGhleSBoYXZlIGEgaGlnaCBjb3JyZWxhdGlvbiksIHRoZSBzdGFuZGFyZC1kZXZpYXRpb24gb2YgdGhlIGRpZmZlcmVuY2Ugc2NvcmVzIGRlY3JlYXNlcy4NClRoaXMsIGluIHR1cm4sIHJlc3VsdHMgaW4gaGlnaGVyIHBvd2VyIHRvIGRldGVjdCBhbiBlZmZlY3QuDQoNCg0KVG8gc3VtIHVwIGFsbCBvZiB0aGUgYWJvdmUsIHdlIGNhbiBlaXRoZXIgc3BlY2lmeSBhIGRpZmZlcmVuY2Utc2NvcmUgZGlzdHJpYnV0aW9uIGRpcmVjdGx5IGFuZCB0aGVyZWJ5IGltcGx5IGEgY2VydGFpbiBjb3JyZWxhdGlvbiBieSBzcGVjaWZ5aW5nIHRoZSAkU0Rfe2RpZmZ9JCwgb3Igd2UgY2FuIHNlZSB3aGF0ICRTRF97ZGlmZn0kIHdlIGdldCB3aXRoIGEgY2VydGFpbiBjb3JyZWxhdGlvbiBieSB1c2luZyB0aGUgZm9ybXVsYSBhYm92ZSBhbmQgdXNlIHRoZSByZXN1bHQgZm9yIHRoZSBvbmUtc2FtcGxlIHNpbXVsYXRpb24uDQpIb3dldmVyLCBpbnN0ZWFkIG9mIHdvcmtpbmcgd2l0aCB0aGUgb25lLXNhbXBsZSB0LXRlc3QsIGluIHRoZSBuZXh0IHNlY3Rpb24sIHdlIHdpbGwgc2VlIGhvdyB3ZSBjYW4gZGlyZWN0bHkgc2ltdWxhdGUgY29ycmVsYXRlZCBub3JtYWwtZGlzdHJpYnV0aW9ucyBpbiBgUmAuDQoNCg0KIyMjIyBTaW11bGF0aW5nIGNvcnJlbGF0ZWQgbm9ybWFsLWRpc3RyaWJ1dGlvbnMgYW5kIGRlbXlzdGlmeWluZyB0aGUgbXVsdGl2YXJpYXRlIG5vcm1hbC4NCg0KSW4gcmVhbCBsaWZlLCBhbG1vc3QgZXZlcnl0aGluZyBpcyBjb3JyZWxhdGVkIHRvIHNvbWUgZGVncmVlLiANClRob3VnaCB0aGVzZSBjb3JyZWxhdGlvbnMgYXJlIG9mdGVuIG5vdCBvZiBpbnRlcmVzdCwgdGhleSBzb21ldGltZXMgYXJlIGFuZCBpbiBhIGdvb2Qgc2ltdWxhdGlvbiB3ZSB3YW50IHRvIGFja25vd2xlZGdlIHRoZW0uIEZvciBpbnN0YW5jZSwgcHJlZGljdG9ycyBpbiBhIHJlZ3Jlc3Npb24gbWlnaHQgYmUgY29ycmVsYXRlZCBvciByYW5kb20gZWZmZWN0cyBpbiBhIG1peGVkLW1vZGVsLg0KDQpUaGUgZm9sbG93aW5nIHBhcnQgaXMgKGFnYWluKSBsb25nZXIgdGhhbiBJIGludGVuZGVkIGJ1dCBJIGZlZWwgdGhhdCBpdCBpcyBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCBob3cgd2Ugc2ltdWxhdGUgY29ycmVsYXRlZCBub3JtYWwtZGlzdHJpYnV0aW9ucyBhbmQgd2hhdCBhIG11bHRpdmFyaWF0ZSBub3JtYWwtZGlzdHJpYnV0aW9uIGlzLiANCkluIG1vc3QgY2FzZXMgbGF0ZXIgb24gd2Ugd2lsbCBkZWFsIHdpdGggc29tZSBraW5kIG9mIGNvcnJlbGF0ZWQgbm9ybWFsIGRpc3RyaWJ1dGlvbnMgKGluIG1peGVkLW1vZGVscyB3ZSB3aWxsIGFsd2F5cyBlbmNvdW50ZXIgdGhlbSBmb3IgZXhhbXBsZSkgc28gSSB0aGluayBpdCBoZWxwcyBpZiB3ZSBoYXZlIGEgbG9vayBhdCB0aGVtIG5vdyBpbiBhbiBlYXNpZXIgZXhhbXBsZSwgc28gd2UgaGF2ZSBvbmUgcHJvYmxlbSBsZXNzIHRvIHdvcnJ5IGFib3V0IGxhdGVyIG9uLg0KDQpSZXBocmFzaW5nIHRoZSBwcm9ibGVtIG9mIHNpbXVsYXRpbmcgdHdvIGNvcnJlbGF0ZWQgbm9ybWFsLWRpc3RyaWJ1dGlvbnMsIHdlIGNhbiBzYXkgdGhhdCB3ZSB3YW50IHRvIHNpbXVsYXRlIGEgX211bHRpdmFyaWF0ZSBub3JtYWwgZGlzdHJpYnV0aW9uXyBvciwgbW9yZSBzcGVjaWZpY2FsbHkgaW4gdGhpcyBjYXNlLCBhIF9iaXZhcmlhdGUgbm9ybWFsIGRpc3RyaWJ1dGlvbl8uIA0KSWYgeW91IG5ldmVyIGhlYXJkIHRoZXNlIHRlcm1zIGJlZm9yZSwgdGhleSBtaWdodCBzZWVtIHZlcnkgb3BhZ3VlLCBzbyBsZXQncyBzZWUgd2hhdCB0aGV5IGFyZS4NCkkgd2lsbCBmaXJzdCBzaG93IGhvdyB3ZSBjYW4gc2ltdWxhdGUgdGhlbSwgYW5kIGV4cGxhaW4gd2hhdCBleGFjdGx5IHRoaXMgbXVsdGl2YXJpYXRlIG5vcm1hbCBkaXN0cmlidXRpb24gbWVhbnMgYWZ0ZXJ3YXJkcyB3aXRoIGEgbGl0dGxlIHZpc3VhbCBpbnR1aXRvbi4NCldlIGNhbiBzaW11bGF0ZSBhIG11bHRpdmFyaWF0ZSBub3JtYWwgZGlzdHJpYnV0aW9uIGJ5IHVzaW5nIHRoZSBgbXZybm9ybSgpYCBmdW5jdGlvbiBmcm9tIHRoZSBgTUFTU2AgcGFja2FnZSBidXQgaXQgd29ya3Mgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gdGhlIHNpbXVsYXRpb24gZnVuY3Rpb25zIHRoYXQgd2UgaGF2ZSB1c2VkIHNvIGZhciAoYHJub3JtYCBhbmQgYHJiaW5vbWApLg0KTGV0cyBoYXZlIGEgbG9vayBhdCBob3cgdGhpcyB3b3JrcyAoY29kZSBleHBsYWluZWQgYmVsb3cpLg0KDQpgYGB7ciBzaW1fYml2bm9ybX0NCnJlcXVpcmUoTUFTUykgIyBsb2FkIE1BU1MgcGFja2FnZQ0KDQpwcmVfcG9zdF9tZWFucyA8LSBjKHByZSA9IDAscG9zdCA9IDEpICMgZGVmaW5lIG1lYW5zIG9mIHByZSBhbmQgcG9zdCBpbiBhIHZlY3Rvcg0KcHJlX3NkIDwtIDIgIyBkZWZpbmUgc2Qgb2YgcHJlLW1lYXN1cmUNCnBvc3Rfc2QgPC0gMiAjIGRlZmluZSBzZCBvZiBwb3N0LW1lYXN1cmUNCmNvcnJlbGF0aW9uIDwtIDAuNSAjIGRlZmluZSB0aGVpciBjb3JyZWxhdGlvbg0KDQpzaWdtYSA8LSBtYXRyaXgoYyhwcmVfc2ReMiwgcHJlX3NkKnBvc3Rfc2QqY29ycmVsYXRpb24sIHByZV9zZCpwb3N0X3NkKmNvcnJlbGF0aW9uLCBwb3N0X3NkXjIpLCBuY29sID0gMikgIyBkZWZpbmUgdmFyaWFuY2UtY292YXJpYW5jZSBtYXRyaXgNCg0Kc2V0LnNlZWQoMSkNCmJpdm5vcm0gPC0gZGF0YS5mcmFtZShtdnJub3JtKDEwMDAwLCBwcmVfcG9zdF9tZWFucywgc2lnbWEpKSAjIHNpbXVsYXRlIGJpdmFyaWF0ZSBub3JtYWwNCg0KYGBgDQoNClRoZSBhYm92ZSBjb2RlIHNhbXBsZXMgMTAsMDAwIG9ic2VydmF0aW9ucyBmcm9tIGEgYml2YXJpYXRlIG5vcm1hbC1kaXN0cmlidXRpb24sIG9yIGluIHRlcm1zIG9mIG91ciBleGFtcGxlLCBpdCBzYW1wbGVzIDEwLDAwMCBwcmUtbWVhc3VyZXMgd2l0aCAxMCwwMDAgY29ycmVsYXRlZCBwb3N0LW1lYXN1cmVzLg0KVGhlIGZpcnN0IHRoaW5nIHRoYXQgaXMgZGlmZmVyZW50IGZyb20gb3VyIGVhcmxpZXIgc2ltdWxhdGlvbnMgaXMgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGNvZGUgYHByZV9wb3N0X21lYW5zIDwtIGMoMCwxKWAuIA0KSW5zdGVhZCBvZiBkZWZpbmluZyBvdXIgbWVhbnMgc2VwZXJhdGVseSBmb3IgZWFjaCBtZWFzdXJlbWVudCwgYXMgd2UgaGF2ZSBkb25lIGVhcmxpZXIgaW4gdGhlIGluZGVwZW5kZW50LXNhbXBsZSBjYXNlLCB3ZSBub3cgcHV0IHRoZSBwcmUtIGFuZCBwb3N0LW1lYXN1cmVtZW50IG1lYW4gdGhhdCB3ZSBhc3N1bWUgaW50byBhIHZlY3Rvci4NClRoaXMgaXMgYmVjYXVzZSB3ZSB3aWxsIHNpbXVsYXRlIGJvdGggbWVhc3VyZW1lbnRzIHRvZ2V0aGVyIGluIHRoZSBgbXZybm9ybWAgZnVuY3Rpb24sIGFuZCB0aGVyZWZvcmUgYm90aCBtZWFucyBuZWVkIHRvIGJlIHByb3ZpZGVkIGF0IHRoZSBzYW1lIHRpbWUuDQoNClNlY29uZGx5LCB3ZSBkZWZpbmUgdGhlIHN0YW5kYXJkLWRldmlhdGlvbnMgb2YgYm90aCBtZWFzdXJlbWVudHMganVzdCBhcyB3ZSBkaWQgZWFybGllciBhbmQgYWxzbyBzcGVjaWZ5IGEgY29ycmVsYXRpb24gdGhhdCB3ZSB3b3VsZCBsaWtlIG91ciBkYXRhLXBvaW50cyB0byBoYXZlLCBpbiB0aGlzIGNhc2UgMC41Lg0KDQpOb3csIHRoZSBsaW5lIGBtYXRyaXgoYyhwcmVfc2ReMiwgcHJlX3NkKnBvc3Rfc2QqY29ycmVsYXRpb24sIHByZV9zZCpwb3N0X3NkKmNvcnJlbGF0aW9uLCBwb3N0X3NkXjIpLCBuY29sID0gMilgIGRvZXMgc29tZXRoaW5nIHRoYXQgd2UgaGF2ZSBub3QgZG9uZSBiZWZvcmUgYW5kIGl0IG1pZ2h0IGxvb2sgcXVpdGUgY29uZnVzaW5nLg0KV2hhdCB3ZSBhcmUgZG9pbmcgaGVyZSBpcyBzcGVjaWZ5aW5nIHRoZSBfdmFyaWFuY2UtY292YXJpYW5jZSBtYXRyaXhfLiANClRoaXMgaXMgbm90aGluZyBtb3JlIHRoYW4gYSB0YWJsZSBjb250YWluaW5nIHRoZSB2YXJpYW5jZXMgb2Ygb3VyIHByZS0gYW5kIHBvc3QtbWVhc3VyZW1lbnQgKHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgZW50cnkgaW4gdGhlIGxpc3QpIGFuZCB0aGUgY292YXJpYW5jZSBiZXR3ZWVuIHRoZSB0d28gdmFyaWFibGVzIHR3aWNlIC0gb25jZSBmb3IgZWFjaCBtZWFzdXJlbWVudCAodGhlIG1pZGRsZSAyIGVudHJpZXMgaW4gdGhlIGxpc3QpLg0KQ29uY2VwdHVhbGx5IHlvdSBjYW4gc2VlIHRoaXMgdmFyaWFuY2UtY292YXJpYW5jZSBtYXRyaXggYXMgdGhlIHN0YW5kYXJkLWRldmlhdGlvbiBvZiB0aGUgbXVsdGl2YXJpYXRlIG5vcm1hbCB0aGF0IGBtdnJub3JtYCBuZWVkcyBpbnN0ZWFkIG9mIHRoZSBzdGFuZGFyZC1kZXZpYXRpb24gdGhhdCB3ZSBwdXQgaW50byBgcm5vcm1gIGVhcmxpZXIuDQoNCldlIGNhbiB2aXN1YWxpemUgdGhlIHZhcmlhbmNlLWNvdmFyaWFuY2UgbWF0cml4IGBzaWdtYWAgdG8gZGVteXN0aWZ5IGl0IGEgYml0Lg0KDQpgYGB7ciB0YWJsZV9zaWdtYX0NCmNvbG5hbWVzKHNpZ21hKSA8LSBjKCJwcmUiLCAicG9zdCIpDQpyb3duYW1lcyhzaWdtYSkgPC0gYygicHJlIiwgInBvc3QiKQ0Kc2lnbWENCmBgYA0KDQpUaHVzLCB0aGlzIG1hdHJpeCBpcyBub3RoaW5nIG1vcmUgdGhhbiBhIHRhYmxlIGNvbnRhaW5pbmcgdGhlIHZhcmlhbmNlIG9mIGVhY2ggdmFyaWFibGUgKDQgaW4gZWFjaCBjYXNlKSBhbmQgdGhlaXIgY292YXJpYW5jZSAoaS5lLiB0aGUgY29ycmVsYXRpb24gb2YgdGhlIHR3byBtdWx0aXBsaWVkIGJ5IGJvdGggc3RhbmRhcmQtZGV2aWF0aW9ucyAoJENvdihwcmUscG9zdCkgPSBccmhvKHByZSxwb3N0KSpzZF97cHJlfSpzZF97cG9zdH0kKS4NCg0KSW4gdGhlIG5leHQgbGluZSBvZiB0aGUgY29kZSB3ZSBwdXQgdGhpcyBhbGwgaW50byBgbXZybm9ybWAgdG8gc2ltdWxhdGUgb3VyIGJpdmFyaWF0ZSBub3JtYWwgZGlzdHJpYnV0aW9uIGFuZCBzdG9yZSB0aGUgcmVzdWx0cyBpbiBhIGRhdGEtZnJhbWUgd2l0aCAyIGNvbHVtbnMsIGVhY2ggY29udGFpbmluZyBvbmUgbWVhc3VyZW1lbnQgcG9pbnQ6DQoNCmBgYHtyIGJpdmFyX2RhdH0NCmhlYWQoYml2bm9ybSkNCmBgYA0KDQpXaGVuIHdlIHJ1biBgY29yKGJpdm5vcm0kcHJlLCBiaXZub3JtJHBvc3QpYCB3ZSBzZWUgdGhhdCBpbmRlZWQgdGhlaXIgY29ycmVsYXRpb24gaXMgYHIgcm91bmQoY29yKGJpdm5vcm0kcHJlLCBiaXZub3JtJHBvc3QpLCAyKWAgYW5kIGNsb3NlIHRvIHdoYXQgd2Ugc3BlY2lmaWVkLg0KDQpUbyBzZWUgaG93IHdlIGNhbiBpbWFnaW5lIHN1Y2ggYSBiaXZhcmlhdGUgbm9ybWFsIGRpc3RyaWJ1dGlvbiwgd2UgY2FuIHZpc3VhbGl6ZSBpdCB0aGUgZm9sbG93aW5nIHdheS4NCg0KSWYgd2UgZHJhdyBhIGhpc3RvZ3JhbSBvZiBlYWNoIG1lYXN1cmVtZW50IGluZGl2aWR1YWxseSwgaXQgbG9va3MgbGlrZSB0aGlzLg0KDQpgYGB7ciBwbG90X2Jpdm5vcm0xfQ0KcGFyKG1mcm93PWMoMSwyKSkNCmhpc3QoYml2bm9ybSRwcmUsIG1haW4gPSAicHJlLW1lYXN1cmUiKQ0KaGlzdChiaXZub3JtJHBvc3QsIG1haW4gPSAicG9zdC1tZWFzdXJlIikNCmBgYA0KDQpIb3dldmVyLCBpbWFnaW5lIHdlIHdvdWxkIG5vdCBvbmx5IGxvb2sgYXQgZWFjaCBoaXN0b2dyYW0gc2VwZXJhdGVseSBidXQgd2Ugd291bGQgY29tYmluZSB0aGVtIGludG8gb25lIHBsb3QgYnkgcHV0dGluZyB0aGUgcHJlLW1lYXN1cmUgc2NvcmVzIG9mIGVhY2ggc2ltdWxhdGVkIGluZGl2aWR1YWwgb24gdGhlIHgtYXhpcyBhbmQgcHV0dGluZyB0aGUgcG9zdC1tZWFzdXJlcyBvbiB0aGUgeS1heGlzIGxpa2UgdGhpczoNCg0KYGBge3IgcGxvdF9iaXZub3JtMn0NCnBsb3QoYml2bm9ybSRwcmUsIGJpdm5vcm0kcG9zdCwgeGxhYiA9ICJwcmUtbWVhc3VyZSIsIHlsYWIgPSAicG9zdC1tZWFzdXJlIikNCmBgYA0KDQoNCkluIHRoZSBhYm92ZSBwbG90LCB3ZSBjYW4gY2xlYXJseSBzZWUgdGhlIGNvcnJlbGF0aW9ucyBiZXR3ZWVuIHRoZSB0d28gbWVhc3VyZW1lbnRzIHRoYXQgd2UgcHV0IGluIHRoZSBkYXRhLiANCk1vcmUgZWxlZ2FudGx5LCB3ZSBjYW4gY29tYmluZSB0aGUgdHdvIGhpc3RvZ3JhbXMgaW4gdGhlIGZvbGxvd2luZyB3YXkuDQoNCmBgYHtyIHBsb3RfYml2bm9ybTN9DQpiaXZub3JtX2tkZSA8LSBrZGUyZChiaXZub3JtWywxXSwgYml2bm9ybVssMl0sIG4gPSA1MCkgIyBjYWxjdWxhdGUga2VybmVsIGRlbnNpdHkgKGkuZS4gdGhlICJoZWlnaHQgb2YgdGhlIGNvbmUgb24gdGhlIHotYXhpcyI7IG5vdCBzbyBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCBoZXJlKQ0KcGFyKG1hciA9IGMoMCwgMCwgMCwgMCkpICMgdGVsIHIgbm90IHRvIGxlYXZlIHNvIG11Y2ggc3BhY2UgYXJvdW5kIHRoZSBwbG90DQpwZXJzcChiaXZub3JtX2tkZSwgcGhpID0gNDUsIHRoZXRhID0gMzAsIHhsYWIgPSAicHJlLW1lYXN1cmUiLCB5bGFiID0gInBvc3QtbWVhc3VyZSIsIHpsYWIgPSAiZnJlcXVlbmN5IikgIyBwbG90IHRoZSBiaXZhcmlhdGUgbm9ybWFsDQpgYGANCg0KSGVyZSwgd2Ugc2VlIGNsZWFybHkgaG93IG91ciBiaXZhcmlhdGUgbm9ybWFsIGRpc3RyaWJ1dGlvbiBpcyBub3RoaW5nIG1vcmUgdGhhbiB0aGUgMiBub3JtYWwtZGlzdHJpYnV0aW9ucyBvZiBlYWNoIG1lYXN1cmVtZW50LXBvaW50IGNvbWJpbmVkIGludG8gb25lICJjb25lLXNoYXBlZCIgbm9ybWFsIGRpc3RyaWJ1dGlvbiB0aGF0IGhhcyBhIGNlcnRhaW4gY29ycmVsYXRpb24uDQoNClRoZSBwbG90IGJlbG93IHNob3dzIGhvdyB0aGlzIGNvbmUgbG9va3Mgd2l0aCBkaWZmZXJlbnQgY29ycmVsYXRpb25zLg0KDQoNCmBgYHtyIHBsb3RfYml2bm9ybV9jb3JzLCBlY2hvID0gRkFMU0UsIG91dC53aWR0aD0nMTIwJSd9DQpjb3IxMCA8LSAuMTANCnNpZ21hXzEwIDwtIG1hdHJpeChjKHByZV9zZF4yLCBwcmVfc2QqcG9zdF9zZCpjb3IxMCwgcHJlX3NkKnBvc3Rfc2QqY29yMTAsIHBvc3Rfc2ReMiksIG5jb2wgPSAyKQ0KYml2bm9ybV8xMCA8LSBtdnJub3JtKDFlNSwgcHJlX3Bvc3RfbWVhbnMsIHNpZ21hXzEwKQ0KYml2bm9ybTEwX2tkZSA8LSBrZGUyZChiaXZub3JtXzEwWywxXSwgYml2bm9ybV8xMFssMl0sIG4gPSA1MCkNCg0KDQpjb3I5MCA8LSAuOTANCnNpZ21hXzkwIDwtIG1hdHJpeChjKHByZV9zZF4yLCBwcmVfc2QqcG9zdF9zZCpjb3I5MCwgcHJlX3NkKnBvc3Rfc2QqY29yOTAsIHBvc3Rfc2ReMiksIG5jb2wgPSAyKQ0KYml2bm9ybV85MCA8LSBtdnJub3JtKDFlNSwgcHJlX3Bvc3RfbWVhbnMsIHNpZ21hXzkwKQ0KYml2bm9ybTkwX2tkZSA8LSBrZGUyZChiaXZub3JtXzkwWywxXSwgYml2bm9ybV85MFssMl0sIG4gPSA1MCkNCg0KcGFyKG1hciA9IGMoMSwgMCwgMSwgMCkpICMgdGVsbCByIG5vdCB0byBsZWF2ZSBzbyBtdWNoIHNwYWNlIGFyb3VuZCB0aGUgcGxvdA0KcGFyKG1mcm93PWMoMSwzKSkNCnBlcnNwKGJpdm5vcm0xMF9rZGUsIHBoaSA9IDQ1LCB0aGV0YSA9IDMwLCB4bGFiID0gInByZS1tZWFzdXJlIiwgeWxhYiA9ICJwb3N0LW1lYXN1cmUiLCB6bGFiID0gImZyZXF1ZW5jeSIsIG1haW4gPSAiY29ycmVsYXRpb24gPSAuMTAiKQ0KcGVyc3AoYml2bm9ybV9rZGUsIHBoaSA9IDQ1LCB0aGV0YSA9IDMwLCB4bGFiID0gInByZS1tZWFzdXJlIiwgeWxhYiA9ICJwb3N0LW1lYXN1cmUiLCB6bGFiID0gImZyZXF1ZW5jeSIsIG1haW4gPSAiY29ycmVsYXRpb24gPSAuNTAiKQ0KcGVyc3AoYml2bm9ybTkwX2tkZSwgcGhpID0gNDUsIHRoZXRhID0gMzAsIHhsYWIgPSAicHJlLW1lYXN1cmUiLCB5bGFiID0gInBvc3QtbWVhc3VyZSIsIHpsYWIgPSAiZnJlcXVlbmN5IiwgbWFpbiA9ICJjb3JyZWxhdGlvbiA9IC45MCIpDQoNCmBgYA0KDQpOb3RpY2UgaG93IGZvciBoaWdoZXIgY29ycmVsYXRpb25zLCB0aGUgY29uZSBiZWNvbWVzIG1vcmUgYW5kIG1vcmUgbmFycm93IGFuZCBzdGFydHMgbG9va2luZyBsaWtlIGEgInNoYXJrLWZpbiIgd2l0aCBhIGNvcnJlbGF0aW9uIG9mIC45MC4NClRoaXMgIm5hcnJvd3JpbmciIG9mIHRoZSBjb25lIGlzIHRoZSB2aXN1YWxpemF0aW9uIG9mIHdoeSB0aGUgc3RhbmRhcmQtZGV2aWF0aW9ucyBvZiB0aGUgZGlmZmVyZW5jZSBzY29yZXMgZ2V0IG1vcmUgbmFycm93LiANCg0KSWYgd2UgdmlzdWFsaXplIHRoaXMgYXMgYSBwb2ludCBjbG91ZCBhZ2FpbiB0aGUgdGhyZWUgY29ycmVsYXRpb25zIGxvb2sgbGlrZSB0aGlzOg0KDQpgYGB7ciBjb3JyZWxhdGlvbl9wb2ludHBsb3RzfQ0KYml2bm9ybV8xMCA8LSBhcy5kYXRhLmZyYW1lKGJpdm5vcm1fMTApDQpiaXZub3JtXzkwIDwtIGFzLmRhdGEuZnJhbWUoYml2bm9ybV85MCkNCnBhcihtZnJvdyA9IGMoMSwzKSkNCnBsb3QoYml2bm9ybV8xMCRwcmUsIGJpdm5vcm1fMTAkcG9zdCkNCnBsb3QoYml2bm9ybSRwcmUsIGJpdm5vcm0kcG9zdCkNCnBsb3QoYml2bm9ybV85MCRwcmUsIGJpdm5vcm1fOTAkcG9zdCkNCmBgYA0KDQpUaGlzIGFnYWluLCBjbGVhcmx5IHNob3dzIHRoZSBtYW5pcHVsYXRpbm8gYmV0d2VlbiB0aGUgcHJlLSBhbmQgcG9zdCBtZWFzdXJlcy4NCg0KIyMjIyBQb3dlci1hbmFseXNpcyB3aXRoIHRoZSBtdWx0aXZhcmlhdGUgbm9ybWFsDQoNCk5vdyB0aGF0IHdlIGtub3cgd2hhdCB3ZSBhcmUgZG9pbmcgd2hlbiB1c2luZyBgbXZybm9ybWAgd2UgY2FuIGdvIGFoZWFkIGFuZCBkbyBhIHBvd2VyLXNpbXVsYXRpb24gZm9yIHRoZSBleGFtcGxlIGFib3ZlIHdpdGggYSBiaXZhcmlhdGUgbm9ybWFsLWRpc3RyaWJ1dGlvbi4NCkhvd2V2ZXIsIGFzIHdlIGFyZSBub3Qgc3VyZSBob3cgYmlnIG91ciBjb3JyZWxhdGlvbiBpcywgd2UgY2FuIHRyeSAzIGRpZmZlcmVudCBjb3JyZWxhdGlvbnMgaW4gdGhlIGNvZGUgYWJvdmUgYnkgcGxhY2luZyB0aGUgc2ltdWxhdGlvbiBpbiBhbm90aGVyIGZvci1sb29wIGFuZCB0ZWxsaW5nIGl0IHRvIHRyeSBkaWZmZXJlbnQgY29ycmVsYXRpb25zLg0KDQpgYGB7ciBsYWJlbCwgb3B0aW9uc30NCm11X3ByZV9wb3N0IDwtIGMocHJlID0gMCwgcG9zdCA9IDEpDQpzZF9wcmUgPC0gMg0Kc2RfcG9zdCA8LSAyDQpjb3JyZWxhdGlvbnMgPC0gYygwLjEsIDAuNSwgMC45KQ0KDQpzZXQuc2VlZCgxKQ0Kbl9zaW1zIDwtIDEwMDAgIyB3ZSB3YW50IDEwMDAgc2ltdWxhdGlvbnMNCnBfdmFscyA8LSBjKCkNCiMgdGhpcyB2ZWN0b3Igd2lsbCBjb250YWluIHRoZSBwb3dlciBmb3IgZWFjaCBzYW1wbGUtc2l6ZSAoaXQgbmVlZHMgdGhlIGluaXRpYWwgMCBmb3IgdGhlIHdoaWxlLWxvb3AgdG8gd29yaykNCmNvaGVuc19kcyA8LSBjKCkNCg0KcG93ZXJzX2F0X2NvciA8LSBsaXN0KCkNCmNvaGVuc19kc19hdF9jb3IgPC0gbGlzdCgpDQoNCmZvcihpY29yIGluIDE6bGVuZ3RoKGNvcnJlbGF0aW9ucykpeyAjIGRvIGEgcG93ZXItc2ltdWxhdGlvbiBmb3IgZWFjaCBzcGVjaWZpZWQgc2ltdWxhdGlvbg0KICBuIDwtIDIgIyBzYW1wbGUtc2l6ZSANCiAgaSA8LSAyICMgaW5kZXggb2YgdGhlIHdoaWxlIGxvb3AgZm9yIHNhdmluZyB0aGluZ3MgaW50byB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIGxpc3RzDQogIHBvd2VyX2F0X24gPC0gYygwKSANCiAgY29oZW5zX2RzX2F0X24gPC0gYygpIA0KICBzaWdtYSA8LSBtYXRyaXgoYyhzZF9wcmVeMiwgc2RfcHJlKnNkX3Bvc3QqY29ycmVsYXRpb25zW2ljb3JdLCBzZF9wcmUqc2RfcG9zdCpjb3JyZWxhdGlvbnNbaWNvcl0sIHNkX3Bvc3ReMiksIG5jb2wgPSAyKSAjdmFyLWNvdmFyIG1hdHJpeA0KICB3aGlsZShwb3dlcl9hdF9uW2ktMV0gPCAuOTUpew0KICAgIGZvcihzaW0gaW4gMTpuX3NpbXMpew0KICAgICAgYml2bm9ybSA8LSBkYXRhLmZyYW1lKG12cm5vcm0obiwgbXVfcHJlX3Bvc3QsIHNpZ21hKSkgIyBzaW11bGF0ZSB0aGUgYml2YXJpYXRlIG5vcm1hbA0KICAgICAgcF92YWxzW3NpbV0gPC0gdC50ZXN0KGJpdm5vcm0kcHJlLCBiaXZub3JtJHBvc3QsIHBhaXJlZCA9IFRSVUUsIHZhci5lcXVhbCA9IFRSVUUsIGNvbmYubGV2ZWwgPSAwLjkpJHAudmFsdWUgIyBydW4gdC10ZXN0IGFuZCBleHRyYWN0IHRoZSBwLXZhbHVlDQogICAgICBjb2hlbnNfZHNbc2ltXSA8LSBhYnMoKG1lYW4oYml2bm9ybSRwcmUpLW1lYW4oYml2bm9ybSRwb3N0KSkvKHNxcnQoc2QoYml2bm9ybSRwcmUpXjIrc2QoYml2bm9ybSRwb3N0KV4yLTIqY29yKGJpdm5vcm0kcHJlLCBiaXZub3JtJHBvc3QpKnNkKGJpdm5vcm0kcHJlKSpzZChiaXZub3JtJHBvc3QpKSkpICMgd2UgYWxzbyBzYXZlIHRoZSBjb2hlbnMgZHMgdGhhdCB3ZSBvYnNlcnZlZCBpbiBlYWNoIHNpbXVsYXRpb24NCiAgICB9DQogICAgcG93ZXJfYXRfbltpXSA8LSBtZWFuKHBfdmFscyA8IC4xMCkgIyBjaGVjayBwb3dlciAoaS5lLiBwcm9wb3J0aW9uIG9mIHAtdmFsdWVzIHRoYXQgYXJlIHNtYWxsZXIgdGhhbiBhbHBoYS1sZXZlbCBvZiAuMTApDQogICAgbmFtZXMocG93ZXJfYXRfbilbaV0gPC0gbg0KICAgIGNvaGVuc19kc19hdF9uW2ldIDwtIG1lYW4oY29oZW5zX2RzKSAjIGNhbGN1bGF0ZSBtZWFucyBvZiBjb2hlbnMgZHMgZm9yIGVhY2ggc2FtcGxlLXNpemUNCiAgICBuYW1lcyhjb2hlbnNfZHNfYXRfbilbaV0gPC0gbg0KICAgIG4gPC0gbisxICMgaW5jcmVhc2Ugc2FtcGxlLXNpemUgYnkgMQ0KICAgIGkgPC0gaSsxICMgaW5jcmVhc2UgaW5kZXggb2YgdGhlIHdoaWxlLWxvb3AgYnkgMSB0byBzYXZlIHBvd2VyIGFuZCBjb2hlbnMgZCB0byB2ZWN0b3INCiAgfQ0KICBwb3dlcl9hdF9uIDwtIHBvd2VyX2F0X25bLTFdICMgZGVsZXRlIGZpcnN0IDAgZnJvbSB0aGUgdmVjdG9yDQogIGNvaGVuc19kc19hdF9uIDwtIGNvaGVuc19kc19hdF9uWy0xXSAjIGRlbGV0ZSBmaXJzdCBOQSBmcm9tIHRoZSB2ZWN0b3INCiAgcG93ZXJzX2F0X2NvcltbaWNvcl1dIDwtIHBvd2VyX2F0X24gIyBzdG9yZSB0aGUgZW50aXJlIHBvd2VyIGN1cnZlIGZvciB0aGlzIGNvcnJlbGF0aW9uIGluIGEgbGlzdA0KICBjb2hlbnNfZHNfYXRfY29yW1tpY29yXV0gPC0gY29oZW5zX2RzX2F0X24gIyBkbyB0aGUgc2FtZSBmb3IgY29oZW5zIGQNCiAgbmFtZXMocG93ZXJzX2F0X2NvcilbW2ljb3JdXSA8LSBjb3JyZWxhdGlvbnNbaWNvcl0gIyBuYW1lIHRoZSBwb3dlci1jdXJ2ZSBpbiB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHRlc3RlZCBjb3JyZWxhdGlvbg0KICBuYW1lcyhjb2hlbnNfZHNfYXRfY29yKVtbaWNvcl1dIDwtIGNvcnJlbGF0aW9uc1tpY29yXSAjIHNhbWUgZm9yIGNvaGVucyBkDQp9DQpgYGANCg0KDQpBZ2FpbiwgdGhlIGFib3ZlIGNvZGUgcnVucyBhIHBvd2VyLXNpbXVsYXRpb24sIG9yIG1vcmUgc3BlY2lmaWNhbGx5IHRocmVlIHBvd2VyLWFuYWx5c2VzLCBvbmUgZm9yIGVhY2ggY29ycmVsYXRpb24gdGhhdCB3ZSB3YW50ZWQgdG8gdGVzdC4NCk5vdGljZSBob3cgdGhpcyB0aW1lIHdlIHNwZWNpZnkgYHBhaXJlZCA9IFRSVUVgIGluIHRoZSBgdC50ZXN0YCBmdW5jdGlvbiwgdG8gaW5kaWNhdGUgdGhhdCB3ZSBhcmUgZGVhbGluZyB3aXRoIG5vbi1pbmRlcGVuZGVudCBvYnNlcnZhdGlvbnMuDQpBbHNvIG5vdGUgdGhhdCBhIG5ldyBwYXJ0IG9mIHRoZSBjb2RlIHNhdmVzIHRoZSBgcG93ZXJfYXRfbmAgdmVjdG9yIHRvIGEgbGlzdCBjYWxsZWQgYHBvd2VyX2F0X2NvcmAuIA0KVGhpcyBsaXN0LCB3aWxsIGhhdmUgMyBlbGVtZW50cywgZWFjaCBvZiB0aGVtIHRoZSBwb3dlciBjdXJ2ZSBmb3Igb25lIG9mIHRoZSBjb3JyZWxhdGlvbnMuDQpXZSBjYW4gYWNjZXNzIGVhY2ggcG93ZXItY3VydmUgYmVpIGVpdGhlciBgcG93ZXJzX2F0X2NvcltbMV1dYCB0byBnZXQgdGhlIGZpcnN0IHZlY3RvciBpbiB0aGUgbGlzdCAodGhlIGRvdWJsZSBzcXVhcmUgYnJhY2tldHMgbWVhbiBmaXJzdCBlbnRpcmUgdmVjdG9yIHJhdGhlciB0aGFuIGZpcnN0IG51bWJlciBvbmx5KSBvciB3ZSBjYW4gdXNlIGl0IGJ5IGluZGljYXRpbmcgaXRzIG5hbWUgYXMgYHBvd2Vyc19hdF9jb3IkYDAuMWAgdG8gdGVsbCBSIHRoYXQgd2Ugd2FudCB0aGUgcG93ZXIgY3VydmUgZm9yIGEgY29ycmVsYXRpb24gb2YgLjEwLg0KDQpXZSBjYW4gcGxvdCB0aGVzZSBwb3dlci1jdXJ2ZXMgbmV4dCB0byBlYWNoIG90aGVyDQoNCmBgYHtyIHBvd2VyY3VydmVfY29ycl90LXRlc3QsIG91dC53aWR0aD0nMTIwJSd9DQpwYXIobWZyb3c9YygxLDMpKQ0KcGxvdCgyOihsZW5ndGgocG93ZXJzX2F0X2NvciRgMC4xYCkrMSksIHBvd2Vyc19hdF9jb3IkYDAuMWAsIHhsYWIgPSAiTnVtYmVyIG9mIHBhcnRpY2lwYW50cyIsIHlsYWIgPSAiUG93ZXIiLCB5bGltID0gYygwLDEpLCBheGVzID0gVFJVRSwgbWFpbiA9ICJjb3JyZWxhdGlvbiA9IDAuMSIpDQphYmxpbmUoaCA9IC45NSwgY29sID0gInJlZCIpDQpwbG90KDI6KGxlbmd0aChwb3dlcnNfYXRfY29yJGAwLjVgKSsxKSwgcG93ZXJzX2F0X2NvciRgMC41YCwgeGxhYiA9ICJOdW1iZXIgb2YgcGFydGljaXBhbnRzIiwgeWxhYiA9ICJQb3dlciIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBUUlVFLCBtYWluID0gImNvcnJlbGF0aW9uID0gMC41IikNCmFibGluZShoID0gLjk1LCBjb2wgPSAicmVkIikNCnBsb3QoMjoobGVuZ3RoKHBvd2Vyc19hdF9jb3IkYDAuOWApKzEpLCBwb3dlcnNfYXRfY29yJGAwLjlgLCB4bGFiID0gIk51bWJlciBvZiBwYXJ0aWNpcGFudHMiLCB5bGFiID0gIlBvd2VyIiwgeWxpbSA9IGMoMCwxKSwgYXhlcyA9IFRSVUUsIG1haW4gPSAiY29ycmVsYXRpb24gPSAwLjkiKQ0KYWJsaW5lKGggPSAuOTUsIGNvbCA9ICJyZWQiKQ0KYGBgDQoNCkhlcmUgd2Ugc2VlIGhvdyBkcmFzdGljYWxseSB0aGUgY29ycmVsYXRpb24gaW5mbHVlbmNlcyB0aGUgcG93ZXIgaW4gdGhpcyBzaXR1YXRpb24uDQpXaXRoIGEgaGlnaCBjb3JyZWxhdGlvbiwgd2UgbmVlZCBvbmx5IHZlcnkgZmV3IHBhcnRpY2lwYW50cyB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIHBvd2VyIGluIHRoZSBzcGVjaWZpZWQgY2FzZS4NCldoeSBpcyB0aGlzPyANClRoZSByZWFzb24gZm9yIHRoaXMgaXMgd2hhdCB3ZSBoYWQgYSBsb29rIGF0IGFib3ZlOiBUaGUgZGVjcmVhc2luZyBzdGFuZGFyZC1kZXZpYXRpb24gb2YgdGhlIGRpZmZlcmVuY2Ugc2NvcmVzIHRoZSBoaWdoZXIgdGhlIGNvcnJlbGF0aW9uIGdldHMuIA0KDQpUaGlzIGlzIGhvdyB0aGUgZWZmZWN0LXNpemVzIGxvb2suDQoNCmBgYHtyIGNvaGVuc19kX2NvcnJfdHRlc3QsIG91dC53aWR0aD0nMTIwJSd9DQpwYXIobWZyb3c9YygxLDMpKQ0KcGxvdCgyOihsZW5ndGgoY29oZW5zX2RzX2F0X2NvciRgMC4xYCkrMSksIGNvaGVuc19kc19hdF9jb3IkYDAuMWAsIHhsYWIgPSAiTnVtYmVyIG9mIHBhcnRpY2lwYW50cyIsIHlsYWIgPSAiQ29oZW5zIEQiLCB5bGltID0gYygwLDEpLCBheGVzID0gVFJVRSwgbWFpbiA9ICJjb3JyZWxhdGlvbiA9IDAuMSIpDQphYmxpbmUoaCA9IC41MCwgY29sID0gInJlZCIpDQpwbG90KDI6KGxlbmd0aChjb2hlbnNfZHNfYXRfY29yJGAwLjVgKSsxKSwgY29oZW5zX2RzX2F0X2NvciRgMC41YCwgeGxhYiA9ICJOdW1iZXIgb2YgcGFydGljaXBhbnRzIiwgeWxhYiA9ICJDb2hlbnMgRCIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBUUlVFLCBtYWluID0gImNvcnJlbGF0aW9uID0gMC41IikNCmFibGluZShoID0gLjUwLCBjb2wgPSAicmVkIikNCnBsb3QoMjoobGVuZ3RoKGNvaGVuc19kc19hdF9jb3IkYDAuOWApKzEpLCBjb2hlbnNfZHNfYXRfY29yJGAwLjlgLCB4bGFiID0gIk51bWJlciBvZiBwYXJ0aWNpcGFudHMiLCB5bGFiID0gIkNvaGVucyBEIiwgeWxpbSA9IGMoMCwxMCksIGF4ZXMgPSBUUlVFLCBtYWluID0gImNvcnJlbGF0aW9uID0gMC45IikNCmFibGluZShoID0gLjUwLCBjb2wgPSAicmVkIikNCmBgYA0KDQpGb3IgLjEwIHRoZSB2YWx1ZSBvZiB0aGUgZWZmZWN0LXNpemUgc2VlbXMgc2xpZ2h0bHkgdW5kZXJlc3RpbWF0ZWQsIGZvciAuNTAgaXQgYXBwcm9hY2hlcyAuNTAganVzdCBhcyBpbiB0aGUgdHdvLXNhbXBsZSBjYXNlIGFuZCBmb3IgLjkwIGl0IHNlZW1zIG92ZXJlc3RpbWF0ZWQgYnkgcXVpdGUgYSBiaXQuIA0KRGlkIHNvbWV0aGluZyBnbyB3cm9uZz8NCldlbGwgbm8uIEFzIHdlJ3ZlIHNlZW4gYWJvdmUgJENvaGVuJ3NcIGQkIGlzIGNhbGN1bGF0ZWQgYnkgZGl2aWRpbmcgdGhlIG1lYW4tZGlmZmVyZW5jZSBieSB0aGUgc3RhbmRhcmQtZGV2aWF0aW9uIG9mIHRoZSBkaWZmZXJlbmNlIHNjb3JlcyB3aGljaCBiZWNvbWVzIHNtYWxsZXIgYW5kIHNtYWxsZXIgd2l0aCBpbmNyZWFzaW5nIGNvcnJlbGF0aW9uLg0KVGhlcmVmb3JlLCBjYWxjdWxhdGVkIHRoaXMgd2F5LCAkQ29oZW4nc1wgZCQgaXMgbXVjaCBiaWdnZXIgaW4gdGhlIGNhc2Ugd2l0aCB0aGUgbGFyZ2VyIGNvcnJlbGF0aW9uLg0KVGhpcyBpcyBhbHNvIHdoeSB3ZSBzZWVtIHRvIGhhdmUgbXVjaCBiaWdnZXIgcG93ZXIgLSB3ZSBqdXN0IHdvcmsgd2l0aCBhIGxhcmdlciBlZmZlY3Qgc2l6ZSB0aGFuIHdlIGludGVuZGVkLg0KV2UgY2FuIGV2ZW4gY2FsY3VsYXRlIGJ5IGhvdyBtdWNoIHRoZSBlZmZlY3Qtc2l6ZSBpcyBpbmZsdWVuY2VkIGJ5IHRoZSBjb3JyZWxhdGlvbiBieSBkaXZpZGluZyB0aGUgZWZmZWN0LXNpemUgdGhhdCB3ZSB3b3VsZCBjYWxjdWxhdGUgYmFzZWQgb24gdGhlIG1lYW5zIGFuZCBzZHMgb2Ygb3VyIGdyb3VwcyBieSAkXHNxcnR7MigxLXIpfSQuIA0KDQpyID0gLjkwIC0tPiBgMC41L3NxcnQoMiooMS0uOTApKWAgPSBgciAwLjUvc3FydCgyKigxLS45MCkpYA0KciA9IC41MCAtLT4gYDAuNS9zcXJ0KDIqKDEtLjUwKSlgID0gYHIgMC41L3NxcnQoMiooMS0uNTApKWANCnIgPSAuMTAgLS0+IGAwLjUvc3FydCgyKigxLS4xMCkpYCA9IGByIDAuNS9zcXJ0KDIqKDEtLjEwKSlgDQoNCllvdSBtaWdodCB3b25kZXIgaG93IHdlIGNhbiBzcGVjaWZ5IGVmZmVjdC1zaXplcyBpbiB0aGVzZSBjYXNlcyBvZiBjb3JyZWxhdGVkIGRhdGEuIERvIHdlICJjb3JyZWN0IiB0aGUgZXhwZWN0ZWQgZWZmZWN0IGZvciB0aGUgY29ycmVsYXRpb24gb3IgZG8gd2UganVzdCBhc3N1bWUgdGhhdCBpdCBpcyAuNTAgYW5kIHVzZSB0aGUgb25lLXNhbXBsZSBzY2VuYXJpbyBhYm92ZT8gDQpJIGRvIG5vdCBoYXZlIGEgZ29vZCBhbnN3ZXIgZm9yIHRoaXMuIA0KSW4gbWFueSBjYXNlcyBpdCBtaWdodCBiZSBmaW5lIHRvIG9ubHkgc3BlY2lmeSB0aGUgZWZmZWN0LXNpemUgb2YgdGhlIHByZS1wb3N0IGRlc2lnbiBiYXNlZCBvbiB0aGUgZGlmZmVyZW5jZSBzY29yZXMgYXMgd2UgZGlkIGluIHRoZSBvbmUtc2FtcGxlIGNhc2UuDQpJbiBzb21lIGNhc2VzLCBob3dldmVyLCB3ZSBtaWdodCBmaW5kIHRoZSBjb3JyZWxhdGlvbiB2ZXJ5IGltcG9ydGFudCBvciBoYXZlIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvcnJlbGF0aW9uIG9mIDIgbWVhc3VyZXMgdGhhbiBhYm91dCB0aGUgY2hhbmdlIGluIG1lYXN1cmVzIGR1ZSB0byBhbiBpbnRlcnZlbnRpb24uIA0KSW4gdGhvc2UgY2FzZXMsIGl0IG1pZ2h0IG1ha2Ugc2Vuc2UgdG8gYmUgdmVyeSBzcGVjaWZpYyBhYm91dCB0aGUgZXhwZWN0ZWQgY29ycmVsYXRpb25zIGFuZCBiZSBhd2FyZSB0aGF0IHdlIG1pZ2h0IG5lZWQgbW9yZSBkYXRhIGlmIHRoZSBjb3JyZWxhdGlvbiBpcyBsb3cuDQpFdmVudHVhbGx5LCBvdXIgZGF0YSBzdGVtIGZyb20gYW4gdW5kZXJseWluZyBfZGF0YSBnZW5lcmF0aW5nIHByb2Nlc3NfIHRoYXQgaW5jbHVkZXMgdGhlIGNvcnJlbGF0aW9uIGJldHdlZW4gdmFyaWFibGVzIGFuZCBtZWFzdXJlcyBhbmQgaXQgaXMgYWx3YXlzIGdvb2QgdG8gYmUgYXdhcmUgb2YgdGhlIGZhY3RvcnMgdGhhdCBtaWdodCBwb3NzaWJseSBpbmZsdWVuY2UgdGhlIHJlc3VsdHMuIA0KV2hlbiB3ZSBjb2xsZWN0IGRhdGEgaW4gYSBwcmUtcG9zdCBkZXNpZ24sIHdlIF9kb18gaW4gZmFjdCBtZWFzdXJlIGEgc2NvcmUgYXQgMiB0aW1lLXBvaW50cyBhbmQgZG8gbm90IGRpcmVjdGx5IGFzc2VzcyB0aGUgZGlmZmVyZW5jZS4gDQpXaGVuIHdlIHNwZWNpZnkgdGhlIHN0YW5kYXJkLWRldmlhdGlvbiBvZiB0aGUgZGlmZmVyZW5jZSBzY29yZXMgaG93ZXZlciwgdG8gYXJyaXZlIGF0IGEgZ2l2ZW4gJENvaGVuJ3NcIGQkLCB3ZSBpbXBsaWNpdGVseSBtYWtlIGFzc3VtcHRpb25zIGFib3V0IHRoZSBjb3JyZWxhdGlvbnMgb2YgdGhlc2UgdHdvIG1lYXN1cmVzLg0KDQpUaGUgVGFrZS1ob21lIG1lc3NhZ2UgaGVyZSBpcyB0aGF0IGNvcnJlbGF0aW9ucyBtYXR0ZXIgYW5kIHRoYXQgd2UgbmVlZCB0byBiZSBhd2FyZSBvZiB0aGlzLiBUaGUgZ29vZCBuZXdzIGlzIHRoYXQgcG93ZXItc2ltdWxhdGlvbnMgd2lsbCBhdCBsZWFzdCBtYWtlIHVzIGF3YXJlIG9mIHRoZXNlIGZhY3RvcnMgYW5kIHNob3cgdXMgaG93IGRpZmZlcmVudCBhc3N1bXB0aW9ucyBsZWFkIHRvIGRpZmZlcmVudCByZXN1bHRzLiANCg0KDQojIyBTdW1tYXJ5OiBPdXIgZmlyc3Qgc2ltdWxhdGlvbnMgd2l0aCB0LXRlc3RzDQoNClRoaXMgd2FzIHRoZSBsYXN0IGJpdCB0aGF0IEkgd2FudGVkIHRvIGRpc2N1c3MgYWJvdXQgc2ltdWxhdGluZyB0LXRlc3RzIGFuZCB0aGUgZW5kIG9mIHBhcnQgSUkgb2YgdGhpcyB0dXRvcmlhbC4NCldlIGhhdmUgbm93IGxlYXJuZWQgaG93IHRvIHNpbXVsYXRlIGEgdC10ZXN0IGJ5IHVzaW5nIGVpdGhlciAkQ29oZW4nc1wgZCQgYXMgYW4gZWZmZWN0LXNpemUgZXN0aW1hdGUgYW5kLCBpZiBuZWNlc3NhcnksIHRlbGwgYFJgIHRoYXQgb3VyIHR3byBncm91cHMsIG9yIG1lYXN1cmVtZW50cywgYXJlIGNvcnJlbGF0ZWQgaW4gc29tZSB3YXkuDQpXaGF0IHdlIGxlYXJuZWQgYWJvdmUgaXMgbm90IHJlc3RyaWN0ZWQgdG8gZG9pbmcgdC10ZXN0cyBob3dldmVyLg0KU2ltdWxhdGluZyB1bml2YXJpYXRlIChpLmUuIHVuY29ycmVsYXRlZCkgb3IgbXVsdGl2YXJpYXRlIChpLmUuIGNvcnJlbGF0ZWQpIG5vcm1hbC1kaXN0cmlidXRpb25zIHdpbGwgYmUgd2hhdCB3ZSBkbyBtb3N0IG9mIHRoZSB0aW1lIGluIHBhcnQgSUlJIGFuZCBwYXJ0IElWIG9mIHRoZSB0dXRvcmlhbC4NClRoZSBvbmx5IHRoaW5nIHRoYXQgd2lsbCBjaGFuZ2UgZm9yIG1vcmUgY29tcGxpY2F0ZWQgZGVzaWducyBpcyBob3cgd2UgY29tYmluZSB0aGUgZGlmZmVyZW50IHRvb2xzIHRoYXQgd2UgbGVhcm5lZCBpbiB0aGlzIHBhcnQgdG8gYWNoaWV2ZSBvdXIgZ29hbC4NCg0KSW4gcGFydCBJSUkgb2YgdGhpcyB0dXRvcmlhbCwgd2Ugd2lsbCBzZWUgaG93IHdlIGNhbiBiYXNpY2FsbHkgcnVuIGV2ZXJ5IGFuYWx5c2lzIGFzIGEgbGluZWFyIG1vZGVsIHVzaW5nIHRoZSBgbG1gIGZ1bmN0aW9uIGluc3RlYWQgb2YgdXNpbmcgdGhlIGB0LnRlc3RgIGZ1bmN0aW9uIGZvciB0LXRlc3RzLCB0aGUgYGFvdmAgZnVuY3Rpb24gZm9yIEFOT1ZBLWRlc2lnbnMgYW5kIHNvIGZvcnRoLg0KQnkgZXhwbG9yaW5nIGhvdyB0aGlzIHdvcmtzIGZvciB0LXRlc3QsIGFub3ZhIGFuZCByZWdyZXNzaW9uIHdlIHdpbGwgc2ltdWxhdGUgb3VyIHdheSB0aHJvdWdoIHRoZSB0aGlyZCBwYXJ0IGFuZCBiZSBmbGV4aWJsZSBlbm91Z2ggdG8gc2ltdWxhdGUgYW55IGNsYXNzaWNhbCByZXNlYXJjaCBkZXNpZ25zIHRoYXQgd2Ugd291bGQsIGZvciBleGFtcGxlLCBiZSBhYmxlIHRvIGRvIGluIEdQb3dlci4gSW4gcGFydCBJViB3ZSB3aWxsIGdvIGJleW9uZCB0aGlzIGFuZCBzaW11bGF0ZSBtaXhlZC1lZmZlY3QgbW9kZWxzLg0KDQojIEZvb3Rub3Rlcw0KDQpbXjFdOg0KVGhpbmsgYmFjayB0byB0aGUgcG9zc2libGUgc2VxdWVuY2VzIG9mIGNvaW4gdG9zc2VzIGluIHBhcnQgSS4gDQpJbnN0ZWFkIG9mIHBvc3NpYmxlIHNlcXVlbmNlcyBvZiBjb2luLXRvc3Nlcywgd2UgZGVhbCB3aXRoIHBvc3NpYmxlIHNlcXVlbmNlcyBvZiBwZW9wbGUtc2NvcmVzIGhlcmUsIGFzc3VtaW5nIHRoYXQgdGhleSBjb21lIGZyb20gdGhlIHVuZGVybHlpbmcgZGlzdHJpYnV0aW9uIHRoYXQgd2Ugc3BlY2lmeS4NClRvIGdldCBhIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBhbGwgdGhlIHBvc3NpYmxlIHNhbXBsZXMgdGhhdCB3ZSBjb3VsZCBnZXQgdGhhdCBzdGlsbCBmb2xsb3cgdGhlIHNwZWNpZmllZCBkaXN0cmlidXRpb24sIHdlIG5lZWQgdG8gc2ltdWxhdGUgbWFueSwgbWFueSB0aW1lcy4NCg0KW14yXTogDQpUaGlzIGlzIGhvdyB3ZSBzb2x2ZSBmb3IgcjoNCg0KXGJlZ2lue2FsaWdufQ0KJjIgPSBcc3FydHsyXjIrMl4yLTJyIFx0aW1lcyAyIFx0aW1lcyAyfSAgXFwNCg0KXGlmZiAmMiA9IFxzcXJ0ezgtOHJ9ICZ8IF4yXFwNClxpZmYgJjQgPSA4LThyICZ8IC04OyBcZGl2KC04KSBcXCANClxpZmYgJjAuNSA9IHIgIA0KDQpcZW5ke2FsaWdufQ0K" download="power-analysis-by-data-simulation-in-r-part-ii.Rmd">Download power-analysis-by-data-simulation-in-r-part-ii.Rmd</a>
<style type="text/css">
button.btn.collapsed:before
{
    content:'+' ;
    display:block;
    width:15px;
}
button.btn:before
{
    content:'-' ;
    display:block;
    width:15px;
}
</style>
<p><em>This blog is also available on <a href="https://www.r-bloggers.com/">R-Bloggers</a></em></p>
<div id="the-power-analysis-by-simulation-in-r-for-really-any-design---part-ii" class="section level1">
<h1>The Power Analysis by simulation in <code>R</code> for really any design - Part II</h1>
<p>This is Part II of my tutorial on how to do power-analysis by simulation.
In Part I, we saw how to do a simulation for a simple toy-example with a coin-toss.
In this part, we will use a more realistic problem that we might encounter in our daily research life and see how to simulate the power for these designs.
By looking at how to do power-simulation for the independent-samples t-test and the paired t-test we will learn how to simulate normal-distributions, how to specify their effect-sizes, in terms of <span class="math inline">\(Cohen&#39;s\ d\)</span>. Moreover, we simulate correlated (i.e. multivariate) normal distributions in cases where we have correlated observations (e.g. paired-sample t-test).
This will be an important tool for later parts of this tutorial.</p>
<p>In part III of this tutorial we will learn how we can conceptualize basically <em>any</em> design as a linear model and thereby be very flexible in our power analysis.
In part IV we will learn how to apply this technique to complicated designs such as linear mixed-effects models and generalized mixed-effects models.</p>
<div id="simulating-a-between-subjects-t-test" class="section level2">
<h2>Simulating a between-subjects t-test</h2>
<p>Let’s get to it.
The first thing we will need again in our simulation is one of the implemented simulation functions in R (those that let <code>R</code> run theoretical experiments for us), but this time it is not <code>rbinom</code> as we are not working with coin-flips but <code>rnorm</code> - the simulation function for the normal distribution.
Let’s have a short look at that function as we will keep working with it throughout the tutorial.</p>
<p><code>rnorm(n, mean, sd)</code> takes three arguments, a sample-size <code>n</code>, a <code>mean</code> and a standard-deviation <code>sd</code>.
By specifying these values, we can sample random ‘people’ (or observations) that are participating in our simulated experiments.
Imagine, for example, that we have an intervention study in which we have a treatment group and a control group.
We can easily simulate both groups with <code>rnorm</code> but what should the means and sds of the groups be?</p>
<p>There are two ways we can approach this.</p>
<ol style="list-style-type: decimal">
<li>We could think about what group means we expect in our given case and what we expect the spread of the groups to be <em>on the measurment scale that we are working with</em>.
For example, if we use a 40-point scale for a clinical test we might know that a group with deficiencies on the thing that we measure would probably score around 10 points and that almost everyone from that group would score lower than 20 points.
This statement (most people score around 10, almost everyone scores lower than tified as normal distribution with a mean of 10 and a standard-deviation of 5. In this case only 2.5% of the values (i.e. the values outside the 95% CI) will be higher than 20.</li>
<li>In a new research project, we might not be able or willing to to make these statements.
In this case, by making some extra assumptions, we can fall back to the approach that we also use in power-calculation software in most cases and define a <em>standardized effect size</em> that we can use to simulate data rather than defining the group means and standard-deviations directly.</li>
</ol>
<p>I personally try to go with the first approach whenever possible, as I think that in many cases we know more about what we expect from our data than we think, even in new projects.
Even if we <strong>do not</strong> know a lot about our data, we might still try out different assumptions (i.e. means and sds) for the groups in our simulation to see what power we would get for each of them.
This way, we can make informed decisions about our sample size that are more nuanced than the one in which we just assume a standardized effect size and see what sample-size it implies and are forced to think harder about our data - something that might seem difficult and annoying at first, but is extremely useful and eduucational.
Another advantage of specifying the groups directly is that we can do this for any arbitrarily complex design where standardized effect sizes are often difficult to calculate.</p>
<p>This said, for the cases where we might really not be willing to specify groups directly, and because it allows me to demonstrate some other interesting points, in this part I will discuss how we can use standardized effect-sizes in our simulation.
In part III and IV however, we will always specify effects on the raw scale.</p>
<p>If we were using GPower now, we would most likely just fill in a difference between groups in <span class="math inline">\(Cohen&#39;s\ d\)</span> and be done with it.
We could of course also follow this approac in a simulation by defining the groups based on the implied <span class="math inline">\(Cohen&#39;s\ d\)</span>.
For instance, we can just assume that group 1 as <code>rnorm(n, 1,2)</code>.
Now, following from the formula for Cohen’s d:</p>
<p><span class="math display">\[Cohen&#39;s\ d =  \frac{(M_1 - M_2)}{pooled \ sd}\]</span></p>
<p>where</p>
<p><span class="math display">\[pooled\ sd =  \sqrt\frac{(sd_1^2+sd_2^2)}{2}\]</span></p>
<p>and adhering to the student t-test assumption of equal variances we can fill in the pooled sd formula above as</p>
<p><span class="math display">\[pooled\ sd =  \sqrt\frac{(2^2+2^2)}{2} = 2\]</span></p>
<p>to get a <span class="math inline">\(Cohen&#39;s\ d\)</span> of .50:</p>
<p><span class="math display">\[Cohen&#39;s\ d =  \frac{(1 - 0)}{2} = 0.5\]</span></p>
<p>To get any other value for <span class="math inline">\(Cohen&#39;s\ d\)</span> we can just change the pooled sd value to whatever we want.
More generally, we want to solve the equation above for the pooled sd after specifying any <span class="math inline">\(Cohen&#39;s\ d\)</span>, e.g.:</p>
<p><span class="math display">\[0.5=  \frac{(1 - 0)}{pooled\ sd}\]</span></p>
<p>We can solve an equation like that with <code>R</code>’s somewhat unintuitive <code>solve</code> function like this:</p>
<pre class="r"><code>solve(0.5,1) # cohens d of .5</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>solve(0.25,1) # cohens d of .25</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code>solve(2,1) # cohens d of 2</code></pre>
<pre><code>## [1] 0.5</code></pre>
<p>giving us three examples of how we would need to specify pooled sd to arrive at a particular <span class="math inline">\(Cohen&#39;s\ d\)</span>.</p>
<p>Thus, if we want to do a t-test with two simulated groups and a cohen’s d of 0.5 we can simulate two groups of a particular sample-size by using the <code>rnorm</code> function.
Let’s say we have 30 participants in each group.</p>
<pre class="r"><code>set.seed(1234)
group1 &lt;- rnorm(30, 1, 2)
group2 &lt;- rnorm(30, 0, 2)</code></pre>
<p>We can visualize the groups that we got in a plot like this:</p>
<pre class="r"><code>hist(group1, col = &quot;#addd8e&quot;, breaks = 10, main = &quot;Histogram of both groups&quot;, xlab = &quot;&quot;)
hist(group2, add = TRUE, breaks = 10, col= &quot;#31a354&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_groups1-1.png" width="672" /></p>
<p>We can already make important observations from this plot:</p>
<p>We wanted to get normal distributions, but what we got here does not really look normal.
Why is that? Because we only have 30 people per group and taking only 30 values from the specified normal distributions does not really give us a good approximation of the real distribution.
<strong>This point is important</strong>: The sampling variability in such small groups is high and often, if small sample-studies (i.e. underpowered studies) find “effects”, they are often rather big and the consequence of this sampling variability rather than real differences of groups.
For example, by looking at the means of our sampled groups <code>mean(group1)</code> = 0.40715 and <code>mean(group2)</code> = -1.1032366 we see that the group mean of group 1 is actually closer to the mean that we specified for group 2 (i.e. 0) than to its own mean, while the mean for group 2 is far away from our intended mean.
Looking at the sds actually shows that they are quite close to what we wanted <code>sd(group1)</code> = 1.8059661 and <code>sd(group2)</code> = 1.9179992.
The <span class="math inline">\(Cohen&#39;s\ d\)</span> that we wanted is also not presented very accurately at <code>(mean(group1)-mean(group2))/(sqrt((sd(group1)^2+sd(group2)^2)/2))</code> = 0.8108043.
Again, if we would do this in Gpower, and specify a <span class="math inline">\(Cohen&#39;s\ d\)</span>, we will always work with an <em>exact</em> <span class="math inline">\(Cohen&#39;s\ d\)</span>, in a simulation approach we do <strong>not</strong>.</p>
<p>So let us run a t-test to see whether there is a significant difference here.
First, we need to decide on an alpha-level again.
What will we choose?
Well, to have a good justification we have to elaborate on what the groups actually represent.
Let us say that the difference between groups is related to an intervention that can elevate depressive symptoms.
Thus, the control group (group1) did not get the intervention and scores higher on depressive symptoms while the treatment group (group2) is expected to score lower.
Let us assume that this is the first study that we run and that, if we find anything we will follow it up by more extensive studies anyway. Therefore, we might not want to miss a possible effect by setting a too conservative alpha-level.
If we find something in this study, we will conduct further studies in which we are more strict about the alpha level.
Thus, we choose .10 for this first “pilot” study.</p>
<div class="notebox">
<p>
<strong>NOTE</strong>: The alpha-level “jusficications” in this tutorial are for educational purposes and to provide a starting point. They are obviously not as rigorous as we would like in a real research project. If you find yourself in a situation where you want to justify your alpha-level see <a href="https://www.nature.com/articles/s41562-018-0311-x">Justify your alpha by Lakens et al.</a> for a good discussion on this.
</p>
</div>
<p>We can now run a t-test with R’s integrated <code>t.test</code> function.</p>
<pre class="r"><code>t.test(group1, group2, paired = FALSE, var.equal = TRUE, conf.level = 0.9)</code></pre>
<pre><code>## 
##  Two Sample t-test
## 
## data:  group1 and group2
## t = 3.1402, df = 58, p-value = 0.002656
## alternative hypothesis: true difference in means is not equal to 0
## 90 percent confidence interval:
##  0.7064042 2.3143690
## sample estimates:
## mean of x mean of y 
##  0.407150 -1.103237</code></pre>
<p>The t-test shows, that this effect would be significant.
However, we also got “lucky” and had a larger effect than we intended to have.
To do a proper power analysis (lets say we first want to see whether 30 people per group are enough) we need to not only simulate each group once, but many many times and see how often we get a significant result at the desired alpha-level<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.
Moreover, we would like to have a power of at least 95%, again reflecting our view that we do not want to miss a possible effect.</p>
<p>In normal language these assumptions mean that if there is a difference, we will detect it in 19 out of 20 cases while, if there is no difference, we will only be incorrectly claiming that there is one in 1 out of 10 cases.</p>
<p>We will do this similarly to our simulations in part 1 of this tutorial.</p>
<pre class="r"><code>set.seed(1)
n_sims &lt;- 1000 # we want 1000 simulations
p_vals &lt;- c()
for(i in 1:n_sims){
  group1 &lt;- rnorm(30,1,2) # simulate group 1
  group2 &lt;- rnorm(30,0,2) # simulate group 2
  p_vals[i] &lt;- t.test(group1, group2, paired = FALSE, var.equal = TRUE, conf.level = 0.90)$p.value # run t-test and extract the p-value
}
mean(p_vals &lt; .10) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)</code></pre>
<pre><code>## [1] 0.592</code></pre>
<p>Aha, so it appears that our power <code>mean(p_vals &lt; .10)</code> = 0.592 is much lower than the 95% that we desired.
Thus, we did really get lucky in our example above when we found an effect of our intervention.</p>
<p>To actually do a legit power-analysis however, we would like to know how many people we do need for a power of 95 percent.
Again we can modify the code above to take this into account.</p>
<pre class="r"><code>set.seed(1)
n_sims &lt;- 1000 # we want 1000 simulations
p_vals &lt;- c()
power_at_n &lt;- c(0) # this vector will contain the power for each sample-size (it needs the initial 0 for the while-loop to work)
cohens_ds &lt;- c()
cohens_ds_at_n &lt;- c() 
n &lt;- 30 # sample-size 
i &lt;- 2
while(power_at_n[i-1] &lt; .95){
  for(sim in 1:n_sims){
    group1 &lt;- rnorm(n,1,2) # simulate group 1
    group2 &lt;- rnorm(n,0,2) # simulate group 2
    p_vals[sim] &lt;- t.test(group1, group2, paired = FALSE, var.equal = TRUE, conf.level = 0.9)$p.value # run t-test and extract the p-value
    cohens_ds[sim] &lt;- abs((mean(group1)-mean(group2))/(sqrt((sd(group1)^2+sd(group2)^2)/2))) # we also save the cohens ds that we observed in each simulation
  }
    power_at_n[i] &lt;- mean(p_vals &lt; .10) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)
    cohens_ds_at_n[i] &lt;- mean(cohens_ds) # calculate means of cohens ds for each sample-size
    n &lt;- n+1 # increase sample-size by 1
    i &lt;- i+1 # increase index of the while-loop by 1 to save power and cohens d to vector
}
power_at_n &lt;- power_at_n[-1] # delete first 0 from the vector
cohens_ds_at_n &lt;- cohens_ds_at_n[-1] # delete first NA from the vector</code></pre>
<p>The loop stopped at a sample-size of <code>n-1</code> = 84 participants per group.
Thus make a conclusion about the effectiveness of our intervention at the specified alpha-level with the desired power we need 168 people in total.</p>
<p>To visualize the power we can plot it again, just as in the first part of the tutorial.</p>
<pre class="r"><code>plot(30:(n-1), power_at_n, xlab = &quot;Number of participants per group&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = TRUE)
abline(h = .95, col = &quot;red&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_power1-1.png" width="672" /></p>
<p>Again, this plot shows us how our power to detect the effect slowly increases if we increase the sample-size until it reaches our desired power.</p>
<p>There is another interesting observation to make here.
In the code above, I also calculate the average <span class="math inline">\(Cohen&#39;s\ d\)</span> for each sample size and the plot below shows how it changes with increasing sample-size.</p>
<pre class="r"><code>plot(30:(n-1), cohens_ds_at_n, xlab = &quot;Number of participants per group&quot;, ylab = &quot;Cohens D&quot;, ylim = c(0.45,0.55), axes = TRUE)
abline(h = .50, col = &quot;red&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_cohensd1-1.png" width="672" /></p>
<p>It is not super obvious in this plot and I had to change the scale of the y-axis quite a bit to make it visible, but we can actually see how our average <span class="math inline">\(Cohen&#39;s\ d\)</span> initially deviates slightly more from the desired <span class="math inline">\(Cohen&#39;s\ d\)</span> of .50 than in de end.
In other words, in the beginning, for small sample-sizes there is more fluctuation than for bigger sample-sizes.
That is pretty neat, as it seems very desirable that a power-estimation procedure takes into account that for smaller sample-sizes, even if the effect in the population is exactly the same (i.e. we always sample groups with a difference of <span class="math inline">\(Cohen&#39;s\ d\)</span> = .50) it is just less precise.</p>
<p>Let’s have a brief summary of what we did so far.
We just used the formula for <span class="math inline">\(Cohen&#39;s\ d\)</span> to give our groups a certain difference that we are interested in, ran 1000 simulated experiments for each sample-size and calculated the power, just as in the first part of the tutorial.</p>
<p>However, I want to mention again that, even though it is convenient to specify the effect-size this way as it saves us from having to specify precise group means and standard-deviations directy and makes the specification more comparable, it is often preferable to specify the parameters on the original scale that we are interested in.
This is especially the case if we have previous data on a research topic that we can make use of.
Moreover, for more complex designs with many parameters, standardized effect sizes are often difficult to obtain and we are forced to make our assumptions on the original scale of the data.
We will see this in later examples.</p>
</div>
<div id="simulating-a-within-subject-t-test" class="section level2">
<h2>Simulating a within-subject t-test</h2>
<p>Intuitively, it might seem that we can use the exact same approach above for a paired t-test as well.
However, the problem with this is that in a paired t-test we get 2 data-points from the same individual.
For example, image we have a group of people that get an intervention and we measure their score before and after the intervention and want to compare them with a paired t-test.
In this case, the score of the post-measure of a given individual is not completely independent of the score of the pre-measure.
In other words, somebody who scores very low on the pre-measure will most likely not score very high on the post-measure and vice versa.</p>
<p>Thus, there is a <em>correlation</em> between the pre- and the post-measures in that the pre-measures already tell us a little bit about what we can expect on the post-measure.
You probably already knew this but why does this matter for power simulation, you might wonder.
It matters as it directly influences our power to detect an effect as we will see later.
For now let’s just keep in mind that it is important.</p>
<p>So what do we do in a situation with correlated data as in the pre-post intervention situation?
There are two ways we can go from here.
First, we can simulate correlated normal distributions, as already mentioned above.
However, for the particular case of a paired sample t-test, we can also just make use of the fact that, in the end, we are testing whether the <strong>difference</strong> between post- and pre-measures is different from 0.
In this case, the correlation between the pre and the post-measure is implicitely handled when substracting the two measures. This way, we do not need to directly specify it.
If the correlation is close to one, the standard-deviation of the difference scores will be very small, if it is zero, we will end up with the same situation that we have in the independent-sample t-test.
Thus, we can just make use of a one-sample in which we test whether the distribution of difference-scores differs from zero as the paired t-test is equivalent to the one-sample t-test on difference scores <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3840331/">(see Lakens, 2013 for more details on this)</a>.</p>
<p>Though the one-sample approach is easier to simulate, I will describe both approaches in the following as the first approach (simulating correlated normal-distributions) is more flexible and we need it for the situations we deal with later.</p>
<div id="using-a-one-sample-t-test-approach" class="section level3">
<h3>Using a one-sample t-test approach</h3>
<p>When we want to do our power-calculation based on the one-sample t-test approach, we only have to specify a single difference-score distribution.
We can do this again, based on the <span class="math inline">\(Cohen&#39;s\ d\)</span> formula, this time for a one-sample scenario:</p>
<p><span class="math display">\[ Cohen&#39;s\ d = \frac{M_{diff} - \mu_0}{SD_{diff}}\]</span></p>
<p>In the above formula, to get our values for the simulation we can substitute the <span class="math inline">\(\mu_0\)</span> by 0 (as our null-hypothesis is no difference) and solve the equation in the same way as above by fixing the mean-difference between pre- and post-measure, <span class="math inline">\(M_{diff}\)</span> to 1 and calculating the sd we need for each given <span class="math inline">\(Cohen&#39;s\ d\)</span>, for instance</p>
<p><span class="math display">\[ 0.5 = \frac{1}{SD_{diff}}\]</span></p>
<p>putting this into <code>R</code>s <code>solve</code> function again, we unsurprisingly get a 2 in this case.</p>
<pre class="r"><code>solve(0.5, 1)</code></pre>
<pre><code>## [1] 2</code></pre>
<p>To run our simulation we just need to modify the code above to run a one-sample t-test rather than a two-sample t-test and change the formula for <span class="math inline">\(Cohen&#39;s\ d\)</span></p>
<pre class="r"><code>set.seed(1)
n_sims &lt;- 1000 # we want 1000 simulations
p_vals &lt;- c()
power_at_n &lt;- c(0) # this vector will contain the power for each sample-size (it needs the initial 0 for the while-loop to work)
cohens_ds &lt;- c()
cohens_ds_at_n &lt;- c() 
n &lt;- 2 # sample-size 
i &lt;- 2
while(power_at_n[i-1] &lt; .95){
  for(sim in 1:n_sims){
    difference &lt;- rnorm(n,1,2) # simulate the difference score distribution
    p_vals[sim] &lt;- t.test(difference, mu = 0, conf.level = 0.90)$p.value # run t-test and extract the p-value
    cohens_ds[sim] &lt;- mean(difference)/sd(difference) # we also save the cohens ds that we observed in each simulation 
  }
    power_at_n[i] &lt;- mean(p_vals &lt; .10) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)
    cohens_ds_at_n[i] &lt;- mean(cohens_ds) # calculate means of cohens ds for each sample-size
    n &lt;- n+1 # increase sample-size by 1
    i &lt;- i+1 # increase index of the while-loop by 1 to save power and cohens d to vector
}
power_at_n &lt;- power_at_n[-1] # delete first 0 from the vector
cohens_ds_at_n &lt;- cohens_ds_at_n[-1] # delete first NA from the vector</code></pre>
<p>We see that the loop stopped at <code>n</code> = 43 so the sample size we need is <code>n-1</code> = 42</p>
<p>We can plot the power-curve again</p>
<pre class="r"><code>plot(2:(n-1), power_at_n, xlab = &quot;Number of participants per group&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = TRUE)
abline(h = .95, col = &quot;red&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_power_ost-1.png" width="672" /></p>
<p>and the <span class="math inline">\(Cohen&#39;s\ d\)</span> values:</p>
<pre class="r"><code>plot(2:(n-1), cohens_ds_at_n, xlab = &quot;Number of participants per group&quot;, ylab = &quot;Cohens D&quot;, ylim = c(0.0,1.0), axes = TRUE)
abline(h = .50, col = &quot;red&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_cohensd_ost-1.png" width="672" /></p>
<p>We see again, and this time more dramatically, how our simulated effect size becomes more accurate the bigger our sample gets.</p>
</div>
<div id="using-a-correlated-samples-paired-t-test-approach" class="section level3">
<h3>Using a correlated-samples paired t-test approach</h3>
<div id="the-relationship-between-sd_diff-and-the-correlation" class="section level4">
<h4>The relationship between <span class="math inline">\(SD_{diff}\)</span> and the correlation</h4>
<p>In the above example, we respecified a paired t-test as a one-sample t-test on the difference scores.
However, what we are actually working with is two <em>correlated</em> distributions of measurements.
To demonstrate this point, let us have a look at how we would actually calculate the standard deviation of the difference scores (<span class="math inline">\(SD_{diff}\)</span>) in the above equation for <span class="math inline">\(Cohen&#39;s\ d\)</span>.
The formula to calculate <span class="math inline">\(SD_{diff}\)</span> from the standard deviation of the two measurements (pre and post) and their correlation is:</p>
<p><span class="math display">\[SD_{diff} = \sqrt{SD_{pre}^2+SD_{post}^2-2r \times SD_{pre} \times SD_{post}} \]</span></p>
<p>It is not important at this point to understand why this is the case (we will just trust <a href="http://www.utstat.toronto.edu/~brunner/oldclass/378f16/readings/CohenPower.pdf">Cohen</a> on this) but see how we can, for any given <span class="math inline">\(SD_{diff}\)</span> and assuming both groups have, for example, a standard deviation of 2, solve the formula to see what correlation (the <span class="math inline">\(r\)</span> in the above formula) it would imply.</p>
<p>Imagine, for instance, we assume (like in the independent-samples t-test above) that both measures have a standard-deviation of 2 and that the standard-deviation of the difference scores would also be 2 so that we would have the same situation as in the one-sample t-test example above, where we had a mean-difference of 1 and a difference-score standard-deviation of 2.</p>
<p>Filling this in we get</p>
<p><span class="math display">\[2 = \sqrt{2^2+2^2-2r \times 2 \times 2} \]</span></p>
<p>Solving this equation for <span class="math inline">\(r\)</span>, we get<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> <span class="math inline">\(r = 0.5\)</span>:</p>
<p>Therefore, interestingly the situation in which we use the same groups as above and assume that we would get the same <span class="math inline">\(SD_{diff}\)</span> of 2 as we assumed in our one-sample situation would imply that the correlation between the pre- and the post-measure is <span class="math inline">\(r = 0.5\)</span>.
What does this mean?
Well, lets see what happens if we assume a correlation of <span class="math inline">\(r = .90\)</span> and see what <span class="math inline">\(SD_{diff}\)</span> we get:</p>
<p><span class="math display">\[SD_{diff} = \sqrt{2^2+2^2-2 \times 0.90 \times 2 \times 2} \]</span></p>
<p>Solving this in <code>R</code> gives us: <code>sqrt(2^2+2^2-2*0.9*2*2)</code> = 0.89.
Thus, if the correlation increases the standard-deviation of the difference-scores becomes smaller.
If we do the same with a correlation of .10 we get <code>sqrt(2^2+2^2-2*0.1*2*2)</code> = 2.68.
Thus, when the correlation decreases the standard-deviation becomes bigger.
Interestingly, this demonstrates that for the same mean-difference, a high correlation results in a <em>larger</em> <span class="math inline">\(Cohen&#39;s\ d\)</span> as calculated for the difference scores in the one-sample case.
In other words, as the pre-scores tend to be more similar to the post-scores (i.e. they have a high correlation), the standard-deviation of the difference scores decreases.
This, in turn, results in higher power to detect an effect.</p>
<p>To sum up all of the above, we can either specify a difference-score distribution directly and thereby imply a certain correlation by specifying the <span class="math inline">\(SD_{diff}\)</span>, or we can see what <span class="math inline">\(SD_{diff}\)</span> we get with a certain correlation by using the formula above and use the result for the one-sample simulation.
However, instead of working with the one-sample t-test, in the next section, we will see how we can directly simulate correlated normal-distributions in <code>R</code>.</p>
</div>
<div id="simulating-correlated-normal-distributions-and-demystifying-the-multivariate-normal." class="section level4">
<h4>Simulating correlated normal-distributions and demystifying the multivariate normal.</h4>
<p>In real life, almost everything is correlated to some degree.
Though these correlations are often not of interest, they sometimes are and in a good simulation we want to acknowledge them. For instance, predictors in a regression might be correlated or random effects in a mixed-model.</p>
<p>The following part is (again) longer than I intended but I feel that it is important to understand how we simulate correlated normal-distributions and what a multivariate normal-distribution is.
In most cases later on we will deal with some kind of correlated normal distributions (in mixed-models we will always encounter them for example) so I think it helps if we have a look at them now in an easier example, so we have one problem less to worry about later on.</p>
<p>Rephrasing the problem of simulating two correlated normal-distributions, we can say that we want to simulate a <em>multivariate normal distribution</em> or, more specifically in this case, a <em>bivariate normal distribution</em>.
If you never heard these terms before, they might seem very opague, so let’s see what they are.
I will first show how we can simulate them, and explain what exactly this multivariate normal distribution means afterwards with a little visual intuiton.
We can simulate a multivariate normal distribution by using the <code>mvrnorm()</code> function from the <code>MASS</code> package but it works slightly different than the simulation functions that we have used so far (<code>rnorm</code> and <code>rbinom</code>).
Lets have a look at how this works (code explained below).</p>
<pre class="r"><code>require(MASS) # load MASS package</code></pre>
<pre><code>## Loading required package: MASS</code></pre>
<pre class="r"><code>pre_post_means &lt;- c(pre = 0,post = 1) # define means of pre and post in a vector
pre_sd &lt;- 2 # define sd of pre-measure
post_sd &lt;- 2 # define sd of post-measure
correlation &lt;- 0.5 # define their correlation

sigma &lt;- matrix(c(pre_sd^2, pre_sd*post_sd*correlation, pre_sd*post_sd*correlation, post_sd^2), ncol = 2) # define variance-covariance matrix

set.seed(1)
bivnorm &lt;- data.frame(mvrnorm(10000, pre_post_means, sigma)) # simulate bivariate normal</code></pre>
<p>The above code samples 10,000 observations from a bivariate normal-distribution, or in terms of our example, it samples 10,000 pre-measures with 10,000 correlated post-measures.
The first thing that is different from our earlier simulations is the first line of the code <code>pre_post_means &lt;- c(0,1)</code>.
Instead of defining our means seperately for each measurement, as we have done earlier in the independent-sample case, we now put the pre- and post-measurement mean that we assume into a vector.
This is because we will simulate both measurements together in the <code>mvrnorm</code> function, and therefore both means need to be provided at the same time.</p>
<p>Secondly, we define the standard-deviations of both measurements just as we did earlier and also specify a correlation that we would like our data-points to have, in this case 0.5.</p>
<p>Now, the line <code>matrix(c(pre_sd^2, pre_sd*post_sd*correlation, pre_sd*post_sd*correlation, post_sd^2), ncol = 2)</code> does something that we have not done before and it might look quite confusing.
What we are doing here is specifying the <em>variance-covariance matrix</em>.
This is nothing more than a table containing the variances of our pre- and post-measurement (the first and the last entry in the list) and the covariance between the two variables twice - once for each measurement (the middle 2 entries in the list).
Conceptually you can see this variance-covariance matrix as the standard-deviation of the multivariate normal that <code>mvrnorm</code> needs instead of the standard-deviation that we put into <code>rnorm</code> earlier.</p>
<p>We can visualize the variance-covariance matrix <code>sigma</code> to demystify it a bit.</p>
<pre class="r"><code>colnames(sigma) &lt;- c(&quot;pre&quot;, &quot;post&quot;)
rownames(sigma) &lt;- c(&quot;pre&quot;, &quot;post&quot;)
sigma</code></pre>
<pre><code>##      pre post
## pre    4    2
## post   2    4</code></pre>
<p>Thus, this matrix is nothing more than a table containing the variance of each variable (4 in each case) and their covariance (i.e. the correlation of the two multiplied by both standard-deviations (<span class="math inline">\(Cov(pre,post) = \rho(pre,post)*sd_{pre}*sd_{post}\)</span>).</p>
<p>In the next line of the code we put this all into <code>mvrnorm</code> to simulate our bivariate normal distribution and store the results in a data-frame with 2 columns, each containing one measurement point:</p>
<pre class="r"><code>head(bivnorm)</code></pre>
<pre><code>##          pre       post
## 1 -0.2807182 -0.8893814
## 2  1.3746052  0.2615539
## 3 -0.4119554 -1.4827470
## 4  3.9486678  2.5775470
## 5  1.0711637  1.0702847
## 6 -0.8961042 -0.9460816</code></pre>
<p>When we run <code>cor(bivnorm$pre, bivnorm$post)</code> we see that indeed their correlation is 0.52 and close to what we specified.</p>
<p>To see how we can imagine such a bivariate normal distribution, we can visualize it the following way.</p>
<p>If we draw a histogram of each measurement individually, it looks like this.</p>
<pre class="r"><code>par(mfrow=c(1,2))
hist(bivnorm$pre, main = &quot;pre-measure&quot;)
hist(bivnorm$post, main = &quot;post-measure&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_bivnorm1-1.png" width="672" /></p>
<p>However, imagine we would not only look at each histogram seperately but we would combine them into one plot by putting the pre-measure scores of each simulated individual on the x-axis and putting the post-measures on the y-axis like this:</p>
<pre class="r"><code>plot(bivnorm$pre, bivnorm$post, xlab = &quot;pre-measure&quot;, ylab = &quot;post-measure&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_bivnorm2-1.png" width="672" /></p>
<p>In the above plot, we can clearly see the correlations between the two measurements that we put in the data.
More elegantly, we can combine the two histograms in the following way.</p>
<pre class="r"><code>bivnorm_kde &lt;- kde2d(bivnorm[,1], bivnorm[,2], n = 50) # calculate kernel density (i.e. the &quot;height of the cone on the z-axis&quot;; not so important to understand here)
par(mar = c(0, 0, 0, 0)) # tel r not to leave so much space around the plot
persp(bivnorm_kde, phi = 45, theta = 30, xlab = &quot;pre-measure&quot;, ylab = &quot;post-measure&quot;, zlab = &quot;frequency&quot;) # plot the bivariate normal</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_bivnorm3-1.png" width="672" /></p>
<p>Here, we see clearly how our bivariate normal distribution is nothing more than the 2 normal-distributions of each measurement-point combined into one “cone-shaped” normal distribution that has a certain correlation.</p>
<p>The plot below shows how this cone looks with different correlations.</p>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/plot_bivnorm_cors-1.png" width="120%" /></p>
<p>Notice how for higher correlations, the cone becomes more and more narrow and starts looking like a “shark-fin” with a correlation of .90.
This “narrowring” of the cone is the visualization of why the standard-deviations of the difference scores get more narrow.</p>
<p>If we visualize this as a point cloud again the three correlations look like this:</p>
<pre class="r"><code>bivnorm_10 &lt;- as.data.frame(bivnorm_10)
bivnorm_90 &lt;- as.data.frame(bivnorm_90)
par(mfrow = c(1,3))
plot(bivnorm_10$pre, bivnorm_10$post)
plot(bivnorm$pre, bivnorm$post)
plot(bivnorm_90$pre, bivnorm_90$post)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/correlation_pointplots-1.png" width="672" /></p>
<p>This again, clearly shows the manipulatino between the pre- and post measures.</p>
</div>
<div id="power-analysis-with-the-multivariate-normal" class="section level4">
<h4>Power-analysis with the multivariate normal</h4>
<p>Now that we know what we are doing when using <code>mvrnorm</code> we can go ahead and do a power-simulation for the example above with a bivariate normal-distribution.
However, as we are not sure how big our correlation is, we can try 3 different correlations in the code above by placing the simulation in another for-loop and telling it to try different correlations.</p>
<pre class="r"><code>mu_pre_post &lt;- c(pre = 0, post = 1)
sd_pre &lt;- 2
sd_post &lt;- 2
correlations &lt;- c(0.1, 0.5, 0.9)

set.seed(1)
n_sims &lt;- 1000 # we want 1000 simulations
p_vals &lt;- c()
# this vector will contain the power for each sample-size (it needs the initial 0 for the while-loop to work)
cohens_ds &lt;- c()

powers_at_cor &lt;- list()
cohens_ds_at_cor &lt;- list()

for(icor in 1:length(correlations)){ # do a power-simulation for each specified simulation
  n &lt;- 2 # sample-size 
  i &lt;- 2 # index of the while loop for saving things into the right place in the lists
  power_at_n &lt;- c(0) 
  cohens_ds_at_n &lt;- c() 
  sigma &lt;- matrix(c(sd_pre^2, sd_pre*sd_post*correlations[icor], sd_pre*sd_post*correlations[icor], sd_post^2), ncol = 2) #var-covar matrix
  while(power_at_n[i-1] &lt; .95){
    for(sim in 1:n_sims){
      bivnorm &lt;- data.frame(mvrnorm(n, mu_pre_post, sigma)) # simulate the bivariate normal
      p_vals[sim] &lt;- t.test(bivnorm$pre, bivnorm$post, paired = TRUE, var.equal = TRUE, conf.level = 0.9)$p.value # run t-test and extract the p-value
      cohens_ds[sim] &lt;- abs((mean(bivnorm$pre)-mean(bivnorm$post))/(sqrt(sd(bivnorm$pre)^2+sd(bivnorm$post)^2-2*cor(bivnorm$pre, bivnorm$post)*sd(bivnorm$pre)*sd(bivnorm$post)))) # we also save the cohens ds that we observed in each simulation
    }
    power_at_n[i] &lt;- mean(p_vals &lt; .10) # check power (i.e. proportion of p-values that are smaller than alpha-level of .10)
    names(power_at_n)[i] &lt;- n
    cohens_ds_at_n[i] &lt;- mean(cohens_ds) # calculate means of cohens ds for each sample-size
    names(cohens_ds_at_n)[i] &lt;- n
    n &lt;- n+1 # increase sample-size by 1
    i &lt;- i+1 # increase index of the while-loop by 1 to save power and cohens d to vector
  }
  power_at_n &lt;- power_at_n[-1] # delete first 0 from the vector
  cohens_ds_at_n &lt;- cohens_ds_at_n[-1] # delete first NA from the vector
  powers_at_cor[[icor]] &lt;- power_at_n # store the entire power curve for this correlation in a list
  cohens_ds_at_cor[[icor]] &lt;- cohens_ds_at_n # do the same for cohens d
  names(powers_at_cor)[[icor]] &lt;- correlations[icor] # name the power-curve in the list according to the tested correlation
  names(cohens_ds_at_cor)[[icor]] &lt;- correlations[icor] # same for cohens d
}</code></pre>
<p>Again, the above code runs a power-simulation, or more specifically three power-analyses, one for each correlation that we wanted to test.
Notice how this time we specify <code>paired = TRUE</code> in the <code>t.test</code> function, to indicate that we are dealing with non-independent observations.
Also note that a new part of the code saves the <code>power_at_n</code> vector to a list called <code>power_at_cor</code>.
This list, will have 3 elements, each of them the power curve for one of the correlations.
We can access each power-curve bei either <code>powers_at_cor[[1]]</code> to get the first vector in the list (the double square brackets mean first entire vector rather than first number only) or we can use it by indicating its name as <code>powers_at_cor$</code>0.1` to tell R that we want the power curve for a correlation of .10.</p>
<p>We can plot these power-curves next to each other</p>
<pre class="r"><code>par(mfrow=c(1,3))
plot(2:(length(powers_at_cor$`0.1`)+1), powers_at_cor$`0.1`, xlab = &quot;Number of participants&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = TRUE, main = &quot;correlation = 0.1&quot;)
abline(h = .95, col = &quot;red&quot;)
plot(2:(length(powers_at_cor$`0.5`)+1), powers_at_cor$`0.5`, xlab = &quot;Number of participants&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = TRUE, main = &quot;correlation = 0.5&quot;)
abline(h = .95, col = &quot;red&quot;)
plot(2:(length(powers_at_cor$`0.9`)+1), powers_at_cor$`0.9`, xlab = &quot;Number of participants&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = TRUE, main = &quot;correlation = 0.9&quot;)
abline(h = .95, col = &quot;red&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/powercurve_corr_t-test-1.png" width="120%" /></p>
<p>Here we see how drastically the correlation influences the power in this situation.
With a high correlation, we need only very few participants to achieve the desired power in the specified case.
Why is this?
The reason for this is what we had a look at above: The decreasing standard-deviation of the difference scores the higher the correlation gets.</p>
<p>This is how the effect-sizes look.</p>
<pre class="r"><code>par(mfrow=c(1,3))
plot(2:(length(cohens_ds_at_cor$`0.1`)+1), cohens_ds_at_cor$`0.1`, xlab = &quot;Number of participants&quot;, ylab = &quot;Cohens D&quot;, ylim = c(0,1), axes = TRUE, main = &quot;correlation = 0.1&quot;)
abline(h = .50, col = &quot;red&quot;)
plot(2:(length(cohens_ds_at_cor$`0.5`)+1), cohens_ds_at_cor$`0.5`, xlab = &quot;Number of participants&quot;, ylab = &quot;Cohens D&quot;, ylim = c(0,1), axes = TRUE, main = &quot;correlation = 0.5&quot;)
abline(h = .50, col = &quot;red&quot;)
plot(2:(length(cohens_ds_at_cor$`0.9`)+1), cohens_ds_at_cor$`0.9`, xlab = &quot;Number of participants&quot;, ylab = &quot;Cohens D&quot;, ylim = c(0,10), axes = TRUE, main = &quot;correlation = 0.9&quot;)
abline(h = .50, col = &quot;red&quot;)</code></pre>
<p><img src="/post/2020-05-12-power-analysis-by-data-simulation-in-r-part-ii_files/figure-html/cohens_d_corr_ttest-1.png" width="120%" /></p>
<p>For .10 the value of the effect-size seems slightly underestimated, for .50 it approaches .50 just as in the two-sample case and for .90 it seems overestimated by quite a bit.
Did something go wrong?
Well no. As we’ve seen above <span class="math inline">\(Cohen&#39;s\ d\)</span> is calculated by dividing the mean-difference by the standard-deviation of the difference scores which becomes smaller and smaller with increasing correlation.
Therefore, calculated this way, <span class="math inline">\(Cohen&#39;s\ d\)</span> is much bigger in the case with the larger correlation.
This is also why we seem to have much bigger power - we just work with a larger effect size than we intended.
We can even calculate by how much the effect-size is influenced by the correlation by dividing the effect-size that we would calculate based on the means and sds of our groups by <span class="math inline">\(\sqrt{2(1-r)}\)</span>.</p>
<p>r = .90 –&gt; <code>0.5/sqrt(2*(1-.90))</code> = 1.118034
r = .50 –&gt; <code>0.5/sqrt(2*(1-.50))</code> = 0.5
r = .10 –&gt; <code>0.5/sqrt(2*(1-.10))</code> = 0.372678</p>
<p>You might wonder how we can specify effect-sizes in these cases of correlated data. Do we “correct” the expected effect for the correlation or do we just assume that it is .50 and use the one-sample scenario above?
I do not have a good answer for this.
In many cases it might be fine to only specify the effect-size of the pre-post design based on the difference scores as we did in the one-sample case.
In some cases, however, we might find the correlation very important or have more information about the correlation of 2 measures than about the change in measures due to an intervention.
In those cases, it might make sense to be very specific about the expected correlations and be aware that we might need more data if the correlation is low.
Eventually, our data stem from an underlying <em>data generating process</em> that includes the correlation between variables and measures and it is always good to be aware of the factors that might possibly influence the results.
When we collect data in a pre-post design, we <em>do</em> in fact measure a score at 2 time-points and do not directly assess the difference.
When we specify the standard-deviation of the difference scores however, to arrive at a given <span class="math inline">\(Cohen&#39;s\ d\)</span>, we implicitely make assumptions about the correlations of these two measures.</p>
<p>The Take-home message here is that correlations matter and that we need to be aware of this. The good news is that power-simulations will at least make us aware of these factors and show us how different assumptions lead to different results.</p>
</div>
</div>
</div>
<div id="summary-our-first-simulations-with-t-tests" class="section level2">
<h2>Summary: Our first simulations with t-tests</h2>
<p>This was the last bit that I wanted to discuss about simulating t-tests and the end of part II of this tutorial.
We have now learned how to simulate a t-test by using either <span class="math inline">\(Cohen&#39;s\ d\)</span> as an effect-size estimate and, if necessary, tell <code>R</code> that our two groups, or measurements, are correlated in some way.
What we learned above is not restricted to doing t-tests however.
Simulating univariate (i.e. uncorrelated) or multivariate (i.e. correlated) normal-distributions will be what we do most of the time in part III and part IV of the tutorial.
The only thing that will change for more complicated designs is how we combine the different tools that we learned in this part to achieve our goal.</p>
<p>In part III of this tutorial, we will see how we can basically run every analysis as a linear model using the <code>lm</code> function instead of using the <code>t.test</code> function for t-tests, the <code>aov</code> function for ANOVA-designs and so forth.
By exploring how this works for t-test, anova and regression we will simulate our way through the third part and be flexible enough to simulate any classical research designs that we would, for example, be able to do in GPower. In part IV we will go beyond this and simulate mixed-effect models.</p>
</div>
</div>
<div id="footnotes" class="section level1">
<h1>Footnotes</h1>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Think back to the possible sequences of coin tosses in part I.
Instead of possible sequences of coin-tosses, we deal with possible sequences of people-scores here, assuming that they come from the underlying distribution that we specify.
To get a good approximation of all the possible samples that we could get that still follow the specified distribution, we need to simulate many, many times.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>This is how we solve for r:<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
<mtable displaystyle="true" columnalign="right left right left right left right left right left right left" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" rowspacing="3pt">
<mtr>
<mtd></mtd>
<mtd>
<mn>2</mn>
<mo>=</mo>
<msqrt>
<msup>
<mn>2</mn>
<mn>2</mn>
</msup>
<mo>+</mo>
<msup>
<mn>2</mn>
<mn>2</mn>
</msup>
<mo>−</mo>
<mn>2</mn>
<mi>r</mi>
<mo>×</mo>
<mn>2</mn>
<mo>×</mo>
<mn>2</mn>
</msqrt>
</mtd>
</mtr>
<mtr>
<mtd>
<mstyle scriptlevel="0">
<mspace width="thickmathspace"></mspace>
</mstyle>
<mo stretchy="false">⟺</mo>
<mstyle scriptlevel="0">
<mspace width="thickmathspace"></mspace>
</mstyle>
</mtd>
<mtd>
<mn>2</mn>
<mo>=</mo>
<msqrt>
<mn>8</mn>
<mo>−</mo>
<mn>8</mn>
<mi>r</mi>
</msqrt>
</mtd>
<mtd>
<mi></mi>
<msup>
<mo stretchy="false">|</mo>
<mn>2</mn>
</msup>
</mtd>
</mtr>
<mtr>
<mtd>
<mstyle scriptlevel="0">
<mspace width="thickmathspace"></mspace>
</mstyle>
<mo stretchy="false">⟺</mo>
<mstyle scriptlevel="0">
<mspace width="thickmathspace"></mspace>
</mstyle>
</mtd>
<mtd>
<mn>4</mn>
<mo>=</mo>
<mn>8</mn>
<mo>−</mo>
<mn>8</mn>
<mi>r</mi>
</mtd>
<mtd>
<mi></mi>
<mrow>
<mo stretchy="false">|</mo>
</mrow>
<mo>−</mo>
<mn>8</mn>
<mo>;</mo>
<mo>÷</mo>
<mo stretchy="false">(</mo>
<mo>−</mo>
<mn>8</mn>
<mo stretchy="false">)</mo>
</mtd>
</mtr>
<mtr>
<mtd>
<mstyle scriptlevel="0">
<mspace width="thickmathspace"></mspace>
</mstyle>
<mo stretchy="false">⟺</mo>
<mstyle scriptlevel="0">
<mspace width="thickmathspace"></mspace>
</mstyle>
</mtd>
<mtd>
<mn>0.5</mn>
<mo>=</mo>
<mi>r</mi>
</mtd>
</mtr>
</mtable>
</math><a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
]]>
      </description>
    </item>
    
    <item>
      <title>Power Analysis by Data Simulation in R - Part I</title>
      <link>/post/power-analysis-by-data-simulation-in-r-part-i/</link>
      <pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate>
      <guid>/post/power-analysis-by-data-simulation-in-r-part-i/</guid>
      <description><![CDATA[
        
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#power-analysis-by-data-simulation-in-r---part-i-theoretical-introduction-to-simulation">Power Analysis by Data Simulation in <code>R</code> - Part I: Theoretical introduction to simulation</a></li>
<li><a href="#back-to-power">Back to Power</a></li>
<li><a href="#finally-an-actual-power-simulation.">Finally, an actual power simulation.</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#footnotes">Footnotes</a></li>
</ul>
</div>

<html>
<link rel="stylesheet" href="/css/style.css" />
</html>
<p><div class="alert alert-note">
  <div>
    <!-- raw HTML omitted -->Click below to download the .Rmd file<!-- raw HTML omitted -->
  </div>
</div>
</p>
<a href="data:text/x-markdown;base64,LS0tDQp0aXRsZTogUG93ZXIgQW5hbHlzaXMgYnkgRGF0YSBTaW11bGF0aW9uIGluIFIgLSBQYXJ0IEkNCmF1dGhvcjogfg0KZGF0ZTogJzIwMjAtMDQtMjInDQpzbHVnOiBwb3dlci1hbmFseXNpcy1ieS1kYXRhLXNpbXVsYXRpb24taW4tci1wYXJ0LWkNCmNhdGVnb3JpZXM6IFtQb3dlciBBbmFseXNpc10NCnRhZ3M6IFtwb3dlciwgZGF0YS1zaW11bGF0aW9uXQ0Kc3VidGl0bGU6ICdQYXJ0IEkgLSB0aGVvcmV0aWNhbCBpbnRyb2R1Y3Rpb24gdG8gZGF0YS1zaW11bGF0aW9uJw0Kc3VtbWFyeTogJ1RoaXMgcGFydCBwcm92aWRlcyBhbiBpbnRyb2R1Y3Rpb24sIHNvbWUgYmFja2dyb3VuZCBvbiBwb3dlci1jYWxjdWxhdGlvbiBhbmQgZGF0YS1zaW11bGF0aW9uLicNCmF1dGhvcnM6IFtdDQpsYXN0bW9kOiAiYHIgZm9ybWF0KFN5cy50aW1lKCkpYCINCmZlYXR1cmVkOiBubw0KY29kZV9kb3dubG9hZDogdHJ1ZQ0KaW1hZ2U6DQogIGNhcHRpb246ICcnDQogIGZvY2FsX3BvaW50OiAnJw0KICBwcmV2aWV3X29ubHk6IG5vDQpwcm9qZWN0czogW1Bvd2VyIEFuYWx5c2lzIFR1dG9yaWFsXQ0Kb3V0cHV0Og0KICBibG9nZG93bjo6aHRtbF9wYWdlOg0KICAgIHRvYzogdHJ1ZQ0KICAgIHRvY19kZXB0aDogMQ0KLS0tDQoNCjxodG1sPg0KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iL2Nzcy9zdHlsZS5jc3MiIC8+DQo8L2h0bWw+DQoNCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQ0KcmVxdWlyZShrbml0cikNCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVCwgd2FybmluZyA9IEYsIGNhY2hlID0gVCkNCm9wdGlvbnMod2lkdGggPSA4MCkNCm9wdGlvbnMoc2NpcGVuID0gMTApDQojc291cmNlKCJjb21tb25fcGFja2FnZXMuUiIpDQpkZXZBc2tOZXdQYWdlKGFzayA9IEZBTFNFKQ0KYGBgDQoNCnt7JSBhbGVydCBub3RlICV9fQ0KX19DbGljayBiZWxvdyB0byBkb3dubG9hZCB0aGUgLlJtZCBmaWxlX18NCnt7JSAvYWxlcnQgJX19DQoNCmBgYHtyIGVjaG89RkFMU0V9DQp4ZnVuOjplbWJlZF9maWxlKCcuLzIwMjAtMDQtMjItcG93ZXItYW5hbHlzaXMtYnktZGF0YS1zaW11bGF0aW9uLWluLXItcGFydC1pLlJtZCcsICJwb3dlci1hbmFseXNpcy1ieS1kYXRhLXNpbXVsYXRpb24taW4tci1wYXJ0LWkuUm1kIikNCmBgYA0KDQoNCiMgUG93ZXIgQW5hbHlzaXMgYnkgRGF0YSBTaW11bGF0aW9uIGluIGBSYCAtIFBhcnQgSTogVGhlb3JldGljYWwgaW50cm9kdWN0aW9uIHRvIHNpbXVsYXRpb24gDQoNCg0KIyMgV2h5IHRoaXMgYmxvZz8NCg0KSW4gcmVjZW50IHllYXJzLCBwb3dlci1hbmFseXNpcyBoYXMgYmVjb21lIGEgc3RhbmRhcmQgdG9vbCBpbiB0aGUgYmVoYXZpb3JhbCBzY2llbmNlcy4gDQpXaXRoIGFuIG9uZ29pbmcgcmVwbGljYXRpb24gY3Jpc2lzLCBoaWdoLXBvd2VyIHJlc2VhcmNoIGlzIHRoZSBhIGtleSB0byBpbXByb3ZpbmcgcmVwbGljYWJpbGl0eSBhbmQgdG8gaW1wcm92aW5nIHRoZSByZWxpYWJpbGl0eSBvZiBmaW5kaW5ncy4NCkVzcGVjaWFsbHkgd2l0aCBwcmVyZWdpc3RyYXRpb24gc2xvd2x5IGJlY29taW5nIHN0YW5kYXJkIHByYWN0aWNlIGluIHBzeWNob2xvZ3ksIHBvd2VyLWFuYWx5c2lzLCB0aGUgcHJhY3RpY2Ugb2YgZXN0aW1hdGluZyB0aGUgcmVxdWlyZWQgc2FtcGxlLXNpemUgYS1wcmlvcmksIGlzIGEgbW9yZSBpbXBvcnRhbnQgc3RlcCB0aGFuIGV2ZXIgdG8gcGxhbiByZXNlYXJjaCBwcm9qZWN0cyBhY2NvcmRpbmdseS4NCg0KTm90IHNvIGxvbmcgYWdvLCBwb3dlci1hbmFseXNpcyB3YXMgYSByYXRoZXIgY29tcGxpY2F0ZWQgZW5kZWF2b3IgdXJnaW5nIHBlb3BsZSB0byB1c2UgYWxnZWJyYWljIHNvbHV0aW9ucyB0byBjYWxjdWxhdGUgcG93ZXIgb2YgcGxhbm5lZCBzdHVkaWVzIHdoaWNoIGNhbiBiZSBkZW1hbmRpbmcgZXNwZWNpYWxseSBmb3Igbm9uLXRyaXZpYWwgZGVzaWducyAoaS5lLiBiYXNpY2FsbHkgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBjb3JyZWxhdGlvbikuDQpMdWNraWx5LCBmb3IgbWFueSByZXNlYXJjaCBkZXNpZ25zIHBvd2VyLWFuYWx5c2lzIGlzIG5vd2FkYXlzIHJlYWRpbHkgYXZhaWxhYmxlIGluIHNvZnR3YXJlIHBhY2thZ2VzIHN1Y2ggYXMgW0cqUG93ZXJdKGh0dHA6Ly93d3cuZ3Bvd2VyLmhodS5kZS8pIGFuZCBldmVuIGZvciByZWxhdGl2ZWx5IGNvbXBsZXggZGVzaWducyBpbiBzcGVjaWFsaXplZCB0b29scyBzdWNoIGFzIHRoZSBfZ3JlYXRfIFtQQU5HRUFdKGh0dHBzOi8vamFrZXdlc3RmYWxsLnNoaW55YXBwcy5pby9wYW5nZWEvKSB0b29sIGZvciBhbGwga2luZHMgb2YgZ2VuZXJhbGl6ZWQgQU5PVkEgZGVzaWducyBhbmQgb3RoZXIgdG9vbHMgYnkgW0pha2UgV2VzdGZhbGxdKGh0dHA6Ly9qYWtld2VzdGZhbGwub3JnLykuDQoNCkhvd2V2ZXIsIHdoaWxlIHRoZXNlIHRvb2xzIGFyZSByZWFsbHkgZ3JlYXQgdGhleSBhbHNvIGhhdmUgKGluIG15IHBlcnNvbmFsIG9waW5pb24pIHR3byBkcmF3YmFja3MuDQpGaXJzdCwgdGhleSB1cmdlIHRoZSB1c2VyIHRvIGZhbWlsaWFyaXplIHRoZW1zZWx2ZXMgd2l0aCBhIG5ldyBwaWVjZSBvZiBzb2Z0d2FyZSB3aXRoIG5ldyB1c2VyIGludGVyZmFjZXMsIHRoYXQgYXJlIG5vdCBhbHdheXMgaW50dWl0aXZlLg0KU2Vjb25kLCBhbmQgbW9yZSBpbXBvcnRhbnRseSwgdGhlc2UgaW50ZXJmYWNlcyBwcm9tb3RlIGEgc3RhdGlzdGljYWwgd2F5IG9mIHRoaW5raW5nIHRoYXQgb2Z0ZW4gbGVhdmVzIHRoZSB1c2VyIGNvbmZ1c2VkIHdpdGggd2hhdCB0aGUgZXZlci1jaGFuZ2luZyBwYXJhbWV0ZXJzICh0aGluayBvZiB0aGVzZSAkXGRlbHRhJCAsICRkJCwgJGYkLCAkZl4yJCBhbmQgdmFndWUgImdyb3VwLXNpemUiIGFuZCAibWVhc3VyZW1lbnQtcG9pbnQiIGZpZWxkcykgdGhhdCBuZWVkIHRvIGJlIGZpbGxlZCBpbiBtZWFuLg0KTW9yZW92ZXIsIHRoZXNlIHBhcmFtZXRlcnMgZGlmZmVyIGZvciBtb3N0IGRlc2lnbnMgYW5kIGdpdmUgYW4gaW1wcmVzc2lvbiB0aGF0IHBvd2VyLWFuYWx5c2lzIGlzIGNvbXBsaWNhdGVkIGJ1c2luZXNzIGJldHRlciBsZWZ0IHRvIHN0YXRpc3RpY2lhbnMgb3IgdGhhdCBpdCBtaWdodCBub3QgYmUgd29ydGggdGhlIGVmZm9ydC4NCg0KDQo8ZmlndXJlPg0KICA8aW1nIHNyYz0iL2ltZy9wb3dlci10dXRvcmlhbC9tZS1kb2luZy1wYS5qcGciIGFsdD0iZHJhd2luZyIgd2lkdGg9IjUwMCIvPg0KICA8ZmlnY2FwdGlvbj5fRmlndXJlIDEuIE1lIHRyeWluZyB0byBmaWd1cmUgb3V0IGhvdyB0byB1c2UgYSBzdGFuZGFyZCBwb3dlci1hbmFseXNpcyBzb2Z0d2FyZS5fPC9maWdjYXB0aW9uPg0KPGZpZ3VyZT4NCg0KSG93ZXZlciwgdGhpcyBpbXByZXNzaW9uIGNoYW5nZWQgZHJhbWF0aWNhbGx5IGZvciBtZSwgb25jZSBJIGNoYW5nZWQgbXkgd2F5cyBhbmQgc3RhcnRlZCBkb2luZyBwb3dlciBhbmFseXNpcyBieSBzaW11bGF0aW9uLg0KTW9yZW92ZXIsIGxlYXJuaW5nIGhvdyB0byBzaW11bGF0ZSBkYXRhIGNhbiBvZiBjb3Vyc2Ugbm90IG9ubHkgYmUgb2YgdXNlIGZvciBwb3dlciBhbmFseXNpcyBidXQgaXMgYSB1c2VmdWwgc2tpbGwgdG8gaW4gZXZlcnkgcmVzZWFyY2ggcHJvamVjdC4NCldoZW4gd2Ugc2ltdWxhdGUgZGF0YSwgd2UgY2FuIHNlZSB3aGV0aGVyIHdoYXQgd2UgX3RoaW5rXyBhYm91dCB0aGUgZGF0YS1nZW5lcmF0aW5nIHByb2Nlc3Mgd2lsbCBhY3R1YWxseSBfcmVzdWx0XyBpbiB0aGUgcGF0dGVybnMgdGhhdCB3ZSB3b3VsZCBleHBlY3QuDQpJbiBvdGhlciB3b3Jkcywgd2UgY2FuIGRvIHRoZW9yZXRpY2FsIGV4cGVyaW1lbnRzIHRvIHNlZSB3aGV0aGVyIGlmIGV2ZXJ5dGhpbmcgZ29lcyBhcyB3ZSB3b3VsZCBleHBlY3QsIHdlIHdvdWxkIGFsc28gZmluZCB0aGUgcmVzdWx0cyB0aGF0IHdlIHdvdWxkIGV4cGVjdC4NCkVzcGVjaWFsbHkgd2hlbiBvdXIgYW5hbHlzZXMgYmVjb21lIG1vcmUgY29tcGxleCwgYWxsIHRoZSBkaWZmZXJlbnQgcGFydHMgaW4gb3VyIG1vZGVsIHRlbmQgdG8gaW50ZXJhY3QgYW5kIGl0IGlzIGVhc3kgdG8gZ2V0IGxvc3QuDQpCeSBzaW11bGF0aW5nIGRhdGEgYmVmb3JlIGNvbmR1Y3RpbmcgYW4gZXhwZXJpbWVudCwgd2Ugd2lsbCBiZSBmb3JjZWQgKGFuZCBhYmxlKSB0byBzcGVjaWZ5IG1vcmUgcHJlY2lzZWx5IGhvdyB3ZSB0aGluayBhIHRoZW9yZXRpY2FsIG1vZGVsIG9yIHByZWRpY3Rpb24gd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlIGRhdGEuDQoNClRodXMsIGV2ZW4gdGhvdWdoIHRoaXMgdHV0b3JpYWwgd2lsbCBmb2N1cyBvbiBzaW11bGF0aW5nIGRhdGEgZm9yIHBvd2VyIGFuYWx5c2lzLCB5b3Ugd2lsbCBsZWFybiBhIHZlcnkgdXNlZnVsIHNraWxsIG9uIHRoZSBzaWRlIC0gc2ltdWxhdGluZyB5b3VyIG93biBkYXRhIGFuZCB0aGVyZWJ5IGNvbmR1Y3RpbmcgdGhlb3JldGljYWwgZXhwZXJpbWVudHMgYmVmb3JlIHlvdSBldmVuIGNvbGxlY3QgZGF0YS4NCkkga25vdyB0aGF0IHRoZXJlIGFyZSBhbHJlYWR5IHNvbWUgZXhjZWxsZW50IHR1dG9yaWFscyBvbiBkYXRhL3Bvd2VyLXNpbXVsYXRpb24gb3V0IHRoZXJlIGJ1dCB0aGV5IGFyZSBvZnRlbiB2ZXJ5IGJyaWVmIGFuZC9vciB0ZWNobmljYWwgYW5kIGFzc3VtZSBhIHJhdGhlciBoaWdoIGxldmVsIG9mIHByaW9yIGtub3dsZWRnZSBhYm91dCBgUmAgYW5kIGRhdGEtc2ltdWxhdGlvbiBpbiBnZW5lcmFsLg0KVGhlcmVmb3JlLCBJIHdpbGwgc3BlbmQgc29tZSB0aW1lIG9uIGV4cGxhaW5pbmcgdGhlb3JldGljYWwgY29uY2VwdHMgYW5kIHNsb3dseSBidWlsZCB1cCB0aGUgc2ltdWxhdGlvbi1jb2RlIHRvIGhvcGVmdWxseSBlbmFibGUgdGhlIHJlYWRlciB0byB1bmRlcnN0YW5kIHRoZSB1bmRlcmx5aW5nIHByaW5jaXBsZXMgYW5kIGZsZXhpYmx5IGNvbmR1Y3QgcG93ZXIgc2ltdWxhdGlvbnMgdGhlbXNlbHZlcyBhZnRlciByZWFkaW5nIHRoaXMuDQoNClRocm91Z2hvdXQgdGhlIHR1dG9yaWFsIEkgYXNzdW1lIHJlYWRlcnMgYXJlIGZhbWlsaWFyIHdpdGggYFJgIGFuZCBzb21lIG9mIGl0J3MgYmFzZSBmdW5jdGlvbmFsaXR5Lg0KVGhpcyB0dXRvcmlhbCB3aWxsIGNvbnNpc3Qgb2YgZm91ciBkaWZmZXJlbnQgcGFydHMuDQoNCiogSW4gdGhlIGZpcnN0IHBhcnQgKHRoZSBvbmUgeW91IGFyZSByZWFkaW5nKSBJIHdpbGwgZ2l2ZSBhIHNob3J0IG92ZXJ2aWV3IG9mIGhvdyBwb3dlci1hbmFseXNpcyBieSBzaW11bGF0aW9uIHdvcmtzIG9uIGEgY29uY2VwdHVhbCBsZXZlbCBhbmQgd2h5IEkgcHJlZmVyIGl0IHRvIGF2YWlsYWJsZSBwb3dlci1hbmFseXNpcyBzb2Z0d2FyZSwgZXZlbiB0aG91Z2ggdGhlcmUgYXJlIGNsZWFyIGRyYXdiYWNrcyB0aGF0IEkgd2lsbCBhbHNvIGJyaWVmbHkgbWVudGlvbi4NCk1vcmVvdmVyLCBJIHdpbGwgaW50cm9kdWNlIHRoZSBjb25jZXB0IG9mIHBvd2VyIGFzIEkgd2FudCB0byBicmluZyB1cyBhbGwgb24gdGhlIHNhbWUgcGFnZSBhbmQgd2FudCB0byBnaXZlIGEgKGhvcGVmdWxseSkgaW50dWl0aXZlIGV4YW1wbGUgYWJvdXQgd2hhdCB3ZSBhY3R1YWxseSBkbyBpbiBwb3dlciBjYWxjdWxhdGlvbiBhbmQgaG93IGl0IHJlbGF0ZXMgdG8gdGhlIHNpbXVsYXRpb24gdGVjaG5pcXVlcyB0aGF0IHdlIHdpbGwgdXNlIGZvciB0aGUgcmVzdCBvZiB0aGUgdHV0b3JpYWwuDQoqIEluIHRoZSBzZWNvbmQgcGFydCwgSSB3aWxsIGRpc2N1c3Mgc2ltdWxhdGlvbnMgZm9yIHRoZSBzaW1wbGVzdCBjYXNlIG9mIHBhaXJlZCBhbmQgdHdvLXNhbXBsZSB0LXRlc3RzLg0KKiBJbiB0aGUgdGhpcmQgcGFydCwgd2Ugd2lsbCBleHBsb3JlIGRpZmZlcmVudCBBTk9WQSBhbmQgcmVncmVzc2lvbiBkZXNpZ25zLg0KKiBJbiB0aGUgZm91cnRoIHBhcnQgd2Ugd2lsbCBtb3ZlIG9uIHRvIG1vcmUgY29tcGxleCBtaXhlZC1lZmZlY3RzIGFuZCBoaWVyYXJjaGljYWwgbW9kZWxzIGFuZCBldmVuIGhhdmUgYSBwZWFrIGF0IEJheWVzaWFuIGFwcHJvYWNoZXMgdG8gcG93ZXIgYW5hbHlzaXMgKHdlbGwgdGVjaG5pY2FsbHkgaXRzIG5vdCBhIHBvd2VyIGFuYWx5c2lzIGJ1dCBhIHRydWUgZGV0ZWN0aW9uIHJhdGUgYW5hbHlzaXMpLg0KRm9yIHRoaXMgZm91cnRoIHBhcnQsIEkgYXNzdW1lIHJlYWRlcnMgd2lsbCBiZSBmYW1pbGlhciB3aXRoIGhvdyB0byBmaXQgbWl4ZWQtZWZmZWN0IG1vZGVscyBpbiBgbG1lcmAgYW5kL29yIGBicm1zYC4NCg0KVGhpcyBwYXJ0IG9mIHRoZSB0dXRvcmlhbCBpcyBieSBmYXIgdGhlIG1vc3Qgd29yZHkgYW5kIGxvbmdlc3QgcGFydC4gDQpKdXN0IGFzIGEgbGl0dGxlIG1vdGl2YXRvciB0byBrZWVwIGluIG1pbmQgZHVyaW5nIHRoaXMgc29tZXRpbWVzIGxlbmd0aHkgdHV0b3JpYWw6DQpBdCB0aGUgZW5kIG9mIHBhcnQgSVYgb2YgdGhpcyB0dXRvcmlhbCwgeW91IHdpbGwga25vdyBob3cgdG8gZG8geW91ciBvd24gY3VzdG9tIHBvd2VyIGFuYWx5c2lzIGZvciBtaXhlZC1lZmZlY3RzIG1vZGVscy4NCg0KIyMgUG93ZXIgQW5hbHlzaXMgYnkgU2ltdWxhdGlvbiAoYSBzdXN0YWluYWJsZSBhbHRlcm5hdGl2ZSkNCg0KPGZpZ3VyZT4NCiAgPGltZyBzcmM9Ii9pbWcvcG93ZXItdHV0b3JpYWwvbmV3LXBvd2VyLmpwZyIgd2lkdGg9IjUwMCIvPg0KICA8ZmlnY2FwdGlvbj5fRmlndXJlIDIuIFRoZSBwcm9vZiB0aGF0IHRoZXJlIGFyZSBhbHRlcm5hdGl2ZSB3YXlzIHRvIGhvdyB3ZSBub3JtYWxseSBnZXQgb3VyIHBvd2VyLl88L2ZpZ2NhcHRpb24+DQo8ZmlndXJlPg0KDQojIyBXaGF0IGlzIHBvd2VyIGFnYWluPyBBIH5+YnJpZWZ+fiBpbnRyb2R1Y3Rpb24gey50YWJzZXQgLnRhYnNldC1mYWRlIC50YWJzZXQtcGlsbHN9DQoNCkFzIG15IGludGVudGlvbiBpcyB0byBrZWVwIHRoaXMgcG9zdCBhcyBzaG9ydCBhcyBwb3NzaWJsZSAoU1BPSUxFUjogd2hpY2ggZGVmaW5pdGVseSBkaWQgbm90IHdvcmspLCBsZXQncyBkaXJlY3RseSBkaXZlIGludG8gdGhlIHRvcGljIGJ5IGhhdmluZyBhIGxvb2sgYXQgdGhlIGRlZmluaXRpb24gb2YgcG93ZXI6DQoNCl9fSWYgYSBjZXJ0YWluIGVmZmVjdCBvZiBpbnRlcmVzdCBleGlzdHMgKGUuZy4gYSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGdyb3VwcykgcG93ZXIgaXMgdGhlIGNoYW5jZSB0aGF0IHdlIGFjdHVhbGx5IGZpbmQgdGhlIGVmZmVjdCBpbiBhIGdpdmVuIHN0dWR5Ll9fDQoNClRvIHByb3ZpZGUgc29tZSBpbnR1aXRpb24gYWJvdXQgcG93ZXIsIGxldHMgYXNzdW1lIHlvdSB0b3NzIGEgY29pbiAxMCB0aW1lcyBhbmQgeW91IGdldCAxMCBoZWFkcy4gDQpTaG91bGQgeW91IGJlIHN1cnByaXNlZCBhYm91dCB0aGlzPw0KSW50dWl0aXZlbHksIGl0IG1ha2VzIHNlbnNlIHRoYXQgd2Ugc2hvdWxkIGJlIG1vcmUgc3VycHJpc2VkIHRoZSBtb3JlIG9mdGVuIHdlIHRvc3MgdGhlIGNvaW4gYW5kIGl0IGtlZXBzIGxhbmRpbmcgb24gaGVhZC4gMTAgb3V0IG9mIDEwIGhlYWRzIHdvdWxkIGZvciBleGFtcGxlIGJlIGxlc3Mgc3VycHJpc2luZyB0aGFuIDEwLDAwMCBvdXQgb2YgMTAsMDAwLCByaWdodD8NClRoaXMgaXMgZXhhY3RseSB0aGUgcXVlc3Rpb24gd2Ugd2FudCB0byBhbnN3ZXIgd2hlbiB3aXRoIHBvd2VyIGFuYWx5c2lzW14xXS4gDQpIb3cgb2Z0ZW4gc2hvdWxkIHdlIHRvc3MgdGhlIGNvaW4gdW50aWwgd2UgYXJlIHN1cnByaXNlZCBlbm91Z2ggdG8gY29uY2x1ZGUgdGhhdCB0aGUgY29pbiBpcyBub3QgZmFpci4NCg0KVG8gdHJhbnNsYXRlIHRoZSBhYm92ZSBzaXR1YXRpb24gaW50byBhIEZyZXF1ZW50aXN0IG51bGwtaHlwb3RoZXNpcyBzaWduaWZpY2FuY2UgdGVzdGluZyAoTkhTVCkgc2NlbmFyaW8sIHdlIGh5cG90aGVzaXplIHRoYXQgdGhlIGNvaW4gX2lzXyBpbmRlZWQgZmFpciAobnVsbC1oeXBvdGhlc2lzKSBhbmQgc2VlIHdoZXRoZXIgb3Igbm90IHRoZSBvYnNlcnZlZCBudW1iZXIgb2YgaGVhZHMgKHRoZSBvYnNlcnZlZCBkYXRhKSBmaXRzIHdpdGggdGhpcyBoeXBvdGhlc2lzIG9yIG5vdC4gSWYgeWVzLCB3ZSB3aWxsIHJldGFpbiB0aGUgbnVsbC1oeXBvdGhlc2lzIHRoYXQgdGhlIGNvaW4gaXMgZmFpciwgaWYgbm90LCB3ZSB3aWxsIGNvbmNsdWRlIHRoYXQgdGhlIGRhdGEgYXJlIHZlcnkgdW5saWtlbHkgdG8gcmVzdWx0IGZyb20gdG9zc2luZyBhIGZhaXIgY29pbi4NCg0KSG93IGRvIHdlIGRvIHRoaXM/IA0KV2VsbCwgYXNzdW1lIHdlIG9ic2VydmVkIDMgaGVhZHMgb3V0IG9mIDMgdG90YWwgdG9zc2VzLiANCk5vdyB3ZSBjYW4gY291bnQgYWxsIHdheXMgdGhhdCB0aGlzIGNvdWxkIGhhdmUgaGFwcGVuZWQgd2l0aCBhIGZhaXIgY29pbiBhbmQgY29tcGFyZSBpdCB0byBhbGwgcG9zc2libGUgb3V0Y29tZXMgdGhhdCBvdXIgY29pbiB0b3NzIGV4cGVyaW1lbnQgbWlnaHQgaGF2ZSBwcm9kdWNlZC4gDQpUaGVzZSBwb3NzaWJpbGl0aWVzIGFyZSAoZm9yIGEgZmFpciBjb2luIG9yIGFueSBjb2luIHRoYXQgY2Fubm90IHByb2R1Y2Ugb25seSBoZWFkcyBvciBvbmx5IHRhaWxzKToNCg0KfCAgICAgICAgICAgICAgICB8IFRvc3MgIzEgfCBUb3NzICMyIHwgVG9zcyAjMyB8IG51bWJlciBvZiBoZWFkcyB8DQp8LS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwNCnwgUG9zc2liaWxpdHkgIzEgfCBIRUFEICAgIHwgSEVBRCAgICB8IEhFQUQgICAgfCAzICAgICAgICAgICAgICAgfA0KfCBQb3NzaWJpbGl0eSAjMiB8IEhFQUQgICAgfCBIRUFEICAgIHwgVEFJTCAgICB8IDIgICAgICAgICAgICAgICB8DQp8IFBvc3NpYmlsaXR5ICMzIHwgSEVBRCAgICB8IFRBSUwgICAgfCBUQUlMICAgIHwgMSAgICAgICAgICAgICAgIHwNCnwgUG9zc2liaWxpdHkgIzQgfCBUQUlMICAgIHwgVEFJTCAgICB8IFRBSUwgICAgfCAwICAgICAgICAgICAgICAgfA0KfCBQb3NzaWJpbGl0eSAjNSB8IFRBSUwgICAgfCBUQUlMICAgIHwgSEVBRCAgICB8IDEgICAgICAgICAgICAgICB8DQp8IFBvc3NpYmlsaXR5ICM2IHwgVEFJTCAgICB8IEhFQUQgICAgfCBIRUFEICAgIHwgMiAgICAgICAgICAgICAgIHwNCnwgUG9zc2liaWxpdHkgIzcgfCBUQUlMICAgIHwgSEVBRCAgICB8IFRBSUwgICAgfCAxICAgICAgICAgICAgICAgfA0KfCBQb3NzaWJpbGl0eSAjOCB8IEhFQUQgICAgfCBUQUlMICAgIHwgSEVBRCAgICB8IDIgICAgICAgICAgICAgICB8DQoNCg0KTm90aWNlIHRoYXQgYSBwb3NzaWJpbGl0eSBpcyBub3Qgb25seSBkZWZpbmVkIGJ5IHRoZSBudW1iZXIgb2YgaGVhZHMgYW5kIHRhaWxzIGJ1dCBhbHNvIGJ5IHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IG9jY3VyW14yXS4gV2UgY2FuIGFsc28gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgcG9zc2liaWxpdGllcyBhcyAkMl54JCB3aGVyZSAyIG1lYW5zIHRoYXQgd2UgaGF2ZSAyIHBvc3NpYmxlIG91dGNvbWVzIHBlciB0b3NzIGFuZCAkeCQgaXMgdGhlIG51bWJlciBvZiB0b3NzZXMuIEluIHRoaXMgY2FzZSB0aGUgbnVtYmVyIG9mIHBvc3NpYmlsaXRpZXMgaXMgdGhlcmVmb3JlICQyXjMgPSA4JC4NCk9ubHkgMSBvZiB0aGVzZSA4IGV2ZW50cyAoUG9zc2liaWxpdHkgMSkgY2FuIHByb2R1Y2UgMyBvdXQgb2YgMyBoZWFkcy4gDQpJZiBvdXIgY29pbiBpcyBmYWlyLCBlYWNoIG9mIHRoZXNlIGV2ZW50cyBzaG91bGQgYmUgZXF1YWxseSBsaWtlbHkgYW5kIHdlIGNhbiBzZWUgdGhhdCB3aGVuIGZsaXBwaW5nIGEgZmFpciBjb2luIDMgdGltZXMsIGluIG9ubHkgMSBvdXQgb2YgOCBjYXNlcyAoMTIuNSUpIHdlIHdpbGwgZ2V0IDMgaGVhZHMgKFBvc3NpYmlsaXR5IDEpLiANCg0KRG8gd2UgZmluZCB0aGlzIHN1cnByaXNpbmcgZW5vdWdoIHRvIGNvbmNsdWRlIHRoYXQgdGhlIGNvaW4gdGhhdCB3ZSBmbGlwcGVkIGlzIHVuZmFpcj8gDQpNYXliZSwgbWF5YmUgbm90Lg0KSWYgbm90LCBpbnN0ZWFkIG9mIGZsaXBwaW5nIHRoZSBjb2luIHRocmVlIHRpbWVzLCB3ZSBjb3VsZCBmbGlwIGl0IDEwMCB0aW1lcy4gDQpJbWFnaW5lIHdlIG9ic2VydmVkIDU1IGhlYWRzIGluIDEwMCBmbGlwcy4NCldlIGNvdWxkIG5vdyBzdGFydCB3cml0aW5nIGRvd24gYWxsIHBvc3NpYmxlIG91dGNvbWVzLCBidXQgdGhhdCB3b3VsZCB0YWtlIHNvbWUgdGltZS4gDQpUaGlzIHRpbWUsIHRoZXJlIGFyZSBub3QgOCBidXQgJDJeezEwMH0kID0gMSwyNjcsNjUxLDAwMCwwMDAsMDAwLDAwMCwwMDAsMDAwLDAwMCwwMDAgcG9zc2libGUgc2VxdWVuY2VzIG9mIGhlYWRzIGFuZCB0YWlscywgYW5kIHdlIHdvdWxkIGhhdmUgdG8gY291bnQgdGhlIG9uZXMgdGhhdCBwcm9kdWNlIF9hdCBsZWFzdF8gNTUgaGVhZHMgdG8gc2VlIGhvdyBvZnRlbiB0aGF0IHdvdWxkIGhhcHBlbiBpZiBvdXIgY29pbiBpcyBmYWlyW14zXS4NCg0KSG93ZXZlciwgbHVja2lseSB3ZSBhcmUgbm90IHRoZSBmaXJzdCB3aG8gYXJlIGludGVyZXN0ZWQgaW4gdGhlc2Uga2luZCBvZiBwcm9ibGVtcyBhbmQgd2UgY2FuIG1ha2UgdXNlIG9mIG1hdGhlbWF0aWNhbCBmb3JtdWxhcyB0aGF0IG90aGVyIHBlb3BsZSBmaWd1cmVkIG91dCBmb3IgdXMuDQoNCkluIHRoaXMgY2FzZSB3ZSBuZWVkIHRoZSBfX2Jpbm9taWFsX18gcHJvYmFiaWxpdHkgbWFzcyBmdW5jdGlvbi4NCkluIHNob3J0LCB0aGlzIGZ1bmN0aW9uIGRlZmluZXMgaG93IG9mdGVuIHdlIGNhbiBnZXQgZWFjaCBvdXRjb21lLCBhc3N1bWluZyBhIGNlcnRhaW4gY2hhbmNlIG9mIGdldHRpbmcgaGVhZHMgb3IgdGFpbHMuIA0KSWYgeW91IGFyZSBpbnRlcmVzdGVkIGluIHNlZWluZyB0aGlzIGZ1bmN0aW9uIGFuZCBzZWUgaG93IHdlIGNhbiBoYW5kLWNvZGUgaXQgaW4gYFJgLCB0aGVuIGNsaWNrIG9uIHRoZSBpbmZvLWJveCBiZWxvdy4NCklmIHlvdSBkbyBub3Qgd2FudCB0byBnZXQgdG9vIG11Y2ggaW50byB0aGUgdGVjaG5pY2FsaXRpZXMgaGVyZSwgeW91IGNhbiBhbHNvIGp1c3QgcmVhZCBvbi4NCg0KPC9icj4NCg0KDQo8ZGV0YWlscz4NCjxzdW1tYXJ5Pg0Ke3slIGFsZXJ0IG5vdGUgJX19DQpfX0NsaWNrIGhlcmUgdG8gZXh0ZW5kIGluZm9ybWF0aW9uIGFib3V0IHRoZSBiaW5vbWlhbCBsaWtlbGlob29kIGZ1bmN0aW9uX18NCnt7JSAvYWxlcnQgJX19DQo8L3N1bW1hcnk+DQoNCg0KPGRpdiBjbGFzcyA9ICJub3RlYm94Ij4NCjxwPg0KDQokJFAoeCk9XGZyYWN7TiF9e3ghKE4teCkhfVxwaV54KDEtXHBpKV57Ti14fSAkJA0KDQpGb3IgcGVvcGxlIHdobyBhcmUgbm90IHVzZWQgdG8gbWF0aGVtYXRpY2FsIGZvcm11bGFzLCB0aGlzIG1pZ2h0IGFscmVhZHkgbG9vayBpbnRpbWlkYXRpbmcuIEhvd2V2ZXIsIGFsbCB3ZSBuZWVkIHRvIGtub3cgcmlnaHQgbm93IGlzIHRoYXQgdGhpcyBmb3JtdWxhIGdpdmVzIHVzIHRoZSBwcm9iYWJpbGl0eSBvZiBnZXR0aW5nIHggaGVhZHMgJFB7KHgpfSQgKGkuZS4gdGhlIG51bWJlciBvZiB3YXlzIHdlIGdldCB4IGhlYWRzIGRpdmlkZWQgYnkgTiB0b3NzZXMpOg0KTm90ZSB0aGF0ICRccGkkIGluIHRoZSBhYm92ZSBmb3JtdWxhIGlzIG5vdCB0aGUgb25lIHdlIG1pZ2h0IGtub3cgZnJvbSBnZW9tZXRyeSBidXQgaXQgaXMgc2ltcGx5IHRoZSBHcmVlayBsZXR0ZXIgZm9yIHAgZGVub3RpbmcgYSBwcm9iYWJpbGl0eSBoZXJlLg0KSW4gdGhpcyBjYXNlLCBpdCBpcyB0aGUgcHJvYmFiaWxpdHkgb2YgZWl0aGVyIGV2ZW50LCBoZWFkcyBvciB0YWlscywgaGFwcGVuaW5nIG9uIGVhY2ggdG9zcyBzbyBpdCBpcyA1MCUgb3IgMC41Lg0KV2UgY2FuIGZpbGwgdGhpcyBpbiBmb3IgdGhlIGV4YW1wbGUgYWJvdmU6DQoNCiQkUCg1NSk9XGZyYWN7MTAwIX17NTUhKDEwMC01NSkhfTAuNV57NTV9KDEtMC41KV57MTAwLTU1fSQkDQoNClRyYW5zbGF0aW5nIHRoaXMgZm9ybXVsYSBpbnRvIGBSYCBzeW50YXggd2UgZ2V0IHRoZSBmb2xsb3dpbmc6DQoNCmBmYWN0b3JpYWwoMTAwKS8oZmFjdG9yaWFsKDU1KSpmYWN0b3JpYWwoMTAwLTU1KSkqMC41XjU1KigxLTAuNSleKDEwMC01NSlgID0gYHIgcm91bmQoZmFjdG9yaWFsKDEwMCkvKGZhY3RvcmlhbCg1NSkqZmFjdG9yaWFsKDEwMC01NSkpKjAuNV41NSooMS0wLjUpXigxMDAtNTUpLDIpYA0KDQpIb3dldmVyLCBiZWZvcmUgd2Ugc2FpZCB0aGF0IHdlIGRvIG5vdCBuZWVkIHRoZSBwcm9iYWJpbGl0eSBvZiBfZXhhY3RseV8gNTUgaGVhZHMgYnV0IGV2ZXJ5dGhpbmcgdGhhdCBpcyBfYXQgbGVhc3QgNTVfLiBJbiBvcmRlciB0byBhbnN3ZXIgb3VyIHF1ZXN0aW9uIGhvdyBvZnRlbiB3ZSBnZXQgX2F0IGxlYXN0XyA1NSBoZWFkcywgd2UgY291bGQgcmVwZWF0IHRoZSBhYm92ZSBjYWxjdWxhdGlvbiB3aXRoIGFsbCB2YWx1ZXMgZnJvbSA1NSB1cCB1bnRpbCAxMDAgYW5kIGFkZCB1cCB0aGUgcHJvYmFiaWxpdGllcyB0aGF0IHdlIGdldC4gDQoNCkZvciBleGFtcGxlIHdlIGNvdWxkIGRvIHRoaXMgd2l0aCBhIGZvci1sb29wOg0KDQpgYGB7ciBwX2Jpbm9tX21hbnVhbH0NCg0KIyBmaXJzdCB3ZSB3cml0ZSBhIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlcyB0aGUgcHJvYmFiaWxpdHkgZm9yIGVhY2ggbnVtYmVyIHNvIHdlIGNhbiBjYWxsIGl0IGluIGEgbG9vcA0KcGJpbm9tMiA8LSBmdW5jdGlvbihOLCB4LCBwKXsNCiAgZmFjdG9yaWFsKE4pLyhmYWN0b3JpYWwoeCkqZmFjdG9yaWFsKE4teCkpKnBeeCooMS1wKV4oTi14KQ0KfQ0KDQp0b3NzZXNfNTV0bzEwMCA8LSBjKDU1OjEwMCkgICMgd2UgZGVmaW5lIHRoZSBhbW91bnQgb2YgaGVhZHMgdGhhdCB3ZSB3YW50IHRvIGNoZWNrIGZvciAoYWxsIGJpZ2dlciB0aGFuIG9yIGVxdWFsIHRvIDU1KQ0KcHJvYnMgPC0gYygpICMgd2Ugd2lsbCBtYWtlIGFuIGVtcHR5IGNvbGxlY3Rpb24gdGhhdCB3ZSB3aWxsIGFkZCB0aGUgcmVzdWx0cyBmb3IgZWFjaCBudW1iZXIgb2YgaGVhZHMgdG8NCg0KZm9yKGkgaW4gdG9zc2VzXzU1dG8xMDApew0KICBwcm9icyA8LSBhcHBlbmQocHJvYnMsIHBiaW5vbTIoMTAwLGksLjUpKQ0KfQ0KcHJpbnQocHJvYnNbMToxMF0pDQpgYGANCg0KTm93IHdlIGdvdCBhbGwgdGhlIHByb2JhYmlsaXRpZXMgZm9yIGVhY2ggb2YgdGhlIGFtb3VudHMgb2YgaGVhZHMgdGhhdCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi4NCkJ5IHN1bW1pbmcgdGhlbSB1cCB3ZSBnZXQgd2hhdCB3ZSBuZWVkIC0gdGhlIHByb2JhYmlsaXR5IG9mIGdldHRpbmcgYXQgbGVhc3QgNTUgaGVhZHMgaW4gMTAwIHRvc3NlcywgYHN1bShwcm9icylgID0gYHIgcm91bmQoc3VtKHByb2JzKSwgMilgIG9yIGByIHJvdW5kKHN1bShwcm9icyksIDIpKjEwMGAgcGVyY2VudC4NCg0KPC9wPg0KPC9kaXY+DQo8L2RldGFpbHM+DQoNCg0KPC9icj4NCg0KQXMgbWVudGlvbmVkLCBmb3J0dW5hdGVseSwgdGhlIGNvdW50aW5nIG9mIHBvc3NpYmlsaXRpZXMgaXMgcHJlLWltcGxlbWVudGVkIGludG8gYFJgLg0KUnVubmluZyBgcGJpbm9tKHggPSA1NCwgc2l6ZSA9IDEwMCwgcHJvYiA9IC41LCBsb3dlci50YWlsID0gRkFMU0UpYCAoSSB3aWxsIGV4cGxhaW4gYmVsb3cpIHdlIGNhbiBnZXQgUiB0byBjYWxjdWxhdGUgdGhlIHByb3BvcnRpb24gb2Ygc2FtcGxlcyB0aGF0IHdvdWxkIHJlc3VsdCBpbiBfbW9yZSB0aGFuXyBgeGAgdGltZXMgaGVhZHMgaW4gYW4gZXhwZXJpbWVudCBvZiBgc2l6ZWAgMTAwIChpLmUuIHRvc3NpbmcgYSBjb2luIDEwMCB0aW1lcykuIA0KRXhlY3V0aW5nIHRoaXMgaW4gYFJgIHdlIGdldCBgciByb3VuZChwYmlub20oNTQsIDEwMCwgLjUsIGxvd2VyLnRhaWwgPSBGQUxTRSksMilgLiANCg0KSW4gc2hvcnQsIHRoZSBgcGJpbm9tYCBmdW5jdGlvbiBnaXZlcyB1cyB0aGUgYW5zd2VyIHRvIHRoZSBxdWVzdGlvbiAid2hhdCBpcyBwcm9wb3J0aW9uIG9mIHBvc3NpYmxlIHRvc3Mtc2VxdWVuY2VzIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gYHggPSA1NGBbXjRdIGhlYWRzIGlmIHdlIHRvc3MgYSBjb2luIGBzaXplPTEwMGAgdGltZXMgaWYgb3VyIGh5cG90aGVzaXMgaXMgdGhhdCB0aGUgY29pbiBpcyBmYWlyIHdpdGggYSBwcm9iYWJpbGl0eSBvZiBoZWFkcyBvZiBgcHJvYiA9IC41YC4NClRoZSBgbG93ZXIudGFpbCA9IEZBTFNFYCBhcmd1bWVudCB0ZWxscyBgUmAgdGhhdCB3ZSB3YW50IHRoZSB0aGUgcHJvYmFiaWxpdHkgb2YgdGhlIHVwcGVyIHBhcnQgb2YgdGhlIHByb2JhYmlsaXR5IG1hc3MgKGkuZS4gdGhlIHByb2JhYmlsaXR5IG9mIGdldHRpbmcgNTUgb3IgX21vcmVfIGhlYWRzIHJhdGhlciB0aGFuIDU0IG9yIF9sZXNzXykuDQpJbiBvdGhlciB3b3JkcywgZXZlcnkgNnRoIG91dCBvZiB0aGUgJDJeezEwMH0kIHBvc3NpYmxlIHNlcXVlbmNlcyBoYXMgNTUgb3IgbW9yZSBoZWFkcy4NCkFnYWluLCB0aGlzIGlzIG5vdCByZWFsbHkgc3VycHJpc2luZyBhbmQgd291bGQgcHJvYmFibHkgbm90IG1ha2UgdXMgY29uY2x1ZGUgdGhhdCBhIGNvaW4gaXMgZGVmaW5pdGVseSB1bmZhaXIuDQoNCklmLCBmb3IgZXhhbXBsZSwgd2UgdGhpbmsgdGhhdCBhIGNvaW4gaXMgdW5mYWlyIGlmIHRoZSBhbW91bnQgb2YgaGVhZHMgKG9yIG1vcmUgaGVhZHMpIGhhcyBvbmx5IGEgcHJvYmFiaWxpdHkgb2YgLjAxIG9yIDEgcGVyY2VudCwgd2hhdCBhbW91bnQgb2YgaGVhZHMgd291bGQgYWxsb3cgdXMgdG8gZHJhdyBzdWNoIGEgY29uY2x1c2lvbiB3aGVuIHRvc3NpbmcgYSBjb2luIDEwMCB0aW1lcz8NClRvIHNvbHZlIHRoaXMsIHdlIGNhbiBqdXN0IHVzZSB0aGUgYHBiaW5vbWAgZnVuY3Rpb24gZm9yIG5vdCBvbmx5IGB4ID0gNTVgIGhlYWRzIGJ1dCBhbHNvIDU2IHVwIHRvIDEwMCBoZWFkcywgYW5kIHNlZSBmcm9tIHdoaWNoIHBvaW50IG9ud2FyZHMgb25seSAxIHBlcmNlbnQgb2YgYWxsICQyXnsxMDB9JCBzZXF1ZW5jZXMgaW5jbHVkZSBzbyBtYW55IGhlYWRzLg0KDQpUaGUgY29kZSBiZWxvdyBkb2VzIGV4YWN0bHkgdGhpcy4gDQpDb252ZW5pZW50bHkgdGhlIGBwYmlub21gIGZ1bmN0aW9uIGNhbm5vdCBvbmx5IGV2YWx1YXRlIDEgdmFsdWUgYXQgdGhlIHNhbWUgdGltZSBidXQgd2UgY2FuIGp1c3QgcGFzcyBhbGwgdmFsdWVzIHRoYXQgd2Ugd2FudCB0byB0cnkgYXMgYSBzZXF1ZW5jZSBhbmQgaXQgd2lsbCBnaXZlIHVzIHRoZSBwcm9iYWJpbGl0eSBvZiBgeGAgaGVhZHMgZm9yIGVhY2ggb2YgdGhlbSBzbyB3ZSBjYW4gc3RvcmUgdGhlbSBhcyBhIGNvbGxlY3Rpb24gb2YgdmFsdWVzLg0KV2UgY2FuIHBsb3QgdGhlc2UgdmFsdWVzIHRvIHNlZSB3aGVuIHdlIGNyb3NzIHRoZSAxIHBlcmNlbnQgbGluZS4NCg0KYGBge3IgY2FjbHVsYXRlX3AxcGVyY2VudH0NCm5faGVhZHMgPC0gNTQ6OTkgICMgYWxsIHBvc3NpYmxlIGFtb3VudCBvZiBoZWFkcyB0aGF0IHdlIHdhbnQgdG8gdHJ5Lg0KDQpwX2hlYWRzIDwtIHBiaW5vbShxID0gbl9oZWFkcywgc2l6ZSA9IDEwMCwgcHJvYiA9IC41LCBsb3dlci50YWlsID0gRikgICMgZ2V0IHBiaW5vbSB0byBzaG93IHVzIHRoZSBwcm9iYWJpbGl0eSBvZiBzbyBtYW55IGhlYWRzIGZvciBlYWNoIG9mIHRoZSB2YWx1ZXMgaWYgYSBjb2luIGlzIGZhaXINCg0KcGxvdChuX2hlYWRzLCBwX2hlYWRzKQ0KYWJsaW5lKGggPSAuMDEpDQphYmxpbmUodiA9IG5faGVhZHNbcF9oZWFkcyA8IC4wMV1bMV0pDQpgYGANCg0KVXNpbmcgdGhlIGFib3ZlIHdlIHNlZSB0aGF0IHRoZSBhdCBgciBuX2hlYWRzW3BfaGVhZHMgPCAuMDFdWzFdYCB0b3NzZXMsIGkuZS4gdGhlIGByIG1pbih3aGljaChwX2hlYWRzIDwgLjAxKSlgdGggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGlzIHRoZSBmaXJzdCBwcm9iYWJpbGl0eSB0aGF0IGlzIHNtYWxsZXIgdGhhbiAuMDEsIGluIHRoaXMgY2FzZSBgciByb3VuZChwX2hlYWRzW21pbih3aGljaChwX2hlYWRzIDwgLjAxKSldLDMpYC4NCkluIG90aGVyIHdvcmRzLCBnZXR0aW5nIGByIG5faGVhZHNbcF9oZWFkcyA8IC4wMV1bMV1gIG9yIG1vcmUgaGVhZHMgaW4gMTAwIHRvc3NlcyB3b3VsZCBvbmx5IGhhcHBlbiBleHRyZW1lbHkgcmFyZWx5LCBpbiAxIG91dCBvZiBgciBuX2hlYWRzW3BfaGVhZHMgPCAuMDFdWzFdYCBjYXNlcy4NClRodXMgYWN0dWFsbHkgZ2V0dGluZyBgciBuX2hlYWRzW3BfaGVhZHMgPCAuMDFdWzFdYCBoZWFkcyBpcyBwcmV0dHkgc3VycHJpc2luZyBhbmQgaWYgc29tZXRoaW5nIGxpa2UgdGhhdCBoYXBwZW5lZCB3ZSBtaWdodCBjb25jbHVkZSB0aGF0IGEgY29pbiBpcyB1bmZhaXIuDQoNCkhvd2V2ZXIsIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBhcHByb2FjaCBhYm92ZSwgdGhlcmUgaXMgYW4gZWFzaWVyIHdheSB0byBnZXQgdGhlIG51bWJlciBvZiBoZWFkcyB0aGF0IHdvdWxkIHN1cnByaXNlIHVzIGJ5IHVzaW5nIHRoZSBgcWJpbm9tYCBmdW5jdGlvbiB0aGF0IGdpdmVzIHVzIHRoZSBxdWFudGlsZSAoaS5lLiBudW1iZXIgb2YgaGVhZHMgb3IgbW9yZSBoZWFkcykgdGhhdCB3b3VsZCBvbmx5IGhhcHBlbiB3aXRoIGEgY2VydGFpbiBwcm9iYWJpbGl0eTogYHFiaW5vbShwID0gLjAxLCBzaXplID0gMTAwLCBwcm9iID0gLjUsIGxvd2VyLnRhaWwgPSBGQUxTRSlgID0gYHIgcWJpbm9tKHAgPSAuMDEsIHNpemUgPSAxMDAsIHByb2IgPSAuNSwgbG93ZXIudGFpbCA9IEZBTFNFKWAsIHVuc3VycHJpc2luZ2x5IGdpdmVzIHVzIHRoZSBzYW1lIHJlc3VsdC4NCg0KIyBCYWNrIHRvIFBvd2VyDQoNCkluIHRoaXMgY29pbi10b3NzIGV4YW1wbGUsIHdlIHJ1biBhIHN0YXRpc3RpY2FsIHRlc3QgYWJvdXQgdGhlIGZhaXJuZXNzIG9mIHRoZSBjb2luLg0KQnV0IHdoYXQgaXMgdGhlIF9fcG93ZXJfXyBvZiB0aGUgdGVzdCBoZXJlIChpbiBjYXNlIHlvdSBmb3Jnb3QgZHVyaW5nIG15IHZlcnkgbG9uZyAiYnJpZWYiIGludHJvZHVjdGlvbiwgdGhpcyBwb3N0IHdhcyBhYm91dCBwb3dlcik/DQoNCkFjdHVhbGx5LCB3ZSBhbHJlYWR5IHVzZWQgdGhyZWUgY29uY2VwdHMgZnJvbSBGcmVxdWVudGlzdCBzdGF0aXN0aWNhbCB0ZXN0aW5nOg0KDQoqIFRoZSBfX251bGwtaHlwb3RoZXNpc19fOiB3ZSBhc3N1bWVkIHRoYXQgdGhlIGNvaW4gaXMgZmFpcg0KKiBUaGUgX19wLXZhbHVlX18gICAgICAgIDogdGhlIHByb2JhYmlsaXR5IHRoYXQgd2UgY2FsY3VsYXRlZCBhYm92ZSB3aGVuIGNoZWNraW5nIGhvdyBsaWtlbHkgNjIgb3IgbW9yZSBoZWFkcyBhcmUgKHdlIGdvdCBgciByb3VuZChwX2hlYWRzW21pbih3aGljaChwX2hlYWRzIDwgLjAxKSldLDMpYCkuIA0KKiBUaGUgX19hbHBoYSBsZXZlbF9fICAgIDogKGkuZS4gd2hlcmUgcGVvcGxlIGNvbnZlbnRpb25hbGx5IHVzZSAuMDUgaW4gcHN5Y2hvbG9naWNhbCBsaXRlcmF0dXJlW141XSkgaXMgdGhlIHRocmVzaG9sZCB0aGF0IHdlIHBpY2tlZCBmb3IgY29uY2x1ZGluZyBpdCB3b3VsZCBzdXJwcmlzZSB1cyBlbm91Z2ggdG8gc2F5IHRoYXQgdGhlIGNvaW4gbXVzdCBiZSB1bmZhaXIsIGkuZS4gdGhlIHByb2JhYmlsaXR5IG9mIC4wMS4gSW4gb3RoZXIgd29yZHMsIGl0IGlzIHRoZSBjaGFuY2UgdGhhdCB3ZSBjb25jbHVkZSB0aGF0IGEgY29pbiBpcyB1bmZhaXIgZXZlbiBpZiBpdCBpcyBhY3R1YWxseSBmYWlyICh0aGUgb25lIHBlcmNlbnQgb2YgY2FzZXMgd2hlcmUgNjIgb3IgbW9yZSBoZWFkcyB3b3VsZCBoYXBwZW4gZXZlbiB3aXRoIGEgZmFpciBjb2luKS4gDQoNCkluIGEgcHJvcGVyIHBvd2VyIGFuYWx5c2lzLCBhbGwgb2YgdGhlc2UgbmVlZCB0byBiZSBzcGVjaWZpZWQgaW4gYWRkaXRpb24gdG8gYW4gX2FsdGVybmF0aXZlIGh5cG90aGVzaXNfLiBMZXQncyBnaXZlIGl0IGEgdHJ5IGFuZCBzcGVjaWZ5IHRoZW0gdG8gcnVuIGEgcG93ZXItYW5hbHlzaXMNCg0KIyMgU3BlY2lmeWluZyB0aGUgbnVsbC1oeXBvdGhlc2lzLg0KDQpBZ2Fpbiwgd2Ugd2lsbCBhc3N1bWUgdGhhdCBhIGNvaW4gaXMgZmFpciBhbmQgd2lsbCBwcm9kdWNlIGhlYWRzIHdpdGggYSBwcm9iYWJpbGl0eSBvZiAuNTBbXjldLg0KDQojIyBTcGVjaWZ5aW5nIHRoZSBBbHRlcm5hdGl2ZSBIeXBvdGhlc2lzIGFrYSBFZmZlY3QgU2l6ZS4NCg0KVG8gY29uZHVjdCBhIHByb3BlciBwb3dlci1hbmFseXNpcywgaXQgaXMgaW1wb3J0YW50IHRoYXQgd2Ugc3BlY2lmeSBhIGNvbmNyZXRlIF9hbHRlcm5hdGl2ZSBoeXBvdGhlc2lzXyAob3IgZWZmZWN0IHNpemUpLg0KSWYgd2UgZG8ga25vdyBoYXZlIGEgaHlwb3RoZXNpcyBhYm91dCB0aGUgZWZmZWN0IHNpemUsIHdlIGNhbiBfYnkgZGVmaW5pdGlvbl8gbm90IGtub3cgdGhlIHBvd2VyIHRvIGludmVzdGlnYXRlIHRoaXMgaHlwb3RoZXNpcy4gDQpNYWtlcyBzZW5zZSwgcmlnaHQ/DQoNClRoaXMgbWVhbnMgd2Ugd2lsbCB0cnkgdG8gdGhpbmsgYWJvdXQgYW4gZWZmZWN0IHNpemUgdGhhdCB3b3VsZCBiZSBtZWFuaW5nZnVsIGluIHRoaXMgY29pbiBmbGlwIGV4YW1wbGUuDQpGb3IgaW5zdGFuY2UsIGlmIHlvdSB1c2UgdGhlIGNvaW4gdG8gbWFrZSBhbiBpbXBvcnRhbnQgZGVjaXNpb24sIGkuZS4gd2hlbiB0aGUgZmFpcm5lc3Mgb2YgdGhlIGNvaW4gaXMgdmVyeSBpbXBvcnRhbnQgKHNlZSBlLmcuIDxhIGlkPSJGaWd1cmUtMy1SZWYiIGhyZWY9IiNGaWd1cmUtMyI+RmlndXJlIDM8L2E+KVteN10geW91IHdvdWxkIHByb2JhYmx5IHdhbnQgdG8gYmUgdmVyeSBzdHJpY3QgYWJvdXQgd2hlbiBhIGNvaW4gaXMgdW5mYWlyIGFuZCB3b3VsZCBsaWtlIHRvLCBmb3IgaW5zdGFuY2UsIGFscmVhZHkgY29uY2x1ZGUgdGhhdCBpdCBpcyB1bmZhaXIgYXQgNTUlIHBlcmNlbnQgaGVhZHMsIGEgZGV2aWF0aW9uIGZyb20gYSB0cnVseSBmYWlyIGNvaW4gb2YgNSUuDQoNCg0Ke3slIGFsZXJ0IG5vdGUgJX19DQpNb3N0IHNvZnR3YXJlIHBhY2thZ2VzIHVzZSBlZmZlY3Qtc2l6ZSBlc3RpbWF0ZXMgbGlrZSBDb2hlbidzIGQgb3IgZiBvciBvdGhlciBfc3RhbmRhcmRpemVkIGVmZmVjdCBzaXplc18uDQpXZSB3aWxsIGhhdmUgYSBsb29rIGF0IGhvdyB0byBkbyB0aGlzIHdpdGggc2ltdWxhdGlvbnMgYnJpZWZseSBpbiB0aGUgc2Vjb25kIHBhcnQgb2YgdGhlIHR1dG9yaWFsLCBidXQgdGhyb3VnaG91dCB0aGlzIHR1dG9yaWFsLCB3ZSB3aWxsIG1vc3RseSBmb2xsb3cgYSBkaWZmZXJlbnQgYXBwcm9hY2ggYnkgdHJ5aW5nIHRvIHNwZWNpZnkgdGhlIGV4cGVjdGVkIGVmZmVjdCBzaXplIG9uIHRoZSBfcmF3XyBzY2FsZS4gDQp7eyUgL2FsZXJ0ICV9fVteNl0NCg0KIyMgU3BlY2lmeWluZyB0aGUgYWxwaGEtbGV2ZWwNCg0KRnVydGhlcm1vcmUsIGFzIGl0IGRvZXMgbm90IGRlZW0geW91IGEgZ29vZCBpZGVhIHRvIGdldCBpbnRvIGEgZmlnaHQgd2l0aCBIYXJ2ZXkgKDxhIGlkPSJGaWd1cmUtMy1SZWYiIGhyZWY9IiNGaWd1cmUtMyI+RmlndXJlIDM8L2E+KSBieSBpbmNvcnJlY3RseSBhY2N1c2luZyBoaW0gb2YgdXNpbmcgYW4gdW5mYWlyIGNvaW4sIHlvdSB3YW50IHRoZSBjaGFuY2Ugb2YgdGhpcyBoYXBwZW5pbmcgKGkuZS4gdGhlIGFscGhhLWxldmVsKSB0byBiZSB2ZXJ5IGxvdyBhdCBvbmx5IDAuMSBwZXJjZW50ICgxIGluIGEgMTAwMCBjYXNlcylbXjhdLg0KDQojIyBTcGVjaWZ5aW5nIHRoZSBkZXNpcmVkIHBvd2VyDQoNCk1vcmVvdmVyLCB5b3UgYWxzbyB3YW50IHRvIGJlIHN1cmUgdGhhdCB5b3UgX3dvdWxkXyBkZXRlY3QgdGhlIHVuZmFpcm5lc3Mgb2YgNTUlIGlmIGl0IGlzIGFjdHVhbGx5IHRoZXJlLiANCkxldCdzIHNheSB5b3Ugb25seSB3YW50IHRvIGhhdmUgYSAxMCBwZXJjZW50IGNoYW5jZSBvZiBub3QgZGV0ZWN0aW5nIGl0IGlmIGl0IHdhcyB0aGVyZS4gDQoxMDAgbWludXMgdGhpcyBjaGFuY2UgaXMgdGhlIF9wb3dlcl8gb2Ygb3VyIGNvaW4tdG9zcyBzdHVkeSwgaS5lLiA5MCBwZXJjZW50IChvciAxLS4xMCBvbiB0aGUgcHJvYmFiaWxpdHkgc2NhbGUpLiANCg0KPGEgaWQ9IkZpZ3VyZS0zIj4NCiAgPGZpZ3VyZT4NCiAgICA8aW1nIHNyYz0iaHR0cHM6Ly9tZWRpYTEudGVub3IuY29tL2ltYWdlcy81MDdkNThhNjI2ZmExNWNiMGI1N2U1N2Y3YTFjYjg3My90ZW5vci5naWY/aXRlbWlkPTk2OTg2NTEiIHdpZHRoPSI1MDAiLz4NCiAgICA8ZmlnY2FwdGlvbj5fRmlndXJlIDMuIEFuIGlsbHVzdHJhdGl2ZSBleGFtcGxlIG9mIHdoZW4gYSBjb2luLXRvc3MgcmVhbGx5IG1hdHRlcnMuXzxhIGhyZWY9IiNGaWd1cmUtMy1SZWYiPuKGqTwvYT48L2ZpZ2NhcHRpb24+DQogIDwvZmlndXJlPg0KPC9hPg0KDQoNCg0KDQpUbyBzdW1tYXJpemUsIG91ciB0ZXN0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6DQoNCiogYWxwaGEtbGV2ZWwgPSAuMDAxDQoqIGFsdGVybmF0aXZlIGh5cG90aGVzaXMgKGFrYSBlZmZlY3Qgc2l6ZSAvIGZhaXJuZXNzLWNyaXRlcmlvbikgPSA1NSUgaGVhZHMNCiogcG93ZXIgPSAuOTANCg0KT3VyIGpvYiBub3cgaXMgdG8gZmlndXJlIG91dCBhdCB3aGljaCBudW1iZXIgb2YgdG9zc2VzIHdlIGNhbiBiZSA5MCUgc3VyZSB0byBkZXRlY3QgdGhlIHVuZmFpcm5lc3Mgb2YgNTUlIHdpdGggb25seSBhIDAuMSUgY2hhbmNlIG9mIGdldHRpbmcgaW50byBhIGZpZ2h0IHdpdGggSGFydmV5IGJ5IHdyb25nbHkgYWNjdXNpbmcgaGltIG9mIHVuZmFpcm5lc3MuDQoNClRvIGRvIHRoaXMgd2UgY2FuIHVzZSB0aGUgZm9sbG93aW5nIHItY29kZSAoSSB3aWxsIGV4cGxhaW4gYmVsb3cpDQoNCiMjIFRoZSBmaXJzdCBQb3dlciBDYWxjdWxhdGlvbg0KDQpgYGB7ciBjYWxjX3Bvd2VyX2Jpbm9tfQ0KcG93ZXJfYXRfbiA8LSBjKDApICMgaW5pdGlhbGl6ZSB2ZWN0b3IgdGhhdCBzdG9yZXMgcG93ZXIgZm9yIGVhY2ggbnVtYmVyIG9mIHRvc3Nlcw0Kbl9oZWFkcyA8LSBjKCkgIyBzYXZlICJjcml0aWNhbCIgbnVtYmVyIG9mIGhlYWRzIGZvciB0aGF0IHRvc3MtYW1vdW50IHRoYXQgd291bGQgcmVzdWx0IA0Kbl90b3NzIDwtIDIgIyBpbml0aWFsaXplIHRoZSB0b3NzLWNvdW50ZXINCndoaWxlKHBvd2VyX2F0X25bbl90b3NzLTFdIDwgLjkwKXsgIyBjb250aW51ZSBhcyBsb25nIGFzIHBvd2VyIGlzIG5vdCA5MCUNCiAgbl9oZWFkc1tuX3Rvc3NdIDwtIHFiaW5vbSguMDAxLCBuX3Rvc3MsIC41LCBsb3dlci50YWlsID0gRikgIyByZXRyaWV2ZSBjcml0aWNhbCB2YWx1ZQ0KICBwb3dlcl9hdF9uW25fdG9zc10gPC0gcGJpbm9tKG5faGVhZHNbbl90b3NzXSwgbl90b3NzLCAuNTUsIGxvd2VyLnRhaWwgPSBGKSAjIGNhbGN1bGF0ZSBwb3dlciAoMS1iZXRhKSBmb3IgZWFjaCBjb2luLXRvc3MNCiAgbl90b3NzIDwtIG5fdG9zcysxICMgaW5jcmVhc2UgdG9zcy1udW1iZXIgDQp9DQpgYGANCg0KVGhlIGFib3ZlIGxvb3AgbmVlZHMgc29tZSBleHBsYW5hdGlvbi4NCkl0IGluY3JlYXNlcyB0aGUgdG9zcy1hbW91bnQgYG5fdG9zc2AgYnkgMSBhcyBsb25nIGFzIGl0IGhhcyBub3QgeWV0IHJlYWNoZWQgOTAlIHBvd2VyLg0KVG8gZG8gdGhpcywgd2UgYWdhaW4gdXNlIHRoZSBgcWJpbm9tYCBmdW5jdGlvbiB0byBmaW5kIHRoZSBudW1iZXIgb2YgaGVhZHMgKG9yIG1vcmUgaGVhZHMpIHRoYXQgd291bGQgb25seSBvY2N1ciB3aXRoIGEgcHJvYmFiaWxpdHkgb2YgLjAwMS4gDQpJbiBvdGhlciB3b3Jkcywgb25seSAwLjElIG9mIHRoZSBwb3NzaWJsZSBjb2luIHRvc3Mgc2VxdWVuY2VzIHdvdWxkIHJlc3VsdCBpbiB0aGF0IHNwZWNpZmljIGFtb3VudCBvZiBoZWFkcyB3aGVuIHRvc3NpbmcgdGhlIGNvaW4gYG5fdG9zc2AgdGltZXMuDQpUaGlzIGlzIHRoZSBzYW1lIHRoaW5nIHdlIGRpZCBlYXJsaWVyIHdpdGggYSBmaXhlZCBhbW91bnQgb2YgMTAwIHRvc3Nlcy4NCg0KaW4gdGhlIG5leHQgbGluZSwgd2UgdGFrZSB0aGlzIGFtb3VudCBvZiBoZWFkcyB0aGF0IG9ubHkgb2NjdXJzIHdpdGggYSBwcm9iYWJpbHRpeSBvZiAuMDAxIGZvciB0aGUgY3VycmVudCB0b3NzIGFtb3VudCBgbl90b3NzYCBhbmQgdXNlIGBwYmlub21gIHRvIGNhbGN1bGF0ZSB0aGUgcHJvYmFiaWxpdHkgb2YgZ2V0dGluZyBfYXQgbGVhc3RfIHRoaXMgbWFueSBoZWFkcyB3aXRoIG91ciBoeXBvdGhlc2l6ZWQgX3VuZmFpcl8gY29pbiB0aGF0IHByb2R1Y2VzIGhlYWRzIGluIDU1JSBvZiB0aGUgY2FzZXMuDQpUaGlzIG1lYW5zLCB3ZSBjYWxjdWxhdGUgdGhlIHBlcmNlbnRhZ2Ugb2YgY29pbiB0b3NzIHNlcXVlbmNlcyB0aGF0IGNvbnRhaW4gYXQgbGVhc3QgdGhpcyBtYW55IGhlYWRzLiANClRoaXMgcHJvYmFiaWxpdHkgaXMgdGhlIF9fcG93ZXJfXyBvZiB0aGUgdGVzdC4NCldoeT8NCkJlY2F1c2UgaWYgOTAlIG9mIHRoZSBzZXF1ZW5jZXMgY29udGFpbiA1NSUgb3IgbW9yZSBoZWFkcywgaWYgd2UgdGFrZSB0aGUgY29pbiBhbmQgdG9zcyBpdCBgbl90b3NzYCB0aW1lcyxpbiA5MCUgb2YgdGhlIGNhc2VzIHdlIHdpbGwgZ2V0IG9uZSBvZiB0aG9zZSBzZXF1ZW5jZXMgdGhhdCBjb250YWluIDU1JSBvciBtb3JlIGhlYWRzLg0KDQpMZXRzIGhhdmUgYSBsb29rIGF0IHR3byBvZiB0aGUgdmFsdWVzIGZyb20gdGhpcyBjYWxjdWxhdGlvbiB0byBtYWtlIHRoaXMgbW9yZSBjbGVhci4NCkZvciBpbnN0YW5jZSwgbGV0cyBsb29rIGF0IHRoZSB2YWx1ZXMgd2hlbiB0aGUgbG9vcCB0cmllZCBvdXQgMTAwIHRvc3NlczogDQoNCmBuX2hlYWRzWzEwMF1gID0gYHIgbl9oZWFkc1sxMDBdYC4gVGhpcyBudW1iZXIgaXMgaGlnaGVyIHRoYW4gdGhlIDYyIGhlYWRzIHdlIGhhZCBhYm92ZSwgYXMgd2UgYXJlIG1vcmUgc3RyaWN0IG5vdyBieSBzcGVjaWZ5aW5nIGEgc3RyaWN0ZXIgYWxwaGEgbGV2ZWwgKC4wMDEgaW5zdGVhZCBvZiAuMDEpLg0KTmV4dCwgdGhpcyBgciBuX2hlYWRzWzEwMF1gIHdhcyBwYXNzZWQgb24gdG8gdGhlIGBwYmlub21gIGZ1bmN0aW9uIGFuZCB3ZSBjYW4gbG9vayBhdCB0aGUgcG93ZXIsIGBwb3dlcl9hdF9uWzEwMF1gID0gYHIgcm91bmQocG93ZXJfYXRfblsxMDBdLCAyKWAuIA0KQXQgdGhpcyBwb2ludCB3ZSBvbmx5IGhhdmUgYSBwb3dlciBvZiAuMDIgb3IgMiUuDQpUaGlzIG1lYW5zIHRoYXQgdG9zc2luZyBhbiB1bmZhaXIgY29pbiB0aGF0IHdvdWxkIGdpdmUgNTUlIGhlYWRzIDEwMCB0aW1lcywgb25seSAyJSBvZiB0aGUgc2VxdWVuY2VzIHdvdWxkIGNvbnRhaW4gNTUgb3IgbW9yZSBoZWFkcywgdGhlcmZvcmUgbWFraW5nIGl0IHVubGlrZWx5IHRoYXQgd2Ugd291bGQgZGV0ZWN0IHRoZSB1bmZhaXJuZXNzLg0KV2hlbiB3ZSBpbmNyZWFzZSB0aGUgbnVtYmVyIG9mIHRvc3NlcyB1bnRpbCB0aGUgbG9vcCBzdG9wcywgd2UgYXJlIGF0IGBuX3Rvc3MtMWAgPSBgciBuX3Rvc3MtMWAgY29pbiB0b3NzZXMuDQpBdCB0aGlzIG51bWJlciBvZiB0b3NzZXMsIHRoZSBhbW91bnQgb2YgaGVhZHMgdGhhdCB3b3VsZCBtYWtlIHVzIGNvbmNsdWRlIHRoYXQgYSBmYWlyIGNvaW4gaXMgdW5mYWlyIChiaWFzZWQgd2l0aCA1NSUgaGVhZHMpIHdpdGggb25seSAwLjElIGNoYW5jZSBvZiBiZWluZyB3cm9uZyBpcyBgbl9oZWFkcy1bbl90b3NzLTFdYCA9IGByIG5faGVhZHNbbl90b3NzLTFdYC4gDQpUaHVzIGluIHRoaXMgY2FzZSwgd2l0aCBgciBuX3Rvc3MtMWAgdG9zc2VzLCBpZiB3ZSBnZXQgYHIgbl9oZWFkc1tuX3Rvc3MtMV1gIGhlYWRzIG9yIG1vcmUsIHdlIGNvbmNsdWRlIHRoYXQgdGhlIGNvaW4gaXMgdW5mYWlyLiANCldoYXQgaXMgdGhlIGNoYW5jZSBvZiBnZXR0aW5nIGF0IGxlYXN0IHRoYXQgd2l0aCBvdXIgX3VuZmFpcl8gY29pbj8NClRoYXQncyB3aGF0IHRoZSBgcGJpbm9tYCBmdW5jdGlvbiBpbiB0aGUgbG9vcCBhYm92ZSB0ZWxscyB1cyBhbmQgaXQgaXMgYHBvd2VyX2F0X25bbl90b3NzLTFdYCA9IGByIHJvdW5kKHBvd2VyX2F0X25bbl90b3NzLTFdLCAyKWAsIG91ciBzcGVjaWZpZWQgOTAlLg0KV2UgY2FuIGFsc28gcGxvdCB0aGUgcG93ZXIgZm9yIGVhY2ggbnVtYmVyIG9mIHRvc3NlcyB0aGF0IHdlIHRyaWVkIGluIHRoZSBsb29wLiANCkZpZ3VyZSA0IHNob3dzIHRoZSBpbmNyZWFzZSBpbiBwb3dlciB3aXRoIGluY3JlYXNpbmcgc2FtcGxlLXNpemUuDQoNCjxhIGlkPSJGaWd1cmUtNCI+DQo8ZmlndXJlPiANCmBgYHtyIHBvd2VyLWN1cnZlMX0NCnBsb3QoMToobl90b3NzLTEpLCBwb3dlcl9hdF9uLCB4bGFiID0gIk51bWJlciBvZiBjb2luLXRvc3NlcyIsIHlsYWIgPSAiUG93ZXIiLCBheGVzID0gRkFMU0UpDQphYmxpbmUoaCA9IC45MCwgY29sID0gInJlZCIpDQpheGlzKHNpZGUgPSAxLCBhdCA9IHNlcSgwLChuX3Rvc3MtMSksYnk9MTAwKSkNCmF4aXMoc2lkZSA9IDIsIGF0ID0gc2VxKDAsMSxieT0wLjEpKQ0KYGBgDQo8ZmlnY2FwdGlvbj5fRmlndXJlIDQuIENoYW5nZSBpbiBwb3dlciB1bnRpbCB3ZSByZWFjaCA5MCUgaW5kaWNhdGVkIGJ5IHRoZSByZWQgaG9yaXpvbnRhbCBsaW5lLl88L2ZpZ2NhcHRpb24+DQo8L2ZpZ3VyZT4NCjwvYT4NCg0KVGh1cywgd2hlbiB0b3NzaW5nIGEgY29pbiAxOTA4IHRpbWVzW14xNF0sIGluIDkwJSBvZiB0aGUgY2FzZXMgd2Ugd2lsbCBiZSBhYmxlIHRvIHRlbGwgaXQncyBiaWFzZWQgYW5kIGNhbiBjb25maWRlbnRseSBjb25mcm9udCBIYXJ2ZXkgbGlrZSBzaG93biBpbiBGaWd1cmUgNS4NCg0KPGZpZ3VyZT4NCiAgPGltZyBzcmM9Imh0dHBzOi8vaS5yZWRkLml0L3d5a2xlbW1mNXp6MTEucG5nIiBhbHQ9ImNvbmZyb250aW5nLWhhcnZleSIgd2lkdGg9IjUwMCIvPg0KICA8ZmlnY2FwdGlvbj5fRmlndXJlIDUuIENvbmZyb250aW5nIEhhcnZleSBhbmQgdGVsbGluZyBoaW0gd2hhdCB3ZSB0aGluayBhYm91dCBoaXMgY29pbi5fPC9maWdjYXB0aW9uPg0KPC9maWd1cmU+DQoNCg0KSWYgeW91IGFyZSBub3QgZmFtaWxpYXIgd2l0aCB1c2luZyB0aGVzZSBkaXN0cmlidXRpb24gZnVuY3Rpb25zIChgcWJpbm9tYCwgYHBiaW5vbWAgZXRjLikgaW4gYFJgLCB0aGlzIG1pZ2h0IGhhdmUgYmVlbiBhIGxvdCBvZiBuZXcgaW5mb3JtYXRpb24gYnV0IHRoaXMgaXMgYmFzaWNhbGx5IHdoYXQgd2UgZG8gaW4gcG93ZXIgYW5hbHlzaXM6IA0KDQoxLiBXZSBzcGVjaWZ5IGEgbnVsbC1oeXBvdGhlc2lzLCBhbiBhbHRlcm5hdGl2ZSBoeXBvdGhlc2lzLCBhbiBhbHBoYS1sZXZlbCBhbmQgYSBkZXNpcmVkIHBvd2VyLA0KMS4gV2UgdHJ5IGEgc21hbGwgc2FtcGxlLXNpemUuDQoxLiBXZSByZXRyaWV2ZSB0aGUgY3JpdGljYWwgdmFsdWUsICh0aGUgbnVtYmVyIG9mIGhlYWRzIHRoYXQgd291bGQgYmUgbW9yZSBzdXJwcmlzaW5nIHRoYW4gd2hhdCB3ZSBzcGVjaWZpZWQgYXMgb3VyIGFscGhhLWxldmVsKS4NCjEuIFdlIGNhbGN1bGF0ZSB0aGUgcHJvYmFiaWxpdHkgdGhhdCB0aGUgYW1vdW50IG9mIGhlYWRzIHRoYXQgd291bGQgbWFrZSB1cyByZWplY3QgdGhlIG51bGwtaHlwb3RoZXNpcyB3b3VsZCBiZSBvYnNlcnZlZCB3aXRoIHRoZSB1bmZhaXIgY29pbiBhY2NvcmRpbmcgdG8gdGhlIGFsdGVybmF0aXZlIGh5cG90aGVzaXMuDQoxLiBXZSBzdG9wIGFzIHNvb24gYXMgdGhpcyBwcm9iYWJpbGl0eSBpcyBlcXVhbCB0byB0aGUgZGVzaXJlZCBwb3dlci4NCg0KDQojIEZpbmFsbHksIGFuIGFjdHVhbCBwb3dlciBzaW11bGF0aW9uLg0KDQpTbyBmYXIsIHdlIGhhdmUgbm90IGRvbmUgYW55IHNpbXVsYXRpb24gYnV0IGhhdmUgbWVyZWx5IGFuYWx5dGljYWxseSBkZXJpdmVkIHRoZSBwb3dlciBieSBtYWtpbmcgdXNlIG9mIHRoZSBiaW5vbWlhbCBwcm9iYWJpbGl0eSBtYXNzIGZ1bmN0aW9uW14xMV0uDQpUaHVzLCBmb3IgZWFzeSB0b3ktZXhhbXBsZXMgbGlrZSB0aGlzIG9uZSB3ZSB3b3VsZCBub3QgbmVlZCB0byBkbyBhIHNpbXVsYXRpb24uDQpIb3dldmVyLCBhcyBzb29uIGFzIHdlIGRlYWwgd2l0aCByZWFsIGV4YW1wbGVzLCBpdCBpcyBtdWNoIG1vcmUgZGlmZmljdWx0IHRvIG1ha2UgdXNlIG9mIHRoaXMgYXBwcm9hY2ggYW5kIGlmIHdlIGhhdmUgc2V2ZXJhbCBwcmVkaWN0b3JzIGluIG91ciBtb2RlbCwgb3IgaWYgd2UgZGVhbCB3aXRoIG1peGVkLWVmZmVjdCBtb2RlbHMgb3IgaGllcmFyY2hpY2FsIG1vZGVscyAoYXMgd2Ugd2lsbCBkbyBpbiBwYXJ0IElWIG9mIHRoaXMgdHV0b3JpYWwpIHRoZSBhYm92ZSBtZXRob2QgaXMgbm90IGZlYXNpYmxlIGFueW1vcmUuDQoNCldoYXQgd2UgY2FuIGRvIGhvd2V2ZXIsIGZvciBhbnkgbW9kZWwgb2YgYW55IGNvbXBsZXhpdHkgYW5kIGZvcm0sIGlzIHRvIGFjdHVhbGx5IHByZXRlbmQgd2Ugd2VyZSByZXBlYXRlZGx5IGRvaW5nIHRoZSBleHBlcmltZW50IGZvciBlYWNoIHNhbXBsZSBzaXplIGFuZCBzZWUgaG93IG9mdGVuIHdlIHdvdWxkIGJlIGFibGUgdG8gcmVqZWN0IHRoZSBudWxsLWh5cG90aGVzaXMuDQpGb3IgaW5zdGFuY2Ugd2UgY291bGQgdG9zcyBhIGNvaW4gMjAgdGltZXMgYW5kIHRlc3Qgd2hldGhlciB3ZSB3b3VsZCByZWplY3QgdGhlIG51bGwtaHlwb3RoZXNpcy4NCldlIGNvdWxkIHRoZW4gcmVwZWF0IHRoaXMgcHJvY2VzcyBmb3IgMjAgdG9zc2VzIHZlcnkgb2Z0ZW4sIGUuZy4gMSwwMDAgdGltZXMgYW5kIHNlZSB3aGF0IHRoZSBwcm9iYWJpbGl0eSBpcyB0aGF0IHdlIHdvdWxkIGNvbmNsdWRlIHRoYXQgdGhlIG51bGwtaHlwb3RoZXNpcyBpcyBmYWxzZVteMTJdLg0KVGhpcyBpcyB3aGF0IHdlIGRvIGluIHBvd2VyLXNpbXVsYXRpb24uDQoNCkFuIG9idmlvdXMgZGlzYWR2YW50YWdlIGlzIHRoYXQgaW5zdGVhZCBvZiBqdXN0IGNhbGN1bGF0aW5nIHRoZSBwb3dlciBmb3IgZWFjaCB0b3NzLWFtb3VudCAoaS5lLiBzYW1wbGUtc2l6ZSkgb25seSBvbmNlLCB3ZSBuZWVkIHRvIHRyeSBlYWNoIHRvc3MtYW1vdW50IG91dCAxLDAwMCB0aW1lcy4gDQpUaHVzLCBzaW11bGF0aW9uIHRha2VzIG11Y2ggbG9uZ2VyIHRoYW4gYSByZWd1bGFyIHBvd2VyLWNhbGN1bGF0aW9uLCBlc3BlY2lhbGx5IHdpdGggbW9yZSBjb21wbGV4IG1vZGVscyBhbmQgaGlnaCBzYW1wbGUtc2l6ZXMuDQpIb3dldmVyLCB0aGUgYWR2YW50YWdlIG9mIHRoZSBtZXRob2QgaXMgdGhhdCB3ZSBjYW4ganVzdCBsZWFybiBpdCBvbmNlIGFuZCBhZGp1c3QgaXQgZm9yIGFueSBzaXR1YXRpb24gdGhhdCB3ZSB3aWxsIGV2ZXIgZmluZCBvdXJzZWx2ZXMgaW4sIG5vdCBoYXZpbmcgdG8gZXZlciB3YWxrIHRocm91Z2ggdGVkaW91cyBpbnRlcmZhY2VzIGFnYWluLCBzZWxlY3RpbmcgYXJiaXRyYXJ5IGFuYWx5c2VzIGFuZCBzZXR0aW5nIGV2ZXIgY2hhbmdpbmcgcGFyYW1ldGVycyB0byBjZXJ0YWluIHZhbHVlcy4NCkFub3RoZXIgYWR2YW50YWdlICh0aGF0IHdpbGwgYmUgZGlzY3Vzc2VkIGluIGRldGFpbCBsYXRlcikgaXMgdGhhdCB3ZSBkbyBub3QgbmVlZCB0byBzcGVjaWZ5IGEgcHJlY2lzZSBhbHRlcm5hdGl2ZSBoeXBvdGhlc2lzIGFuZCB0ZXN0IGl0IGZvciB0aGF0IHNpbmdsZSB2YWx1ZSwgYnV0IHRoYXQgd2UgY2FuIGFjdHVhbGx5IHJlbWFpbiBtb3JlIHZhZ3VlIGFib3V0IHdoYXQgb3VyIGFsdGVybmF0aXZlIGh5cG90aGVzaXMgKGkuZS4gdGhlIGVmZmVjdCBzaXplIHRoYXQgd2UgZXhwZWN0KSB3aWxsIGJlLg0KT2Z0ZW50aW1lcyB3ZSBkbyBub3Qga25vdyBleGFjdGx5IHdoYXQgZWZmZWN0LXNpemUgd2UgY2FuIGV4cGVjdCBhbmQgd2UgbWlnaHQgbGlrZSB0byB0ZWxsIHRoZSBwb3dlci1hbmFseXNpcyBhYm91dCB0aGlzIHVuY2VydGFpbnR5Lg0KDQpBdCBsYXN0LCBsZXQgdXMgZG8gYSBwb3dlci1zaW11bGF0aW9uIGZvciB0aGUgYWJvdmUgZXhhbXBsZS4NCkx1Y2tpbHkgd2UgZG8gbm90IHJlYWxseSBoYXZlIHRvIHRvc3MgYSBjb2luIGFzIGBSYCBjYW4gZG8gdGhhdCBmb3IgdXMgYnkgdXNpbmcgdGhlIGByYmlub21gIGZ1bmN0aW9uLCB0aGF0IHdpbGwgYXMgb2Z0ZW4gYXMgd2UgY2FsbCBpdCBkbyBhIGNvaW4tdG9zc2luZyBleHBlcmltZW50IGZvciB1cyB3aXRoIGEgc3BlY2lmaWVkIHNhbXBsZS1zaXplLg0KTGV0cyBmaXJzdCBzZWUgaG93IHRoZSBgcmJpbm9tYCBmdW5jdGlvbiB3b3JrcyBpZiB3ZSB3b3VsZCB3YW50IHRvIHRvc3MgYSBjb2luIDIwIHRpbWVzLg0KDQpgYGB7ciByYmlub20tdGVzdH0NCnNldC5zZWVkKDEpICMgbWFrZSBzdXJlIG91ciBzaW11bGF0aW9uIHdpbGwgZ2l2ZSB0aGUgc2FtZSByZXN1bHRzIGlmIHlvdSB0cnkgaXQNCnJiaW5vbShuID0gMSwgc2l6ZSA9IDIwLCBwcm9iID0gLjUwKSAjIGxldCByIGRvIDEgZXhwZXJpbWVudCB3aXRoIDIwIGNvaW4gdG9zc2VzIG9mIGEgZmFpciBjb2luDQpgYGANCg0KSW4gdGhlIGFib3ZlIGNvZGUsIGBSYCB0b3NzZWQgYSBjb2luIDIwIHRpbWVzIGFuZCBpdCByZXN1bHRlZCBpbiA5IGhlYWRzLg0KV2UgY291bGQgcmVwZWF0IHRoaXMgZXhwZXJpbWVudCBhZ2FpbjoNCg0KYGBge3IgcmJpbm9tLXRlc3QyfQ0Kc2V0LnNlZWQoMikgIyBtYWtlIHN1cmUgb3VyIHNpbXVsYXRpb24gd2lsbCBnaXZlIG90aGVyIHJlc3VsdHMgdGhhbiBiZWZvcmUNCnJiaW5vbShuID0gMSwgc2l6ZSA9IDIwLCBwcm9iID0gLjUpICMgcnVuIHRoZSBleHBlcmltZW50IGFnYWluDQpgYGANCg0KSW4gdGhpcyBjYXNlLCBnaXZpbmcgdXMgOCBoZWFkcy4NCkJ5IGluY3JlYXNpbmcgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBgcmJpbm9tYCBmdW5jdGlvbiwgd2UgY2FuIHRlbGwgYFJgIHRvIHJlcGVhdCB0aGlzIGV4cGVyaW1lbnQgbW9yZSBvZnRlbi4NCk1vcmVvdmVyLCB3ZSBjYW4gdGVsbCBpdCB0byBtYWtlIHVzZSBvZiBhbiB1bmZhaXIgY29pbiBkaXJlY3RseSwgc28gd2UgY2FuIGRpcmVjdGx5IHB1dCBvdXIgYWx0ZXJuYXRpdmUgaHlwb3RoZXNpcyBpbiB0aGUgc2ltdWxhdGlvbiBieSBjaGFuZ2luZyB0aGUgbGFzdCBudW1iZXIgb2YgdGhlIGByYmlub21gIGZ1bmN0aW9uIGZyb20gLjUwIHRvIC41NSwgdG8gZG8gdGhlIHNhbWUgdGVzdCBhcyBhYm92ZS4NCg0KYGBge3IgcmJpbm9tLXRlc3QzfQ0Kc2V0LnNlZWQoMSkNCm5faGVhZHMgPC0gcmJpbm9tKG4gPSAxMDAwLCBzaXplID0gMjAsIHByb2IgPSAuNTUpICMgcnVuIDEsMDAwIGV4cGVyaW1lbnRzLCBvZiAyMCBjb2luIHRvc3NlcyBlYWNoLCBhdCBvbmNlDQpzdHIobl9oZWFkcykgIyBzaG93IHN0cnVjdHVyZSBvZiB2ZWN0b3INCmBgYA0KDQpOb3csIGBSYCByZXBlYXRlZCB0aGUgMjAgY29pbi10b3NzIGV4cGVyaW1lbnQgMSwwMDAgdGltZXMgd2l0aCBhbiB1bmZhaXIgY29pbiBvZiA1NSUgY2hhbmNlIG9mIHJlc3VsdGluZyBpbiBoZWFkcyBnaXZpbmcgdXMgMSwwMDAgdGltZXMgdGhlIGFtb3VudCBvZiBoZWFkcyB0aGF0IGl0IGdvdC4NCkxldCB1cyBhZ2FpbiBub3cgdGVzdCBob3cgYmlnIG91ciBwb3dlciB3YXMgaW4gdGhpcyBjYXNlLCBhZ2FpbiB3aXRoIGFuIGFscGhhLWxldmVsIG9mIC4wMDEuDQoNCmBgYHtyIGNvaW4tZmxpcC1zaW0tdGVzdH0NCnBfaGVhZHMgPC0gcGJpbm9tKG5faGVhZHMsIDIwLCAuNTAsIGxvd2VyLnRhaWwgPSBGKSAjIGNhbGN1bGF0ZSB0aGUgcHJvYmFiaWxpdHkgb2Ygb2JzZXJ2aW5nIHRoaXMgbWFueSBoZWFkcyBpZiB0aGUgY29pbiB3b3VsZCBiZSBmYWlyICh3aGljaCBpdCBpcyBub3QgY2F1c2Ugd2Ugc2ltdWxhdGVkIHdpdGggNTUlIGhlYWRzKQ0KDQpleHBfcG93ZXIgPC0gbWVhbihwX2hlYWRzIDwgLjAwMSkgIyBjaGVjayB3aGVyZSB0aGlzIGNoYW5jZSBkcm9wcyBiZWxvdyBvdXIgYWxwaGEgbGV2ZWwNCg0KYGBgDQoNClRoZSBmaXJzdCBsaW5lIGluIHRoZSBhYm92ZSBjb2RlIGRvZXMgZXhhY3RseSB3aGF0IHdlIGRpZCBlYXJsaWVyLCBqdXN0IHdpdGggYSBsaXR0bGUgY2hhbmdlLg0KV2UgdGFrZSB0aGUgYW1vdW50cyBvZiBoZWFkcyB0aGF0IHdlIGdvdCBmcm9tIGFuIHVuZmFpciBjb2luLCBhbmQgY2hlY2sgaW4gaG93IG1hbnkgY2FzZXMgd2Ugd291bGQgY29uY2x1ZGUgLSBhc3N1bWluZyB0aGF0IHRoZSBjb2luIHdvdWxkIGFjdHVhbGx5IGJlIGZhaXIsIHRodXMgdXNpbmcgLjUwIGFzIHRoZSBwcm9iYWJpbGl0eSBpbiBgcGJpbm9tYCAtIHRoYXQgdGhlIG9ic2VydmVkIGFtb3VudHMgb2YgaGVhZHMgaXMgdG9vIHVubGlrZWx5IGZvciB1cyB0byBiZWxpZXZlIHRoYXQgdGhlIGNvaW4gd2FzIGZhaXIuDQpXZSBzYXZlIHRoZXNlIHByb2JhYmlsaXRpZXMgdG8gYSB2ZWN0b3IuIA0KVGhlIHNlY29uZCBsaW5lIGNhbGN1bGF0ZXMgdGhlIG9ic2VydmVkIHBvd2VyIG9mIG91ciBleHBlcmltZW50Lg0KVG8gdW5kZXJzdGFuZCB3aGF0IGl0IGRvZXMsIGxldCB1cyBoYXZlIGEgbG9vayBhdCB0aGUgdmVjdG9yIHBfaGVhZHMgaXQgbG9va3MgdGhlIGZvbGxvd2luZyAoaGVyZSBvbmx5IHRoZSBmaXJzdCAxMCBvdXQgb2YgMSwwMDAgdmFsdWVzKToNCg0KYGBge3IgaGVhZF9waGVhZHN9DQpwX2hlYWRzWzE6MTBdDQpgYGANCg0KQXMgc2hvd24gYWJvdmUsIHRoZSBgcF9oZWFkc2AgdmVjdG9yIGNvbnRhaW5zIHRoZSBwcm9iYWJpbGl0eSBvZiBvYnNlcnZpbmcgZWFjaCBhbW91bnQgb2YgaGVhZHMgYG5faGVhZHNgIGZyb20gb3VyIDEsMDAwIGV4cGVyaW1lbnRzIGFzc3VtaW5nIHRoZSBleHBlcmltZW50IHdhcyBkb25lIHdpdGggYSBmYWlyIGNvaW4gKHdoaWNoIGl0IHdhcyBub3QpLg0KTm93IHdlIHdvdWxkIGxpa2UgdG8gY2hlY2sgaG93IG1hbnkgb2YgdGhlc2UgcHJvYmFiaWxpdGllcyBhcmUgYXQgbGVhc3QgYXMgc21hbGwgYXMgb3VyIGFscGhhLWxldmVsLCBpLmUuIHN1cnByaXNpbmcgZW5vdWdoIHRvIGNvbmNsdWRlIHRoZSBjb2luIHdhcyBub3QgZmFpci4NCldlIGRvIHRoaXMgYnkgY2hlY2tpbmcgZm9yIGVhY2ggdmFsdWUgd2hldGhlciBpdCB3YXMgLjAwMSBvciBzbWFsbGVyIChgcF9oZWFkcyA8IC4wMDFgKS4gDQpUaGlzIHdpbGwgcmVzdWx0IGluIGFub3RoZXIgdmVjdG9yIG9mIDAgd2hlbiB0aGUgY29uZGl0aW9uIGlzIGZhbHNlIGFuZCAxIHdoZW4gdGhlIGNvbmRpdGlvbiBpcyB0cnVlW14xM10uDQpUYWtpbmcgdGhlIG1lYW4gb2YgdGhpcyB2ZWN0b3Igd2lsbCBnaXZlIHVzIHRoZSBwcm9iYWJpbGl0eSBvZiByZWplY3RpbmcgdGhlIG51bGwtaHlwb3RoZXNpcyB3aGlsZSB3ZSBhY3R1YWxseSBrbm93IGl0IGlzIGluY29ycmVjdCAoYXMgd2UgcHV0IHRoZSBiaWFzIGluIHRoZSBjb2luIG91cnNlbHZlcykuIA0KQWdhaW4sIHRoaXMgd2lsbCBnaXZlIHVzIHRoZSBwb3dlci4NCkluIHRoZSBwcmVzZW50IGNhc2Ugd2l0aCAyMCBjb2luLXRvc3NlcyB0aGUgcG93ZXIgaXMgYGV4cF9wb3dlcmAgPSBgciBleHBfcG93ZXJgIG9yIGByIGV4cF9wb3dlcioxMDBgIHBlcmNlbnQuDQpUaGlzIGlzIG9idmlvdXNseSB2ZXJ5IGxvdyBhbmQgbm90IHN1cnByaXNpbmcgZ2l2ZW4gdGhhdCB3ZSBhbHJlYWR5IGtub3cgZnJvbSB0aGUgY2FsY3VsYXRpb24gYWJvdmUgdGhhdCB3ZSBuZWVkIGEgbG90IG1vcmUgY29pbi10b3NzZXMgdGhhbiAyMCB0byBnZXQgdGhlIGRlc2lyZWQgcG93ZXIgb2YgOTAlLg0KVG8gZ2V0IHRvIG91ciBkZXNpcmVkIHBvd2VyIGluIHRoaXMgZXhhbXBsZSwgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIGNvZGUgYWJvdmUgc28gaXQgd2lsbCB0cnkgZGlmZmVyZW50IHNhbXBsZS1zaXplcyBhZ2Fpbi4NCg0KYGBge3IgZXN0aW1hdGVfbl9iaW5vbX0NCnNldC5zZWVkKDEpDQpleHBfcG93ZXJfYXRfbiA8LSBjKDApICMgY3JlYXRlIGEgdmVjdG9yIHdoZXJlIHdlIGNhbiBzdG9yZSB0aGUgcG93ZXIgZm9yIGVhY2ggc2FtcGxlLXNpemUNCm5fdG9zc19zdGFydCA8LSAxOSAjIHN0YXJ0IGF0IDIxIHRvc3Nlcw0Kbl90b3NzX2xvb3AgPC0gMiAjIGFkZGl0aW9uYWwgbnVtYmVyIG9mIHRvc3NlcyB0cmllZCAoYWJvdmUgMjApDQp3aGlsZShleHBfcG93ZXJfYXRfbltuX3Rvc3NfbG9vcC0xXSA8IC45MCl7ICMgY29udGludWUgaW5jcmVhc2luZyB0aGUgc2FtcGxlLXNpemUgdW50aWwgcG93ZXIgPSA5MCUNCiAgbl90b3NzIDwtIG5fdG9zc19zdGFydCtuX3Rvc3NfbG9vcCAjIGNhbGN1bGF0ZSB0aGUgY3VycmVudCBudW1iZXIgb2YgdG9zc2VzDQogIG5faGVhZHMgPC0gcmJpbm9tKDEwMDAsIG5fdG9zcywgLjU1KSAjIHJ1biAxMDAwIGV4cGVyaW1lbnRzIGZvciBhbnkgZ2l2ZW4gbnVtYmVyIG9mIHRvc3NlcyBhbmQgc3RvcmUgbnVtYmVyIG9mIGhlYWRzDQogIHBfaGVhZHMgPC0gcGJpbm9tKG5faGVhZHMsIG5fdG9zcywgLjUwLCBsb3dlci50YWlsID0gRikgIyBjYWxjdWxhdGUgdGhlIHByb2JhYmlsaXR5IG9mIGdldHRpbmcgYXQgbGVhc3QgdGhhdCBtYW55IGhlYWRzIGlmIHRoZSBjb2luIHdvdWxkIGJlIGZhaXIgDQogIGV4cF9wb3dlcl9hdF9uW25fdG9zc19sb29wXSA8LSBtZWFuKHBfaGVhZHMgPCAuMDAxKSAjIGNhbGN1bGF0ZSBwb3dlciBieSBjaGVja2luZyB3aGF0IHByb3BvcnRpb24gb2YgdGhlIHByb2JhYmlsaXRpZXMgaXMgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvIG91ciBhbHBoYS1sZXZlbA0KICBuX3Rvc3NfbG9vcCA9IG5fdG9zc19sb29wKzENCn0NCg0KZXhwX3Bvd2VyX2F0X24gPC0gZXhwX3Bvd2VyX2F0X25bLTFdICMgcmVtb3ZlIHRoZSBmaXJzdCAwIHRoYXQgd2UgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdmVjdG9yIGZvciB0aGUgZmlyc3QgaXRlcmF0aW9uIG9mIHRoZSBsb29wDQpgYGANCg0KVGhlIGFib3ZlIGNvZGUgaXMgc2ltaWxhciB0byB3aGF0IHdlIGhhdmUgZG9uZSBlYXJsaWVyIHdoZW4gd2UgdHJpZWQgb25seSAxIHNhbXBsZS1zaXplLg0KVGhpcyB0aW1lLCB3ZSBpdGVyYXRlIG92ZXIgZGlmZmVyZW50IHNhbXBsZS1zaXplcyBpbiBhIGxvb3AgYW5kIHN0b3JlIHRoZSBwb3dlciBmb3IgZWFjaCBpbiB0aGUgdmVjdG9yIGBleHBfcG93ZXJfYXRfbmAuDQpBcyBpbiB0aGUgZWFybGllciBjYWxjdWxhdGlvbiwgd2UgY2FuIG5vdyB1c2UgdGhpcyB0byBzZWUgaG93IG1hbnkgdG9zc2VzIHdlIHdvdWxkIG5lZWQgYnkgaGF2aW5nIGEgbG9vayBhdCB3aGVyZSB0aGUgbG9vcCBzdG9wcGVkLCBpLmUuIHdoZW4gaXQgcmVhY2hlZCA5MCUgcG93ZXIsIHdoaWNoIGlzIGF0IGBuX3Rvc3MtMWAgPSBgciBuX3Rvc3MtMWAgdG9zc2VzIGF0IHdoaWNoIHRoZSBwb3dlciB3YXMgYGV4cF9wb3dlcl9hdF9uW2xlbmd0aChleHBfcG93ZXJfYXRfbildYCA9IGByIGV4cF9wb3dlcl9hdF9uW2xlbmd0aChleHBfcG93ZXJfYXRfbildYC4NCldlIGNhbiBhbHNvIHBsb3QgYWxsIHRoZXNlIHZhbHVlcyBhZ2FpbiBhcyBkb25lIGluIEZpZ3VyZSA2LiANCg0KPGZpZ3VyZT4NCmBgYHtyIGZpZ3VyZTZ9DQpwbG90KDIxOm5fdG9zcywgZXhwX3Bvd2VyX2F0X24sIHhsYWIgPSAiTnVtYmVyIG9mIGNvaW4tdG9zc2VzIiwgeWxhYiA9ICJQb3dlciIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBGQUxTRSkNCmFibGluZShoID0gLjkwLCBjb2wgPSAicmVkIikNCmF4aXMoc2lkZSA9IDEsIGF0ID0gc2VxKDAsKG5fdG9zcyksYnk9MTAwKSkNCmF4aXMoc2lkZSA9IDIsIGF0ID0gc2VxKDAsMSxieT0wLjEpKQ0KYGBgDQogIDxmaWdjYXB0aW9uPl9GaWd1cmUgNi4gT2JzZXJ2ZWQgcG93ZXIgaW4gdGhlIHNpbXVsYXRpb24uXzwvZmlnY2FwdGlvbj4NCjxmaWd1cmU+DQoNCg0KVGhlIHNoYXBlIG9mIHRoZSBsaW5lIGxvb2tzIHZlcnkgc2ltaWxhciB0byB0aGUgZWFybGllciBjYWxjdWxhdGlvbiwgaG93ZXZlciB0aGUgbGluZSBhcHBlYXJzIHRvIGJlIHRoaWNrZXIuIA0KTW9yZW92ZXIsIGl0IG1pZ2h0IGJlIHN1cnByaXNpbmcgdGhhdCB3ZSBkaWQgbm90IGdldCB0aGUgc2FtZSBhbW91bnQgb2YgdG9zc2VzIHRoYXQgd2UgZ290IGZyb20gdGhlIGNhbGN1bGF0aW9uLiANCkFjdHVhbGx5IHRoZXkgZGlmZmVyIHF1aXRlIGEgbG90ICgxOTA4IHZzLiAxNzk1KS4NClRoaXMgaXMgZHVlIHRvIHRoZSBmYWN0IHRoYXQgZXZlbiB3aGVuIHJ1bm5pbmcgMSwwMDAgZXhwZXJpbWVudHMgZm9yIGVhY2ggc2FtcGxlLXNpemUgdGhlcmUgaXMgc3RpbGwgaW1wcmVjaXNpb24gaW4gdGhlIHNpbXVsYXRpb24uDQpFYWNoIGNvaW4tZmxpcCBpcyByYW5kb20gYW5kIGV2ZW4gaWYgd2UgcmVwZWF0IGEgZXhwZXJpbWVudCAxLDAwMCB0aW1lcyB0aGlzIHJhbmRvbW5lc3MgaXMgc3RpbGwgaW4gdGhlcmUgKHRoaW5rIG9mIGhvdyBtYW55IHBvc3NpYmxlIHNlcXVlbmNlcyB0aGVyZSB3b3VsZCBiZSEpLg0KVGhpcyByYW5kb21uZXNzIGlzIHdoeSB3ZSBjYXQgYSBkaWZmZXJlbnQgbnVtYmVyIGluIHRoZSBzaW11bGF0aW9uIGFuZCB3aHkgdGhlIGxpbmUgaW4gRmlndXJlIDYgaXMgdGhpY2tlciB0aGFuIGluIDxhIGhyZWY9IiNGaWd1cmUtNCI+RmlndXJlIDQ8L2E+Lg0KDQpJZiB3ZSB3YW50IHRvIGFwcHJvYWNoIHRoZSByZXN1bHRzIG9mIHRoZSBjYWxjdWxhdGlvbiBtb3JlIGNsb3NlbHkgaW4gb3VyIHNpbXVsYXRpb24gKGkuZS4gZ2V0IGEgbW9yZSBwcmVjaXNlIHBvd2VyLWVzdGltYXRlKSB3ZSBjYW4gaW5jcmVhc2UgdGhlIG51bWJlciBvZiBleHBlcmltZW50cyB0aGF0IGBSYCB3aWxsIHJ1biBwZXIgc2FtcGxlLXNpemUgKGkuZS4gdGhlIG51bWJlciBvZiBzaW11bGF0aW9ucykuDQpGb3IgZXhhbXBsZSwgd2UgY291bGQgcmVwZWF0IHRoZSBzaW11bGF0aW9uIHdpdGggMTAwLDAwMCBleHBlcmltZW50cyBwZXIgc2FtcGxlLXNpemUuDQpZb3UgaGF2ZSB0byBiZSBwYXRpZW50IGhlcmUsIHRoaXMgYWxyZWFkeSB0YWtlcyBhIGZldyBtaW51dGVzIG1heWJlLg0KDQpgYGB7ciBzaW0tcG93ZXItMTAwMDAwfQ0Kc2V0LnNlZWQoMSkNCmV4cF9wb3dlcl9hdF9uIDwtIGMoMCkgIyBjcmVhdGUgYSB2ZWN0b3Igd2hlcmUgd2UgY2FuIHN0b3JlIHRoZSBwb3dlciBmb3IgZWFjaCBzYW1wbGUtc2l6ZQ0Kbl90b3NzX3N0YXJ0IDwtIDE5ICMgc3RhcnQgYXQgMjEgdG9zc2VzDQpuX3Rvc3NfbG9vcCA8LSAyICMgYWRkaXRpb25hbCBudW1iZXIgb2YgdG9zc2VzIHRyaWVkIChhYm92ZSAyMCkNCndoaWxlKGV4cF9wb3dlcl9hdF9uW25fdG9zc19sb29wLTFdIDwgLjkwKXsgIyBjb250aW51ZSBpbmNyZWFzaW5nIHRoZSBzYW1wbGUtc2l6ZSB1bnRpbCBwb3dlciA9IDkwJQ0KICBuX3Rvc3MgPC0gbl90b3NzX3N0YXJ0K25fdG9zc19sb29wICMgY2FsY3VsYXRlIHRoZSBjdXJyZW50IG51bWJlciBvZiB0b3NzZXMNCiAgbl9oZWFkcyA8LSByYmlub20oMTAwMDAwLCBuX3Rvc3MsIC41NSkgIyBydW4gMTAwMCBleHBlcmltZW50cyBmb3IgYW55IGdpdmVuIG51bWJlciBvZiB0b3NzZXMgYW5kIHN0b3JlIG51bWJlciBvZiBoZWFkcw0KICBwX2hlYWRzIDwtIHBiaW5vbShuX2hlYWRzLCBuX3Rvc3MsIC41MCwgbG93ZXIudGFpbCA9IEYpICMgY2FsY3VsYXRlIHRoZSBwcm9iYWJpbGl0eSBvZiBnZXR0aW5nIGF0IGxlYXN0IHRoYXQgbWFueSBoZWFkcyBpZiB0aGUgY29pbiB3b3VsZCBiZSBmYWlyIA0KICBleHBfcG93ZXJfYXRfbltuX3Rvc3NfbG9vcF0gPC0gbWVhbihwX2hlYWRzIDwgLjAwMSkgIyBjYWxjdWxhdGUgcG93ZXIgYnkgY2hlY2tpbmcgd2hhdCBwcm9wb3J0aW9uIG9mIHRoZSBwcm9iYWJpbGl0aWVzIGlzIHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0byBvdXIgYWxwaGEtbGV2ZWwNCiAgbl90b3NzX2xvb3AgPSBuX3Rvc3NfbG9vcCsxDQp9DQoNCmV4cF9wb3dlcl9hdF9uIDwtIGV4cF9wb3dlcl9hdF9uWy0xXSAjIHJlbW92ZSB0aGUgZmlyc3QgMCB0aGF0IHdlIHVzZWQgdG8gcG9wdWxhdGUgdGhlIHZlY3RvciBmb3IgdGhlIGZpcnN0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcA0KYGBgDQoNCklmIHlvdSBydW4gdGhpcyBjb2RlLCB5b3Ugd2lsbCBzZWUgdGhhdCBpdCB0b29rIHN1YnN0YW50aWFsbHkgbG9uZ2VyIHRoYW4gdGhlIHByZXZpb3VzIHNpbXVsYXRpb24gd2l0aCBvbmx5IDEsMDAwIHJlcGV0aXRpb25zLg0KSWYgd2Ugbm93IGxvb2sgYXQgdGhlIG91dGNvbWUgYWdhaW4gd2UgZmluZCB0aGF0IHRoZSBudW1iZXIgb2YgdG9zc2VzIGBuX3Rvc3MtMWAgPSBgciBuX3Rvc3MtMWAgaXMgYWxyZWFkeSBzbGlnaHRseSBjbG9zZXIgdG8gdGhlIGNhbGN1bGF0ZWQgdmFsdWUgYnV0IHN0aWxsIG5vdCBleGFjdGx5IHRoZSBzYW1lLg0KSW4gbXkgcGVyc29uYWwgb3BpbmlvbiwgdGhpcyBpbXByZWNpc2lvbiBpcyBib3RoIGFkdmFudGFnZSBvZiBzaW11bGF0aW9uIGFzIHdlbGwgYXMgZGlzYWR2YW50YWdlLg0KSXQgaXMgYSBkaXNhZHZhbnRhZ2UgaW4gdGhhdCBpdCBpcyBsZXNzIHByZWNpc2UgdGhhbiB0aGUgY2FsY3VsYXRpb24gYWJvdmUgaW4gdGhlb3J5Lg0KSG93ZXZlciwgaXQgaXMgYW4gYWR2YW50YWdlIGFzIGl0IGFkZHMgc29tZSBub2lzZSB0byB0aGUgcG93ZXItZXN0aW1hdGlvbiBwcm9jZXNzIHRoYXQgaXMgYWN0dWFsbHkgYWxzbyBwcmVzZW50IGluIHJlYWwgbGlmZS4NClRoaXMgaXMsIGV2ZW4gaWYgdGhlcmUgaXMgYW4gZWZmZWN0IGluIHRoZSBwb3B1bGF0aW9uLCBlYWNoIG5ldyBzYW1wbGUgd2lsbCBhbHdheXMgYmUgZGlmZmVyZW50IHdoaWNoIGlzIGFsc28gdGhlIGNhc2UgaW4gdGhlIHNpbXVsYXRpb24uDQpJZiB3ZSBsb29rIGF0IEZpZ3VyZSA3LCB3ZSBhbHNvIHNlZSB0aGF0IG5vdyB0aGUgcG93ZXItaW5jcmVhc2UgZm9sbG93cyBhIG1vcmUgc3RyYWlnaHQgbGluZSBhZ2FpbiB0aGF0IGlzIHZlcnkgY2xvc2UgdG8gdGhlIG9uZSBmcm9tIHRoZSBleGFjdCBjYWxjdWxhdGlvbiBhbmQgbm90IGFzIHRoaWNrIGFueW1vcmUgYXMgaW4gRmlndXJlIDYuDQoNCg0KPGZpZ3VyZT4NCmBgYHtyIGZpZ3VyZTd9DQpwbG90KDIxOm5fdG9zcywgZXhwX3Bvd2VyX2F0X24sIHhsYWIgPSAiTnVtYmVyIG9mIGNvaW4tdG9zc2VzIiwgeWxhYiA9ICJQb3dlciIsIHlsaW0gPSBjKDAsMSksIGF4ZXMgPSBGQUxTRSkNCmFibGluZShoID0gLjkwLCBjb2wgPSAicmVkIikNCmF4aXMoc2lkZSA9IDEsIGF0ID0gc2VxKDAsKG5fdG9zcyksYnk9MTAwKSkNCmF4aXMoc2lkZSA9IDIsIGF0ID0gc2VxKDAsMSxieT0wLjEpKQ0KYGBgDQogIDxmaWdjYXB0aW9uPl9GaWd1cmUgNy4gUG93ZXIgY3VydmUgZm9yIGEgbW9yZSBwcmVjaXNlIHNpbXVsYXRpb24uXzwvZmlnY2FwdGlvbj4NCjwvZmlndXJlPg0KDQoNCiMgU3VtbWFyeQ0KDQpJbiB0aGlzIHBhcnQgb2YgdGhlIHR1dG9yaWFsIEkgdHJpZWQgdG8gYnJpbmcgdXMgYWxsIG9uIHRoZSBzYW1lIHBhZ2UgYWJvdXQgd2h5IHdlIHdvdWxkIGRvIGRhdGEgb3IgcG93ZXIgc2ltdWxhdGlvbiBhbmQgaG93IGl0IGlzIHJlbGF0ZWQgdG8gZXhhY3QgcG93ZXIgY2FsY3VsYXRpb24uDQoNCiogSW4gcHJpbmNpcGxlLCBpbiBwb3dlciBjYWxjdWxhdGlvbiB3ZSBjb3VudCB0aGUgYW1vdW50IG9mIHBvdGVudGlhbCBkYXRhIHNlcXVlbmNlcyAoZS5nLiBwb3NzaWJsZSBzZXF1ZW5jZXMgb2YgSEVBRFMtVEFJTFMgaW4gY29pbi10b3NzZXMpIHRoYXQgY291bGQgaGFwcGVuIGluIGFuIGV4cGVyaW1lbnQgb2YgYSBzcGVjaWZpYyBzaXplIChlLmcuIGFtb3VudCBvZiBjb2luLXRvc3NlcykuDQoqIEFmdGVyd2FyZHMsIHdlIGNhbGN1bGF0ZSB0aGUgY3JpdGljYWwgdmFsdWUgKGUuZy4gbnVtYmVyIG9mIGhlYWRzKSB0aGF0IHdvdWxkIG1ha2UgdXMgcmVqZWN0IHRoZSBudWxsLWh5cG90aGVzaXMgKGUuZy4gYSBjb2luIGlzIGZhaXIpIGFzIG9ubHkgYSB2ZXJ5IHNtYWxsIHBlcmNlbnRhZ2Ugb2Ygc2VxdWVuY2VzICgic21hbGwiIGlzIGRlZmluZWQgYnkgdGhlIGFscGhhLWxldmVsIGhlcmUpIHdvdWxkIHN1cnBhc3MgdGhlIGNyaXRpY2FsIHZhbHVlLg0KKiBGaW5hbGx5LCB3ZSBjYWxjdWxhdGUgdGhlIHBlcmNlbnRhZ2Ugb2Ygc2VxdWVuY2VzIGFjY29yZGluZyB0byB0aGUgYWx0ZXJuYXRpdmUgaHlwb3RoZXNpcyAoZS5nLiBhIGNvaW4gaXMgdW5mYWlyIHdpdGggYSBiaWFzIG9mIDU1JSkgdGhhdCB3b3VsZCBzdXJwYXNzIHRoZSBjcml0aWNhbCB2YWx1ZS4gDQpUaGlzIGlzIHRoZSBwb3dlciBvZiBvdXIgdGVzdC4NCg0KSW4gcG93ZXItc2ltdWxhdGlvbiB3ZSBkbyBzb21ldGhpbmcgdmVyeSBzaW1pbGFyLCBidXQgaW5zdGVhZCBvZiBjYWxjdWxhdGluZyBob3cgbWFueSBwb3NzaWJsZSBkYXRhIHNlcXVlbmNlcyB0aGVyZSBhcmUgYW5kIGhvdyBtYW55IG9mIHRoZW0gcmVzdWx0IGluIGEgY3JpdGljYWwgdmFsdWUsIHdlIGp1c3QgX190cnlfXyB0aGlzIG91dCBhIGxvdCBvZiB0aW1lcyB1bnRpbCB3ZSBnZXQgYW4gYXBwcm94aW1hdGlvbiBvZiBob3cgb2Z0ZW4gd2Ugd291bGQgb2JzZXJ2ZSBkYXRhIHRoYXQgYXJlIGluY29uc2lzdGVudCB3aXRoIHRoZSBudWxsLWh5cG90aGVzaXMgZ2l2ZW4gb3VyIHNwZWNpZmllZCBhbHBoYS1sZXZlbC4NCg0KSSBob3BlIHlvdSBmb3JnaXZlIG15IHJhdGhlciBsZW5ndGh5IGludHJvZHVjdGlvbiBvbiBwb3dlci1hbmFseXNpcyBiZWZvcmUgYWN0dWFsbHkgZG9pbmcgdGhlIHNpbXVsYXRpb24sIGFzIEkgdGhvdWdodCBpdCB3b3VsZCBiZSBhIGdvb2QgZm91bmRhdGlvbiBiZWZvcmUgd2UgbW92ZSBvbiB0byBtb3JlIGNvbXBsZXggYW5kIHJlYWxpc3RpYyBzaXR1YXRpb25zLg0KDQoqIEluIHBhcnQgSUkgb2YgdGhpcyB0dXRvcmlhbCwgd2Ugd2lsbCBtb3ZlIG9uIHRvIHRoZXNlIG1vcmUgcmVhbGlzdGljIHNpdHVhdGlvbnMgdGhhdCB3ZSBtaWdodCBhY3R1YWxseSBiZSBpbnRlcmVzdGVkIGluIHBzeWNob2xvZ3kgYnkgbG9va2luZyBhdCBob3cgd2UgZG8gc2ltdWxhdGlvbnMgZm9yIHQtdGVzdHMuDQoqIEluIHBhcnQgSUlJIHdlIHdpbGwgY29udGludWUgd2l0aCBBTk9WQSBhbmQgcmVncmVzc2lvbiBkZXNpZ25zLg0KKiBJbiBwYXJ0IElWIHdlIHdpbGwgbG9vayBhdCBtaXhlZC1lZmZlY3RzL211bHRpbGV2ZWwgbW9kZWxzLg0KDQoNCiMgRm9vdG5vdGVzDQoNClteMV06DQpUaGUgYW5zd2VyIHRvIHRoZSBxdWVzdGlvbiAtIF9TaG91bGQgd2UgYmUgc3VycHJpc2VkXyAtIGlzIGJhc2ljYWxseSB3aGF0IHdlIGdldCB3aGVuIHdlIGRvIGEgc3RhdGlzdGljYWwgdGVzdCBhbmQgaW5zcGVjdCB0aGUgcC12YWx1ZS4NCk9rLCB0aGlzIGlzIG5vdCBleGFjdGx5IHRydWUgYnV0IHAtdmFsdWVzIF9jYW5fIGFjdHVhbGx5IGJlIGV4cHJlc3NlZCBpbiB0ZXJtcyBvZiBob3cgc3VycHJpc2VkIHdlIHNob3VsZCBiZSBhYm91dCBhbiBvYnNlcnZhdGlvbiwgZ2l2ZW4gYSBjZXJ0YWluIGh5cG90aGVzaXMgKGUuZy4gd2hlbiB3ZSBhc3N1bWUgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGdyb3VwcyBhcyB0aGUgbnVsbC1oeXBvdGhlc2lzKS4gDQpUbyByZWFkIGFuIGF3ZXNvbWUgZXhwbGFuYXRpb24gYWJvdXQgdGhpcywgbG9vayBhdCBbdGhpc10oaHR0cHM6Ly9sZXNzbGlrZWx5LmNvbS9zdGF0aXN0aWNzL3MtdmFsdWVzLykgcmVhbGx5IGNvb2wgYmxvZy1wb3N0IGFib3V0IF9zLXZhbHVlc18gYnkgW1phZCBDaG93XShodHRwczovL3R3aXR0ZXIuY29tL2RhaWx5emFkKS4NCg0KW14yXToNCldoeSBpcyB0aGUgb3JkZXIgaW1wb3J0YW50IGhlcmU/IA0KQmVjYXVzZSBvcmRlcnMgZG8gaWRlbnRpZnkgdW5pcXVlIG91dGNvbWVzLiANCklmIHdlIGRvIG5vdCBjb25zaWRlciBlbnRpcmUgc2VxdWVuY2VzLCB3ZSBtaWdodCBiZSBpbmNsaW5lZCB0byB0aGluayB0aGF0IHRoZXJlIGFyZSBvbmx5IGZvdXIgcG9zc2liaWxpdGllczogM3hIRUFEUywgMnhIRUFEUywgMXhIRUFEUyBhbmQgMHhIRUFEUywgYW5kIHRoYXQgZWFjaCBvZiB0aGVzZSBldmVudHMgaXMgZXF1YWxseSBsaWtlbHkuIA0KSG93ZXZlciwgaG93IGxpa2VseSBlYWNoIG9mIHRoZXNlIGV2ZW50cyBpcyBkZXBlbmRzIG9uIGhvdyBtYW55IGRpZmZlcmVudCBzZXF1ZW5jZXMgY2FuIHByb2R1Y2UgaXQuDQoNCg0KW14zXToNCkkgbG9va2VkIGl0IHVwIGFuZCBhcHBhcmVudGx5IHRoaXMgbnVtYmVyIChhIG9uZSBmb2xsb3dlZCBieSAzMCB6ZXJvcykgaXMgY2FsbGVkIGEgX05vbmlsbGlvbl8uIEl0IGlzIHNvIGJpZywgdGhhdCBhcHBhcmVudGx5IHRoZSBudW1iZXIgb2YgYmFjdGVyaWFsIGNlbGxzIG9uIGVhcnRoIGlzIGVzdGltYXRlZCBhdCBbNSBOb25pbGxpb25dKGh0dHBzOi8vd3d3LnBuYXMub3JnL2NvbnRlbnQvOTUvMTIvNjU3OCkuIA0KU28gSSBkbyBub3QgcmVjb21tZW5kIHRyeWluZyB0byB3cml0ZSBkb3duIGFsbCBwb3NzaWJpbGl0aWVzLi4uDQoNClteNF06DQpgUmAgZXhjbHVkZXMgdGhlIGZpcnN0IG51bWJlciBoZXJlLCBzbyB0aGF0IGlzIHdoeSB3ZSBzdGFydCBhdCA1NCByYXRoZXIgdGhhbiA1NQ0KDQpbXjVdOg0KTm90aWNlIGhvd2V2ZXIsIHRoYXQgdGhpcyBhbHBoYS1sZXZlbCBvZiAuMDUgaW1wbGllcyB0aGF0IHdlIGFyZSBzdXJwcmlzZWQgZW5vdWdoIGlmIHNvbWV0aGluZyBvbmx5IGhhcHBlbnMgaW4gMSBvdXQgb2YgMjAgY2FzZXMuDQpUaGVyZSBoYXZlLCBob3dldmVyLCBiZWVuIHJlcGVhdGVkIGNhbGxzIHRvIFtjaGFuZ2UgdGhlIHN0YW5kYXJkIGFscGhhLWxldmVsXShodHRwczovL3d3dy5uYXR1cmUuY29tL2FydGljbGVzL3M0MTU2MiUyMDAxNyUyMDAxODklMjB6KSwgdG8gW2p1c3RpZnkgaXQgYmFzZWQgb24gdGhlIHNwZWNpZmljIHNpdHVhdGlvbiB5b3UgYXJlIGluXShodHRwczovL3d3dy5uYXR1cmUuY29tL2FydGljbGVzL3M0MTU2Mi0wMTgtMDMxMS14KSBvciB0byBbYWJhbmRvbiBpdCBhbGwgdG9nZXRoZXJdKGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xNzA5LjA3NTg4KSBhbG9uZ3NpZGUgb3RoZXIgaWRlYXMgb2YgdXNpbmcgYWx0ZXJuYXRpdmVzIGxpa2UgdGhlIFtCYXllcy1GYWN0b3JdKGh0dHBzOi8vbGluay5zcHJpbmdlci5jb20vYXJ0aWNsZS8xMC4zNzU4L3MxMzQyMy0wMTEtMDA4OC03KS4NCkZvciB0aGUgbW9zdCBwYXJ0LCBpbiB0aGlzIHR1dG9yaWFsIEkgd2lsbCB0cnkgdG8ganVzdGlmeSB0aGUgYWxwaGEgdGhhdCBJIGNob29zZSBhbmQgdG8gc3RheSBhd2F5IGZyb20gdGhlICJtYWdpY2FsIiAuMDUgYXMgSSBhZ3JlZSB3aXRoIHRoZSBqdXN0aWZpY2F0aW9uIGFwcHJvYWNoIGluIHRoYXQgd2Ugc2hvdWxkIGF0IGxlYXN0IF90cnlfIGFuZCB0aGluayBoYXJkZXIgYWJvdXQgdGhlIGFscGhhLWxldmVsIGFuZCBpdCdzIG1lYW5pbmcuDQoNClteNl06DQpTb2Z0d2FyZSBsaWtlIEcqUG93ZXIgb2Z0ZW4gdXNlcyBkaWZmZXJlbnQgc3RhbmRhcmRpemVkIGVmZmVjdCBzaXplcyBmb3IgZGlmZmVyZW50IGFuYWx5c2VzLiANCkhvd2V2ZXIsIGluIG1hbnkgY2FzZXMgc3RhbmRhcmRpemVkIGVmZmVjdC1zaXplcyBjYW4gYmUgY29udmVydGVkIGludG8gZWFjaCBvdGhlci4gDQpJZiB5b3UgZXZlciBuZWVkIHRvIGRvIHN1Y2ggYSB0aGluZywgW0hhdXNlIExpbl0oaHR0cDovL2hhdXNlbGluLmNvbSkgbWFkZSBhIG5pY2UgW2NvbnZlcnNpb24gYXBwXShodHRwOi8vZXNjYWwuc2l0ZS8pLg0KDQpbXjddOg0KRm9yIHRob3NlIHVuZmFtaWxpYXIgd2l0aCB0aGlzIHJlZmVyZW5jZTogQ29uc2lkZXIgd2F0Y2hpbmcgRGFyayBLbmlnaHQsIGl0J3MgYSBncmVhdCBtb3ZpZS4gSW4gc2hvcnQsIHRoZSBkaXNwbGF5ZWQgY2hhcmFjdGVyLCBIYXJ2ZXkgRGVudCwgYSBmb3JtZXIgc3RhdGUgbGF3eWVyLCBmYWxscyBmcm9tIGdyYWNlIGFuZCBhbmQgbG9zZXMgaGlzIGZhaXRoIGluIHRoZSBsYXcgc3lzdGVtLiBIZSB0YWtlcyB0aGUgbGF3IGludG8gaGlzIG93biBoYW5kcyBhbmQgZGVjaWRlcyB3aGV0aGVyIHBlb3BsZSB3aWxsIGJlIHNlbnRlbmNlZCAoaS5lLiBraWxsZWQpIGJ5IHRvc3NpbmcgYSBjb2luLg0KDQpbXjhdOg0KVGhlcmVieSBqdXN0aWZ5aW5nIG91ciBhbHBoYS1sZXZlbCBpbiB0aGlzIHRveSBleGFtcGxlLg0KDQpbXjldOg0KSXQgbWlnaHQgYmUgY29uZnVzaW5nIHRoYXQgaSBzYXkgInNwZWNpZnkiIGEgbnVsbC1oeXBvdGhlc2lzIGhlcmUuIA0KSXMgdGhlIG51bGwtaHlwb3RoZXNpcyBub3QgYnkgZGVmaW5pdGlvbiB0aGF0IHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UsIGkuZS4gdGhhdCB0aGUgY29pbiBpcyBmYWlyIGF0IDUwJS4NCldlbGwsIHllcyBhbmQgbm8uIA0KT2YgY291cnNlIGFzc3VtaW5nIGNvaW4tZmFpcm5lc3MgaXMgdGhlIG1vc3QgbG9naWNhbCB0aGluZyB0byBkbyBoZXJlIGJ1dCBpbiByZWFsIGxpZmUsIG5vIG1hdHRlciB3aGF0IHJlc2VhcmNoIHF1ZXN0aW9uIHlvdSBhcmUgaW52ZXN0aWdhdGluZywgeW91IHdpbGwgY2xvc2UgdG8gX2Fsd2F5c18gZmluZCBhIGRpZmZlcmVuY2UgYmV0d2VlbiBncm91cHMuIA0KSWYgeW91IGtlZXAgaW5jcmVhc2luZyB0aGUgc2FtcGxlIHNpemUsIGF0IHNvbWUgcG9pbnQgdGhlIGVmZmVjdCB3aWxsIGFsd2F5cyBiZSBzaWduaWZpY2FudCwgbm8gbWF0dGVyIGhvdyBzbWFsbCB0aGUgZGV2aWF0aW9uIGlzLiANClRoaXMgaXMsIHdlIGNvdWxkIGV2ZW4gZmluZCB0aGUgdW5mYWlybmVzcyBvZiB0aGUgY29pbiBpZiBpdCBpcyBvbmx5IDUxJS4gDQpCdXQgaXMgdGhpcyA1MSUgcmVhbGx5IGJpZyBlbm91Z2ggdG8gY2FyZSBhYm91dD8gDQpNYXliZSwgbWF5YmUgbm90LCBidXQgd2UgY2FuIGRlZmluZSBhIF9zbWFsbGVzdCBlZmZlY3Qgc2l6ZSBvZiBpbnRlcmVzdF8gYW5kIHVzZSBfRXF1aXZhbGVuY2UgdGVzdGluZ18gaW4gd2hpY2ggdGhlIG51bGwtaHlwb3RoZXNpcyBpcyBhIGNlcnRhaW4gcmFuZ2Ugb2Ygc21hbGwgZGV2aWF0aW9ucyBmcm9tIHRoZSBhY3R1YWwgcG9pbnQgb2Ygbm8tZGlmZmVyZW5jZSBpbiB3aGljaCB3ZSBzYXkgdGhhdCB0aGUgZWZmZWN0IGlzIHRvbyBzbWFsbCB0byBjYXJlIGFib3V0LiANCkVxdWl2YWxlbmNlIHRlc3RpbmcgaXMgbm90IG5ldyBidXQgc3VycHJpc2luZ2x5IHVua25vd24gYW5kL29yIHVuY29tbW9uIGluIHRoZSBwc3ljaG9sb2dpY2FsIGxpdGVyYXR1cmUuIA0KSWYgeW91IGFyZSBpbnRlcmVzdGVkIGluIEVxdWl2YWxlbmNlIFRlc3RpbmcsIHlvdSBzaG91bGQgY2hlY2sgb3V0IHRoZSBncmVhdCBbcGFwZXIocyldKGh0dHBzOi8vam91cm5hbHMuc2FnZXB1Yi5jb20vZG9pLzEwLjExNzcvMjUxNTI0NTkxODc3MDk2MykgYW5kIFtibG9nLXBvc3QocyldKGh0dHA6Ly9kYW5pZWxsYWtlbnMuYmxvZ3Nwb3QuY29tLzIwMTgvMDgvZXF1aXZhbGVuY2UtdGVzdGluZy1hbmQtc2Vjb25kLmh0bWwpIGFib3V0IGl0IGJ5IFtEYW5pZWwgTGFrZW5zXShodHRwOi8vZGFuaWVsbGFrZW5zLmJsb2dzcG90LmNvbS8pIGFuZCBjb2xsZWFndWVzLg0KDQpbXjE0XToNClRoaXMgbWlnaHQgYmUgYSBnb29kIHBvaW50IHRvIG9wZW4gRypQb3dlciAobWF5YmUgZm9yIHRoZSBsYXN0IHRpbWUgZXZlciksIHRvIHNlZSB3aGV0aGVyIHlvdSBnZXQgdGhlIHNhbWUgY29uY2x1c2lvbnMgdGhlcmUgKHNwb2lsZXI6IHlvdSB3aWxsLCBhbmQgaWYgbm90LCB0aGF0IG9ubHkgc2hvd3MgdGhhdCBzb2Z0d2FyZSBsaWtlIHRoaXMgaXMgbm90IG5lY2Vzc2FyaWx5IGVhc2llciB0byB1c2UpLg0KDQpbXjExXToNCllvdSBjYW4gc2VlIHRoYXQgaXMgaXQgbm90IGEgc2ltdWxhdGlvbiBhcyB5b3Ugd2lsbCBhbHdheXMgZ2V0IHRoZSBfZXhhY3Qgc2FtZV8gcmVzdWx0IHdoZW5ldmVyIHlvdSBydW4gdGhlIGNvZGUgYWJvdmUuDQoNClteMTJdOg0KSW4gb3RoZXIgd29yZHMsIGluc3RlYWQgb2Ygd3JpdGluZyBhbGwgcG9zc2libGUgY29pbi10b3NzIHNlcXVlbmNlcyBkb3duIGFuZCBjb3VudGluZyBob3cgbWFueSBvZiB0aGVtIHdvdWxkIHByb2R1Y2UgNTUlIGhlYWRzIHdpdGggYSBjZXJ0YWluIGFtb3VudCBvZiB0b3NzZXMsIHdlIGNvdWxkIGp1c3QgcnVuIHZlcnkgbWFueSBleHBlcmltZW50cyBpbiB3aGljaCB3ZSBmb3IgZXhhbXBsZSB0aHJvdyBhIGNvaW4gMjAgdGltZXMuIA0KSWYgd2UgcmVwZWF0IHRoZXNlIDIwIHRvc3NlcyAxLDAwMCB0aW1lcywgd2UgZ2V0IGFuIGFwcHJveGltYXRpb24gb2YgaG93IG1hbnkgaGVhZHMgdGhlIHRvc3Mgc2VxdWVuY2VzIHByb2R1Y2Ugb24gYXZlcmFnZS4NCg0KW14xM106DQpUZWNobmljYWxseSB0aGUgdmVjdG9yIGNvbnRhaW5zIEZBTFNFIGluc3RlYWQgb2YgMCBhbmQgVFJVRSBpbnN0ZWFkIG9mIDEuIEhvd2V2ZXIsIGluIFIsIGFuZCBtYW55IG90aGVyIHByb2dyYW1taW5nIGxhbmd1YWdlcywgdGhlIHR3byBhcmUgaW50ZXJjaGFuZ2VhYmxlLCBhbGxvd2luZyB1cyB0byBjYWxjdWxhdGUgdGhlIG1lYW4gaW4gdGhlIHNhbWUgd2F5Lg0K" download="power-analysis-by-data-simulation-in-r-part-i.Rmd">Download power-analysis-by-data-simulation-in-r-part-i.Rmd</a>
<p><em>This blog is also available on <a href="https://www.r-bloggers.com/">R-Bloggers</a></em></p>
<div id="power-analysis-by-data-simulation-in-r---part-i-theoretical-introduction-to-simulation" class="section level1">
<h1>Power Analysis by Data Simulation in <code>R</code> - Part I: Theoretical introduction to simulation</h1>
<div id="why-this-blog" class="section level2">
<h2>Why this blog?</h2>
<p>In recent years, power-analysis has become a standard tool in the behavioral sciences.
With an ongoing replication crisis, high-power research is the a key to improving replicability and to improving the reliability of findings.
Especially with preregistration slowly becoming standard practice in psychology, power-analysis, the practice of estimating the required sample-size a-priori, is a more important step than ever to plan research projects accordingly.</p>
<p>Not so long ago, power-analysis was a rather complicated endeavor urging people to use algebraic solutions to calculate power of planned studies which can be demanding especially for non-trivial designs (i.e. basically anything that is not a correlation).
Luckily, for many research designs power-analysis is nowadays readily available in software packages such as <a href="http://www.gpower.hhu.de/">G*Power</a> and even for relatively complex designs in specialized tools such as the <em>great</em> <a href="https://jakewestfall.shinyapps.io/pangea/">PANGEA</a> tool for all kinds of generalized ANOVA designs and other tools by <a href="http://jakewestfall.org/">Jake Westfall</a>.</p>
<p>However, while these tools are really great they also have (in my personal opinion) two drawbacks.
First, they urge the user to familiarize themselves with a new piece of software with new user interfaces, that are not always intuitive.
Second, and more importantly, these interfaces promote a statistical way of thinking that often leaves the user confused with what the ever-changing parameters (think of these <span class="math inline">\(\delta\)</span> , <span class="math inline">\(d\)</span>, <span class="math inline">\(f\)</span>, <span class="math inline">\(f^2\)</span> and vague “group-size” and “measurement-point” fields) that need to be filled in mean.
Moreover, these parameters differ for most designs and give an impression that power-analysis is complicated business better left to statisticians or that it might not be worth the effort.</p>
<figure>
<img src="/img/power-tutorial/me-doing-pa.jpg" alt="drawing" width="500"/>
<figcaption>
<em>Figure 1. Me trying to figure out how to use a standard power-analysis software.</em>
</figcaption>
<figure>
<p>However, this impression changed dramatically for me, once I changed my ways and started doing power analysis by simulation.
Moreover, learning how to simulate data can of course not only be of use for power analysis but is a useful skill to in every research project.
When we simulate data, we can see whether what we <em>think</em> about the data-generating process will actually <em>result</em> in the patterns that we would expect.
In other words, we can do theoretical experiments to see whether if everything goes as we would expect, we would also find the results that we would expect.
Especially when our analyses become more complex, all the different parts in our model tend to interact and it is easy to get lost.
By simulating data before conducting an experiment, we will be forced (and able) to specify more precisely how we think a theoretical model or prediction will be reflected in the data.</p>
<p>Thus, even though this tutorial will focus on simulating data for power analysis, you will learn a very useful skill on the side - simulating your own data and thereby conducting theoretical experiments before you even collect data.
I know that there are already some excellent tutorials on data/power-simulation out there but they are often very brief and/or technical and assume a rather high level of prior knowledge about <code>R</code> and data-simulation in general.
Therefore, I will spend some time on explaining theoretical concepts and slowly build up the simulation-code to hopefully enable the reader to understand the underlying principles and flexibly conduct power simulations themselves after reading this.</p>
<p>Throughout the tutorial I assume readers are familiar with <code>R</code> and some of it’s base functionality.
This tutorial will consist of four different parts.</p>
<ul>
<li>In the first part (the one you are reading) I will give a short overview of how power-analysis by simulation works on a conceptual level and why I prefer it to available power-analysis software, even though there are clear drawbacks that I will also briefly mention.
Moreover, I will introduce the concept of power as I want to bring us all on the same page and want to give a (hopefully) intuitive example about what we actually do in power calculation and how it relates to the simulation techniques that we will use for the rest of the tutorial.</li>
<li>In the second part, I will discuss simulations for the simplest case of paired and two-sample t-tests.</li>
<li>In the third part, we will explore different ANOVA and regression designs.</li>
<li>In the fourth part we will move on to more complex mixed-effects and hierarchical models and even have a peak at Bayesian approaches to power analysis (well technically its not a power analysis but a true detection rate analysis).
For this fourth part, I assume readers will be familiar with how to fit mixed-effect models in <code>lmer</code> and/or <code>brms</code>.</li>
</ul>
<p>This part of the tutorial is by far the most wordy and longest part.
Just as a little motivator to keep in mind during this sometimes lengthy tutorial:
At the end of part IV of this tutorial, you will know how to do your own custom power analysis for mixed-effects models.</p>
</div>
<div id="power-analysis-by-simulation-a-sustainable-alternative" class="section level2">
<h2>Power Analysis by Simulation (a sustainable alternative)</h2>
<figure>
<img src="/img/power-tutorial/new-power.jpg" width="500"/>
<figcaption>
<em>Figure 2. The proof that there are alternative ways to how we normally get our power.</em>
</figcaption>
<figure>
</div>
<div id="what-is-power-again-a-brief-introduction" class="section level2 tabset tabset-fade tabset-pills">
<h2>What is power again? A <del>brief</del> introduction</h2>
<p>As my intention is to keep this post as short as possible (SPOILER: which definitely did not work), let’s directly dive into the topic by having a look at the definition of power:</p>
<p><strong>If a certain effect of interest exists (e.g. a difference between two groups) power is the chance that we actually find the effect in a given study.</strong></p>
<p>To provide some intuition about power, lets assume you toss a coin 10 times and you get 10 heads.
Should you be surprised about this?
Intuitively, it makes sense that we should be more surprised the more often we toss the coin and it keeps landing on head. 10 out of 10 heads would for example be less surprising than 10,000 out of 10,000, right?
This is exactly the question we want to answer when with power analysis<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.
How often should we toss the coin until we are surprised enough to conclude that the coin is not fair.</p>
<p>To translate the above situation into a Frequentist null-hypothesis significance testing (NHST) scenario, we hypothesize that the coin <em>is</em> indeed fair (null-hypothesis) and see whether or not the observed number of heads (the observed data) fits with this hypothesis or not. If yes, we will retain the null-hypothesis that the coin is fair, if not, we will conclude that the data are very unlikely to result from tossing a fair coin.</p>
<p>How do we do this?
Well, assume we observed 3 heads out of 3 total tosses.
Now we can count all ways that this could have happened with a fair coin and compare it to all possible outcomes that our coin toss experiment might have produced.
These possibilities are (for a fair coin or any coin that cannot produce only heads or only tails):</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>Toss #1</th>
<th>Toss #2</th>
<th>Toss #3</th>
<th>number of heads</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Possibility #1</td>
<td>HEAD</td>
<td>HEAD</td>
<td>HEAD</td>
<td>3</td>
</tr>
<tr class="even">
<td>Possibility #2</td>
<td>HEAD</td>
<td>HEAD</td>
<td>TAIL</td>
<td>2</td>
</tr>
<tr class="odd">
<td>Possibility #3</td>
<td>HEAD</td>
<td>TAIL</td>
<td>TAIL</td>
<td>1</td>
</tr>
<tr class="even">
<td>Possibility #4</td>
<td>TAIL</td>
<td>TAIL</td>
<td>TAIL</td>
<td>0</td>
</tr>
<tr class="odd">
<td>Possibility #5</td>
<td>TAIL</td>
<td>TAIL</td>
<td>HEAD</td>
<td>1</td>
</tr>
<tr class="even">
<td>Possibility #6</td>
<td>TAIL</td>
<td>HEAD</td>
<td>HEAD</td>
<td>2</td>
</tr>
<tr class="odd">
<td>Possibility #7</td>
<td>TAIL</td>
<td>HEAD</td>
<td>TAIL</td>
<td>1</td>
</tr>
<tr class="even">
<td>Possibility #8</td>
<td>HEAD</td>
<td>TAIL</td>
<td>HEAD</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Notice that a possibility is not only defined by the number of heads and tails but also by the order in which they occur<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. We can also calculate the number of possibilities as <span class="math inline">\(2^x\)</span> where 2 means that we have 2 possible outcomes per toss and <span class="math inline">\(x\)</span> is the number of tosses. In this case the number of possibilities is therefore <span class="math inline">\(2^3 = 8\)</span>.
Only 1 of these 8 events (Possibility 1) can produce 3 out of 3 heads.
If our coin is fair, each of these events should be equally likely and we can see that when flipping a fair coin 3 times, in only 1 out of 8 cases (12.5%) we will get 3 heads (Possibility 1).</p>
<p>Do we find this surprising enough to conclude that the coin that we flipped is unfair?
Maybe, maybe not.
If not, instead of flipping the coin three times, we could flip it 100 times.
Imagine we observed 55 heads in 100 flips.
We could now start writing down all possible outcomes, but that would take some time.
This time, there are not 8 but <span class="math inline">\(2^{100}\)</span> = 1,267,651,000,000,000,000,000,000,000,000 possible sequences of heads and tails, and we would have to count the ones that produce <em>at least</em> 55 heads to see how often that would happen if our coin is fair<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>.</p>
<p>However, luckily we are not the first who are interested in these kind of problems and we can make use of mathematical formulas that other people figured out for us.</p>
<p>In this case we need the <strong>binomial</strong> probability mass function.
In short, this function defines how often we can get each outcome, assuming a certain chance of getting heads or tails.
If you are interested in seeing this function and see how we can hand-code it in <code>R</code>, then click on the info-box below.
If you do not want to get too much into the technicalities here, you can also just read on.</p>
<p></br></p>
<details>
<p><summary>
<div class="alert alert-note">
  <div>
    <!-- raw HTML omitted -->Click here to extend information about the binomial likelihood function<!-- raw HTML omitted -->
  </div>
</div>

</summary></p>
<div class="notebox">
<p>
<p><span class="math display">\[P(x)=\frac{N!}{x!(N-x)!}\pi^x(1-\pi)^{N-x} \]</span></p>
<p>For people who are not used to mathematical formulas, this might already look intimidating. However, all we need to know right now is that this formula gives us the probability of getting x heads <span class="math inline">\(P{(x)}\)</span> (i.e. the number of ways we get x heads divided by N tosses):
Note that <span class="math inline">\(\pi\)</span> in the above formula is not the one we might know from geometry but it is simply the Greek letter for p denoting a probability here.
In this case, it is the probability of either event, heads or tails, happening on each toss so it is 50% or 0.5.
We can fill this in for the example above:</p>
<p><span class="math display">\[P(55)=\frac{100!}{55!(100-55)!}0.5^{55}(1-0.5)^{100-55}\]</span></p>
<p>Translating this formula into <code>R</code> syntax we get the following:</p>
<p><code>factorial(100)/(factorial(55)*factorial(100-55))*0.5^55*(1-0.5)^(100-55)</code> = 0.05</p>
<p>However, before we said that we do not need the probability of <em>exactly</em> 55 heads but everything that is <em>at least 55</em>. In order to answer our question how often we get <em>at least</em> 55 heads, we could repeat the above calculation with all values from 55 up until 100 and add up the probabilities that we get.</p>
<p>For example we could do this with a for-loop:</p>
<pre class="r"><code># first we write a function that calculates the probability for each number so we can call it in a loop
pbinom2 &lt;- function(N, x, p){
  factorial(N)/(factorial(x)*factorial(N-x))*p^x*(1-p)^(N-x)
}

tosses_55to100 &lt;- c(55:100)  # we define the amount of heads that we want to check for (all bigger than or equal to 55)
probs &lt;- c() # we will make an empty collection that we will add the results for each number of heads to

for(i in tosses_55to100){
  probs &lt;- append(probs, pbinom2(100,i,.5))
}
print(probs[1:10])</code></pre>
<pre><code>##  [1] 0.048474297 0.038952560 0.030068643 0.022292270 0.015869073 0.010843867
##  [7] 0.007110732 0.004472880 0.002697928 0.001559739</code></pre>
<p>Now we got all the probabilities for each of the amounts of heads that we are interested in.
By summing them up we get what we need - the probability of getting at least 55 heads in 100 tosses, <code>sum(probs)</code> = 0.18 or 18 percent.</p>
</p>
</div>
</details>
<p></br></p>
<p>As mentioned, fortunately, the counting of possibilities is pre-implemented into <code>R</code>.
Running <code>pbinom(x = 54, size = 100, prob = .5, lower.tail = FALSE)</code> (I will explain below) we can get R to calculate the proportion of samples that would result in <em>more than</em> <code>x</code> times heads in an experiment of <code>size</code> 100 (i.e. tossing a coin 100 times).
Executing this in <code>R</code> we get 0.18.</p>
<p>In short, the <code>pbinom</code> function gives us the answer to the question "what is proportion of possible toss-sequences that results in more than <code>x = 54</code><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> heads if we toss a coin <code>size=100</code> times if our hypothesis is that the coin is fair with a probability of heads of <code>prob = .5</code>.
The <code>lower.tail = FALSE</code> argument tells <code>R</code> that we want the the probability of the upper part of the probability mass (i.e. the probability of getting 55 or <em>more</em> heads rather than 54 or <em>less</em>).
In other words, every 6th out of the <span class="math inline">\(2^{100}\)</span> possible sequences has 55 or more heads.
Again, this is not really surprising and would probably not make us conclude that a coin is definitely unfair.</p>
<p>If, for example, we think that a coin is unfair if the amount of heads (or more heads) has only a probability of .01 or 1 percent, what amount of heads would allow us to draw such a conclusion when tossing a coin 100 times?
To solve this, we can just use the <code>pbinom</code> function for not only <code>x = 55</code> heads but also 56 up to 100 heads, and see from which point onwards only 1 percent of all <span class="math inline">\(2^{100}\)</span> sequences include so many heads.</p>
<p>The code below does exactly this.
Conveniently the <code>pbinom</code> function cannot only evaluate 1 value at the same time but we can just pass all values that we want to try as a sequence and it will give us the probability of <code>x</code> heads for each of them so we can store them as a collection of values.
We can plot these values to see when we cross the 1 percent line.</p>
<pre class="r"><code>n_heads &lt;- 54:99  # all possible amount of heads that we want to try.

p_heads &lt;- pbinom(q = n_heads, size = 100, prob = .5, lower.tail = F)  # get pbinom to show us the probability of so many heads for each of the values if a coin is fair

plot(n_heads, p_heads)
abline(h = .01)
abline(v = n_heads[p_heads &lt; .01][1])</code></pre>
<p><img src="/post/2020-04-22-power-analysis-by-data-simulation-in-r-part-i_files/figure-html/caclulate_p1percent-1.png" width="672" /></p>
<p>Using the above we see that the at 62 tosses, i.e. the 9th element of the vector is the first probability that is smaller than .01, in this case 0.006.
In other words, getting 62 or more heads in 100 tosses would only happen extremely rarely, in 1 out of 62 cases.
Thus actually getting 62 heads is pretty surprising and if something like that happened we might conclude that a coin is unfair.</p>
<p>However, instead of following the approach above, there is an easier way to get the number of heads that would surprise us by using the <code>qbinom</code> function that gives us the quantile (i.e. number of heads or more heads) that would only happen with a certain probability: <code>qbinom(p = .01, size = 100, prob = .5, lower.tail = FALSE)</code> = 62, unsurprisingly gives us the same result.</p>
</div>
</div>
<div id="back-to-power" class="section level1">
<h1>Back to Power</h1>
<p>In this coin-toss example, we run a statistical test about the fairness of the coin.
But what is the <strong>power</strong> of the test here (in case you forgot during my very long “brief” introduction, this post was about power)?</p>
<p>Actually, we already used three concepts from Frequentist statistical testing:</p>
<ul>
<li>The <strong>null-hypothesis</strong>: we assumed that the coin is fair</li>
<li>The <strong>p-value</strong> : the probability that we calculated above when checking how likely 62 or more heads are (we got 0.006).</li>
<li>The <strong>alpha level</strong> : (i.e. where people conventionally use .05 in psychological literature<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>) is the threshold that we picked for concluding it would surprise us enough to say that the coin must be unfair, i.e. the probability of .01. In other words, it is the chance that we conclude that a coin is unfair even if it is actually fair (the one percent of cases where 62 or more heads would happen even with a fair coin).</li>
</ul>
<p>In a proper power analysis, all of these need to be specified in addition to an <em>alternative hypothesis</em>. Let’s give it a try and specify them to run a power-analysis</p>
<div id="specifying-the-null-hypothesis." class="section level2">
<h2>Specifying the null-hypothesis.</h2>
<p>Again, we will assume that a coin is fair and will produce heads with a probability of .50<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>.</p>
</div>
<div id="specifying-the-alternative-hypothesis-aka-effect-size." class="section level2">
<h2>Specifying the Alternative Hypothesis aka Effect Size.</h2>
<p>To conduct a proper power-analysis, it is important that we specify a concrete <em>alternative hypothesis</em> (or effect size).
If we do know have a hypothesis about the effect size, we can <em>by definition</em> not know the power to investigate this hypothesis.
Makes sense, right?</p>
<p>This means we will try to think about an effect size that would be meaningful in this coin flip example.
For instance, if you use the coin to make an important decision, i.e. when the fairness of the coin is very important (see e.g. <a id="Figure-3-Ref" href="#Figure-3">Figure 3</a>)<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> you would probably want to be very strict about when a coin is unfair and would like to, for instance, already conclude that it is unfair at 55% percent heads, a deviation from a truly fair coin of 5%.</p>
<p><div class="alert alert-note">
  <div>
    Most software packages use effect-size estimates like Cohen’s d or f or other <!-- raw HTML omitted -->standardized effect sizes<!-- raw HTML omitted -->.
We will have a look at how to do this with simulations briefly in the second part of the tutorial, but throughout this tutorial, we will mostly follow a different approach by trying to specify the expected effect size on the <!-- raw HTML omitted -->raw<!-- raw HTML omitted --> scale.
  </div>
</div>
<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
</div>
<div id="specifying-the-alpha-level" class="section level2">
<h2>Specifying the alpha-level</h2>
<p>Furthermore, as it does not deem you a good idea to get into a fight with Harvey (<a id="Figure-3-Ref" href="#Figure-3">Figure 3</a>) by incorrectly accusing him of using an unfair coin, you want the chance of this happening (i.e. the alpha-level) to be very low at only 0.1 percent (1 in a 1000 cases)<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>.</p>
</div>
<div id="specifying-the-desired-power" class="section level2">
<h2>Specifying the desired power</h2>
<p>Moreover, you also want to be sure that you <em>would</em> detect the unfairness of 55% if it is actually there.
Let’s say you only want to have a 10 percent chance of not detecting it if it was there.
100 minus this chance is the <em>power</em> of our coin-toss study, i.e. 90 percent (or 1-.10 on the probability scale).</p>
<a id="Figure-3">
<figure>
<img src="https://media1.tenor.com/images/507d58a626fa15cb0b57e57f7a1cb873/tenor.gif?itemid=9698651" width="500"/>
<figcaption>
<em>Figure 3. An illustrative example of when a coin-toss really matters.</em><a href="#Figure-3-Ref">↩︎</a>
</figcaption>
</figure>
<p></a></p>
<p>To summarize, our test has the following properties:</p>
<ul>
<li>alpha-level = .001</li>
<li>alternative hypothesis (aka effect size / fairness-criterion) = 55% heads</li>
<li>power = .90</li>
</ul>
<p>Our job now is to figure out at which number of tosses we can be 90% sure to detect the unfairness of 55% with only a 0.1% chance of getting into a fight with Harvey by wrongly accusing him of unfairness.</p>
<p>To do this we can use the following r-code (I will explain below)</p>
</div>
<div id="the-first-power-calculation" class="section level2">
<h2>The first Power Calculation</h2>
<pre class="r"><code>power_at_n &lt;- c(0) # initialize vector that stores power for each number of tosses
n_heads &lt;- c() # save &quot;critical&quot; number of heads for that toss-amount that would result 
n_toss &lt;- 2 # initialize the toss-counter
while(power_at_n[n_toss-1] &lt; .90){ # continue as long as power is not 90%
  n_heads[n_toss] &lt;- qbinom(.001, n_toss, .5, lower.tail = F) # retrieve critical value
  power_at_n[n_toss] &lt;- pbinom(n_heads[n_toss], n_toss, .55, lower.tail = F) # calculate power (1-beta) for each coin-toss
  n_toss &lt;- n_toss+1 # increase toss-number 
}</code></pre>
<p>The above loop needs some explanation.
It increases the toss-amount <code>n_toss</code> by 1 as long as it has not yet reached 90% power.
To do this, we again use the <code>qbinom</code> function to find the number of heads (or more heads) that would only occur with a probability of .001.
In other words, only 0.1% of the possible coin toss sequences would result in that specific amount of heads when tossing the coin <code>n_toss</code> times.
This is the same thing we did earlier with a fixed amount of 100 tosses.</p>
<p>in the next line, we take this amount of heads that only occurs with a probabiltiy of .001 for the current toss amount <code>n_toss</code> and use <code>pbinom</code> to calculate the probability of getting <em>at least</em> this many heads with our hypothesized <em>unfair</em> coin that produces heads in 55% of the cases.
This means, we calculate the percentage of coin toss sequences that contain at least this many heads.
This probability is the <strong>power</strong> of the test.
Why?
Because if 90% of the sequences contain 55% or more heads, if we take the coin and toss it <code>n_toss</code> times,in 90% of the cases we will get one of those sequences that contain 55% or more heads.</p>
<p>Lets have a look at two of the values from this calculation to make this more clear.
For instance, lets look at the values when the loop tried out 100 tosses:</p>
<p><code>n_heads[100]</code> = 65. This number is higher than the 62 heads we had above, as we are more strict now by specifying a stricter alpha level (.001 instead of .01).
Next, this 65 was passed on to the <code>pbinom</code> function and we can look at the power, <code>power_at_n[100]</code> = 0.02.
At this point we only have a power of .02 or 2%.
This means that tossing an unfair coin that would give 55% heads 100 times, only 2% of the sequences would contain 55 or more heads, therfore making it unlikely that we would detect the unfairness.
When we increase the number of tosses until the loop stops, we are at <code>n_toss-1</code> = 1908 coin tosses.
At this number of tosses, the amount of heads that would make us conclude that a fair coin is unfair (biased with 55% heads) with only 0.1% chance of being wrong is <code>n_heads-[n_toss-1]</code> = 1021.
Thus in this case, with 1908 tosses, if we get 1021 heads or more, we conclude that the coin is unfair.
What is the chance of getting at least that with our <em>unfair</em> coin?
That’s what the <code>pbinom</code> function in the loop above tells us and it is <code>power_at_n[n_toss-1]</code> = 0.9, our specified 90%.
We can also plot the power for each number of tosses that we tried in the loop.
Figure 4 shows the increase in power with increasing sample-size.</p>
<a id="Figure-4">
<figure>
<pre class="r"><code>plot(1:(n_toss-1), power_at_n, xlab = &quot;Number of coin-tosses&quot;, ylab = &quot;Power&quot;, axes = FALSE)
abline(h = .90, col = &quot;red&quot;)
axis(side = 1, at = seq(0,(n_toss-1),by=100))
axis(side = 2, at = seq(0,1,by=0.1))</code></pre>
<img src="/post/2020-04-22-power-analysis-by-data-simulation-in-r-part-i_files/figure-html/power-curve1-1.png" width="672" />
<figcaption>
<em>Figure 4. Change in power until we reach 90% indicated by the red horizontal line.</em>
</figcaption>
</figure>
<p></a></p>
<p>Thus, when tossing a coin 1908 times<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>, in 90% of the cases we will be able to tell it’s biased and can confidently confront Harvey like shown in Figure 5.</p>
<figure>
<img src="https://i.redd.it/wyklemmf5zz11.png" alt="confronting-harvey" width="500"/>
<figcaption>
<em>Figure 5. Confronting Harvey and telling him what we think about his coin.</em>
</figcaption>
</figure>
<p>If you are not familiar with using these distribution functions (<code>qbinom</code>, <code>pbinom</code> etc.) in <code>R</code>, this might have been a lot of new information but this is basically what we do in power analysis:</p>
<ol style="list-style-type: decimal">
<li>We specify a null-hypothesis, an alternative hypothesis, an alpha-level and a desired power,</li>
<li>We try a small sample-size.</li>
<li>We retrieve the critical value, (the number of heads that would be more surprising than what we specified as our alpha-level).</li>
<li>We calculate the probability that the amount of heads that would make us reject the null-hypothesis would be observed with the unfair coin according to the alternative hypothesis.</li>
<li>We stop as soon as this probability is equal to the desired power.</li>
</ol>
</div>
</div>
<div id="finally-an-actual-power-simulation." class="section level1">
<h1>Finally, an actual power simulation.</h1>
<p>So far, we have not done any simulation but have merely analytically derived the power by making use of the binomial probability mass function<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>.
Thus, for easy toy-examples like this one we would not need to do a simulation.
However, as soon as we deal with real examples, it is much more difficult to make use of this approach and if we have several predictors in our model, or if we deal with mixed-effect models or hierarchical models (as we will do in part IV of this tutorial) the above method is not feasible anymore.</p>
<p>What we can do however, for any model of any complexity and form, is to actually pretend we were repeatedly doing the experiment for each sample size and see how often we would be able to reject the null-hypothesis.
For instance we could toss a coin 20 times and test whether we would reject the null-hypothesis.
We could then repeat this process for 20 tosses very often, e.g. 1,000 times and see what the probability is that we would conclude that the null-hypothesis is false<a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a>.
This is what we do in power-simulation.</p>
<p>An obvious disadvantage is that instead of just calculating the power for each toss-amount (i.e. sample-size) only once, we need to try each toss-amount out 1,000 times.
Thus, simulation takes much longer than a regular power-calculation, especially with more complex models and high sample-sizes.
However, the advantage of the method is that we can just learn it once and adjust it for any situation that we will ever find ourselves in, not having to ever walk through tedious interfaces again, selecting arbitrary analyses and setting ever changing parameters to certain values.
Another advantage (that will be discussed in detail later) is that we do not need to specify a precise alternative hypothesis and test it for that single value, but that we can actually remain more vague about what our alternative hypothesis (i.e. the effect size that we expect) will be.
Oftentimes we do not know exactly what effect-size we can expect and we might like to tell the power-analysis about this uncertainty.</p>
<p>At last, let us do a power-simulation for the above example.
Luckily we do not really have to toss a coin as <code>R</code> can do that for us by using the <code>rbinom</code> function, that will as often as we call it do a coin-tossing experiment for us with a specified sample-size.
Lets first see how the <code>rbinom</code> function works if we would want to toss a coin 20 times.</p>
<pre class="r"><code>set.seed(1) # make sure our simulation will give the same results if you try it
rbinom(n = 1, size = 20, prob = .50) # let r do 1 experiment with 20 coin tosses of a fair coin</code></pre>
<pre><code>## [1] 9</code></pre>
<p>In the above code, <code>R</code> tossed a coin 20 times and it resulted in 9 heads.
We could repeat this experiment again:</p>
<pre class="r"><code>set.seed(2) # make sure our simulation will give other results than before
rbinom(n = 1, size = 20, prob = .5) # run the experiment again</code></pre>
<pre><code>## [1] 8</code></pre>
<p>In this case, giving us 8 heads.
By increasing the first argument to the <code>rbinom</code> function, we can tell <code>R</code> to repeat this experiment more often.
Moreover, we can tell it to make use of an unfair coin directly, so we can directly put our alternative hypothesis in the simulation by changing the last number of the <code>rbinom</code> function from .50 to .55, to do the same test as above.</p>
<pre class="r"><code>set.seed(1)
n_heads &lt;- rbinom(n = 1000, size = 20, prob = .55) # run 1,000 experiments, of 20 coin tosses each, at once
str(n_heads) # show structure of vector</code></pre>
<pre><code>##  int [1:1000] 12 12 11 8 13 8 7 10 10 14 ...</code></pre>
<p>Now, <code>R</code> repeated the 20 coin-toss experiment 1,000 times with an unfair coin of 55% chance of resulting in heads giving us 1,000 times the amount of heads that it got.
Let us again now test how big our power was in this case, again with an alpha-level of .001.</p>
<pre class="r"><code>p_heads &lt;- pbinom(n_heads, 20, .50, lower.tail = F) # calculate the probability of observing this many heads if the coin would be fair (which it is not cause we simulated with 55% heads)

exp_power &lt;- mean(p_heads &lt; .001) # check where this chance drops below our alpha level</code></pre>
<p>The first line in the above code does exactly what we did earlier, just with a little change.
We take the amounts of heads that we got from an unfair coin, and check in how many cases we would conclude - assuming that the coin would actually be fair, thus using .50 as the probability in <code>pbinom</code> - that the observed amounts of heads is too unlikely for us to believe that the coin was fair.
We save these probabilities to a vector.
The second line calculates the observed power of our experiment.
To understand what it does, let us have a look at the vector p_heads it looks the following (here only the first 10 out of 1,000 values):</p>
<pre class="r"><code>p_heads[1:10]</code></pre>
<pre><code>##  [1] 0.13158798 0.13158798 0.25172234 0.74827766 0.05765915 0.74827766
##  [7] 0.86841202 0.41190147 0.41190147 0.02069473</code></pre>
<p>As shown above, the <code>p_heads</code> vector contains the probability of observing each amount of heads <code>n_heads</code> from our 1,000 experiments assuming the experiment was done with a fair coin (which it was not).
Now we would like to check how many of these probabilities are at least as small as our alpha-level, i.e. surprising enough to conclude the coin was not fair.
We do this by checking for each value whether it was .001 or smaller (<code>p_heads &lt; .001</code>).
This will result in another vector of 0 when the condition is false and 1 when the condition is true<a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a>.
Taking the mean of this vector will give us the probability of rejecting the null-hypothesis while we actually know it is incorrect (as we put the bias in the coin ourselves).
Again, this will give us the power.
In the present case with 20 coin-tosses the power is <code>exp_power</code> = 0.004 or 0.4 percent.
This is obviously very low and not surprising given that we already know from the calculation above that we need a lot more coin-tosses than 20 to get the desired power of 90%.
To get to our desired power in this example, we need to change the code above so it will try different sample-sizes again.</p>
<pre class="r"><code>set.seed(1)
exp_power_at_n &lt;- c(0) # create a vector where we can store the power for each sample-size
n_toss_start &lt;- 19 # start at 21 tosses
n_toss_loop &lt;- 2 # additional number of tosses tried (above 20)
while(exp_power_at_n[n_toss_loop-1] &lt; .90){ # continue increasing the sample-size until power = 90%
  n_toss &lt;- n_toss_start+n_toss_loop # calculate the current number of tosses
  n_heads &lt;- rbinom(1000, n_toss, .55) # run 1000 experiments for any given number of tosses and store number of heads
  p_heads &lt;- pbinom(n_heads, n_toss, .50, lower.tail = F) # calculate the probability of getting at least that many heads if the coin would be fair 
  exp_power_at_n[n_toss_loop] &lt;- mean(p_heads &lt; .001) # calculate power by checking what proportion of the probabilities is smaller than or equal to our alpha-level
  n_toss_loop = n_toss_loop+1
}

exp_power_at_n &lt;- exp_power_at_n[-1] # remove the first 0 that we used to populate the vector for the first iteration of the loop</code></pre>
<p>The above code is similar to what we have done earlier when we tried only 1 sample-size.
This time, we iterate over different sample-sizes in a loop and store the power for each in the vector <code>exp_power_at_n</code>.
As in the earlier calculation, we can now use this to see how many tosses we would need by having a look at where the loop stopped, i.e. when it reached 90% power, which is at <code>n_toss-1</code> = 1795 tosses at which the power was <code>exp_power_at_n[length(exp_power_at_n)]</code> = 0.903.
We can also plot all these values again as done in Figure 6.</p>
<figure>
<pre class="r"><code>plot(21:n_toss, exp_power_at_n, xlab = &quot;Number of coin-tosses&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = FALSE)
abline(h = .90, col = &quot;red&quot;)
axis(side = 1, at = seq(0,(n_toss),by=100))
axis(side = 2, at = seq(0,1,by=0.1))</code></pre>
<img src="/post/2020-04-22-power-analysis-by-data-simulation-in-r-part-i_files/figure-html/figure6-1.png" width="672" />
<figcaption>
<em>Figure 6. Observed power in the simulation.</em>
</figcaption>
<figure>
<p>The shape of the line looks very similar to the earlier calculation, however the line appears to be thicker.
Moreover, it might be surprising that we did not get the same amount of tosses that we got from the calculation.
Actually they differ quite a lot (1908 vs. 1795).
This is due to the fact that even when running 1,000 experiments for each sample-size there is still imprecision in the simulation.
Each coin-flip is random and even if we repeat a experiment 1,000 times this randomness is still in there (think of how many possible sequences there would be!).
This randomness is why we cat a different number in the simulation and why the line in Figure 6 is thicker than in <a href="#Figure-4">Figure 4</a>.</p>
<p>If we want to approach the results of the calculation more closely in our simulation (i.e. get a more precise power-estimate) we can increase the number of experiments that <code>R</code> will run per sample-size (i.e. the number of simulations).
For example, we could repeat the simulation with 100,000 experiments per sample-size.
You have to be patient here, this already takes a few minutes maybe.</p>
<pre class="r"><code>set.seed(1)
exp_power_at_n &lt;- c(0) # create a vector where we can store the power for each sample-size
n_toss_start &lt;- 19 # start at 21 tosses
n_toss_loop &lt;- 2 # additional number of tosses tried (above 20)
while(exp_power_at_n[n_toss_loop-1] &lt; .90){ # continue increasing the sample-size until power = 90%
  n_toss &lt;- n_toss_start+n_toss_loop # calculate the current number of tosses
  n_heads &lt;- rbinom(100000, n_toss, .55) # run 1000 experiments for any given number of tosses and store number of heads
  p_heads &lt;- pbinom(n_heads, n_toss, .50, lower.tail = F) # calculate the probability of getting at least that many heads if the coin would be fair 
  exp_power_at_n[n_toss_loop] &lt;- mean(p_heads &lt; .001) # calculate power by checking what proportion of the probabilities is smaller than or equal to our alpha-level
  n_toss_loop = n_toss_loop+1
}

exp_power_at_n &lt;- exp_power_at_n[-1] # remove the first 0 that we used to populate the vector for the first iteration of the loop</code></pre>
<p>If you run this code, you will see that it took substantially longer than the previous simulation with only 1,000 repetitions.
If we now look at the outcome again we find that the number of tosses <code>n_toss-1</code> = 1870 is already slightly closer to the calculated value but still not exactly the same.
In my personal opinion, this imprecision is both advantage of simulation as well as disadvantage.
It is a disadvantage in that it is less precise than the calculation above in theory.
However, it is an advantage as it adds some noise to the power-estimation process that is actually also present in real life.
This is, even if there is an effect in the population, each new sample will always be different which is also the case in the simulation.
If we look at Figure 7, we also see that now the power-increase follows a more straight line again that is very close to the one from the exact calculation and not as thick anymore as in Figure 6.</p>
<figure>
<pre class="r"><code>plot(21:n_toss, exp_power_at_n, xlab = &quot;Number of coin-tosses&quot;, ylab = &quot;Power&quot;, ylim = c(0,1), axes = FALSE)
abline(h = .90, col = &quot;red&quot;)
axis(side = 1, at = seq(0,(n_toss),by=100))
axis(side = 2, at = seq(0,1,by=0.1))</code></pre>
<img src="/post/2020-04-22-power-analysis-by-data-simulation-in-r-part-i_files/figure-html/figure7-1.png" width="672" />
<figcaption>
<em>Figure 7. Power curve for a more precise simulation.</em>
</figcaption>
</figure>
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>In this part of the tutorial I tried to bring us all on the same page about why we would do data or power simulation and how it is related to exact power calculation.</p>
<ul>
<li>In principle, in power calculation we count the amount of potential data sequences (e.g. possible sequences of HEADS-TAILS in coin-tosses) that could happen in an experiment of a specific size (e.g. amount of coin-tosses).</li>
<li>Afterwards, we calculate the critical value (e.g. number of heads) that would make us reject the null-hypothesis (e.g. a coin is fair) as only a very small percentage of sequences (“small” is defined by the alpha-level here) would surpass the critical value.</li>
<li>Finally, we calculate the percentage of sequences according to the alternative hypothesis (e.g. a coin is unfair with a bias of 55%) that would surpass the critical value.
This is the power of our test.</li>
</ul>
<p>In power-simulation we do something very similar, but instead of calculating how many possible data sequences there are and how many of them result in a critical value, we just <strong>try</strong> this out a lot of times until we get an approximation of how often we would observe data that are inconsistent with the null-hypothesis given our specified alpha-level.</p>
<p>I hope you forgive my rather lengthy introduction on power-analysis before actually doing the simulation, as I thought it would be a good foundation before we move on to more complex and realistic situations.</p>
<ul>
<li>In part II of this tutorial, we will move on to these more realistic situations that we might actually be interested in psychology by looking at how we do simulations for t-tests.</li>
<li>In part III we will continue with ANOVA and regression designs.</li>
<li>In part IV we will look at mixed-effects/multilevel models.</li>
</ul>
</div>
<div id="footnotes" class="section level1">
<h1>Footnotes</h1>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The answer to the question - <em>Should we be surprised</em> - is basically what we get when we do a statistical test and inspect the p-value.
Ok, this is not exactly true but p-values <em>can</em> actually be expressed in terms of how surprised we should be about an observation, given a certain hypothesis (e.g. when we assume no difference between groups as the null-hypothesis).
To read an awesome explanation about this, look at <a href="https://lesslikely.com/statistics/s-values/">this</a> really cool blog-post about <em>s-values</em> by <a href="https://twitter.com/dailyzad">Zad Chow</a>.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Why is the order important here?
Because orders do identify unique outcomes.
If we do not consider entire sequences, we might be inclined to think that there are only four possibilities: 3xHEADS, 2xHEADS, 1xHEADS and 0xHEADS, and that each of these events is equally likely.
However, how likely each of these events is depends on how many different sequences can produce it.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>I looked it up and apparently this number (a one followed by 30 zeros) is called a <em>Nonillion</em>. It is so big, that apparently the number of bacterial cells on earth is estimated at <a href="https://www.pnas.org/content/95/12/6578">5 Nonillion</a>.
So I do not recommend trying to write down all possibilities…<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p><code>R</code> excludes the first number here, so that is why we start at 54 rather than 55<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Notice however, that this alpha-level of .05 implies that we are surprised enough if something only happens in 1 out of 20 cases.
There have, however, been repeated calls to <a href="https://www.nature.com/articles/s41562%20017%200189%20z">change the standard alpha-level</a>, to <a href="https://www.nature.com/articles/s41562-018-0311-x">justify it based on the specific situation you are in</a> or to <a href="https://arxiv.org/abs/1709.07588">abandon it all together</a> alongside other ideas of using alternatives like the <a href="https://link.springer.com/article/10.3758/s13423-011-0088-7">Bayes-Factor</a>.
For the most part, in this tutorial I will try to justify the alpha that I choose and to stay away from the “magical” .05 as I agree with the justification approach in that we should at least <em>try</em> and think harder about the alpha-level and it’s meaning.<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>It might be confusing that i say “specify” a null-hypothesis here.
Is the null-hypothesis not by definition that there is no difference, i.e. that the coin is fair at 50%.
Well, yes and no.
Of course assuming coin-fairness is the most logical thing to do here but in real life, no matter what research question you are investigating, you will close to <em>always</em> find a difference between groups.
If you keep increasing the sample size, at some point the effect will always be significant, no matter how small the deviation is.
This is, we could even find the unfairness of the coin if it is only 51%.
But is this 51% really big enough to care about?
Maybe, maybe not, but we can define a <em>smallest effect size of interest</em> and use <em>Equivalence testing</em> in which the null-hypothesis is a certain range of small deviations from the actual point of no-difference in which we say that the effect is too small to care about.
Equivalence testing is not new but surprisingly unknown and/or uncommon in the psychological literature.
If you are interested in Equivalence Testing, you should check out the great <a href="https://journals.sagepub.com/doi/10.1177/2515245918770963">paper(s)</a> and <a href="http://daniellakens.blogspot.com/2018/08/equivalence-testing-and-second.html">blog-post(s)</a> about it by <a href="http://daniellakens.blogspot.com/">Daniel Lakens</a> and colleagues.<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>For those unfamiliar with this reference: Consider watching Dark Knight, it’s a great movie. In short, the displayed character, Harvey Dent, a former state lawyer, falls from grace and and loses his faith in the law system. He takes the law into his own hands and decides whether people will be sentenced (i.e. killed) by tossing a coin.<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>Software like G*Power often uses different standardized effect sizes for different analyses.
However, in many cases standardized effect-sizes can be converted into each other.
If you ever need to do such a thing, <a href="http://hauselin.com">Hause Lin</a> made a nice <a href="http://escal.site/">conversion app</a>.<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p>Thereby justifying our alpha-level in this toy example.<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p>This might be a good point to open G*Power (maybe for the last time ever), to see whether you get the same conclusions there (spoiler: you will, and if not, that only shows that software like this is not necessarily easier to use).<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
<li id="fn11"><p>You can see that is it not a simulation as you will always get the <em>exact same</em> result whenever you run the code above.<a href="#fnref11" class="footnote-back">↩︎</a></p></li>
<li id="fn12"><p>In other words, instead of writing all possible coin-toss sequences down and counting how many of them would produce 55% heads with a certain amount of tosses, we could just run very many experiments in which we for example throw a coin 20 times.
If we repeat these 20 tosses 1,000 times, we get an approximation of how many heads the toss sequences produce on average.<a href="#fnref12" class="footnote-back">↩︎</a></p></li>
<li id="fn13"><p>Technically the vector contains FALSE instead of 0 and TRUE instead of 1. However, in R, and many other programming languages, the two are interchangeable, allowing us to calculate the mean in the same way.<a href="#fnref13" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
]]>
      </description>
    </item>
    
  </channel>
</rss>
